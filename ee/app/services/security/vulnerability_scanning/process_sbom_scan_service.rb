# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    # This service parses an SBOM document after it has been uploaded, extracts its components and scans them for
    # vulnerabilities. Scan results are built in memory in the form of Ruby objects before being serialized and
    # stored as an attachment to the ephemeral SbomScan record.
    # This scan does not interact with the Vulnerability Management system.
    class ProcessSbomScanService < ::BaseService
      class SbomScanBaseError < StandardError
        def retry_delay
          0
        end

        def retryable?
          true
        end
      end

      class SbomFileNotAvailableError < SbomScanBaseError
        def retry_delay
          5.seconds
        end
      end

      SbomScanFailedError = Class.new(SbomScanBaseError)

      class NonRetryableError < SbomScanBaseError
        def retryable?
          false
        end
      end

      UnprocessableSbomError = Class.new(NonRetryableError)
      InvalidSbomError = Class.new(NonRetryableError)

      def initialize(sbom_scan)
        @sbom_scan = sbom_scan
        @build = sbom_scan.build
        @pipeline = build.pipeline
        @project = build.project
      end

      # Scans the uploaded SBOM file for vulnerabilities and store result as an attachment to the ephemeral
      # SbomScan record.
      def execute
        validate_sbom_file_availability!

        sbom_scan.start!

        sbom_reports = parse_sbom_file

        validate_sbom_report!(sbom_reports)

        security_report = perform_security_scan(sbom_reports)

        if security_report.nil?
          raise SbomScanFailedError, "Failed to perform a vulnerability scan for sbom scan #{sbom_scan.id}"
        end

        save_result(security_report)

        sbom_scan.finish!

      rescue StandardError => e
        track_and_raise_error(e)
      end

      private

      attr_reader :sbom_scan, :build, :pipeline, :project

      # If the uploaded SBOM file is not yet available we want to raise a specific error and retry the scan after some
      # delay without marking it as failed.
      # NB: this should never happen with direct upload as we store the file to its final location before creating the
      # SbomScan record but can happen with other upload methods involving tempfile and copy mechanisms.
      def validate_sbom_file_availability!
        return if sbom_scan.sbom_file&.file&.exists?

        raise SbomFileNotAvailableError, "SBOM file is not available yet for sbom scan #{sbom_scan.id}"
      end

      # The sbom report must adhere to the CycloneDX spec and the GitLab CycloneDX taxonomy in order to be scanned.
      def validate_sbom_report!(sbom_reports)
        sbom_report = sbom_reports.reports.first

        unless sbom_report.valid?
          raise InvalidSbomError,
            "The provided SBOM report is invalid and has the following errors: #{sbom_report.errors}"
        end

        return if sbom_report.source&.source_type == :dependency_scanning

        raise InvalidSbomError,
          "The provided SBOM report must follow the GitLab CycloneDX property taxonomy for Dependency Scanning."
      end

      def parse_sbom_file
        sbom_file_content = sbom_scan.sbom_file.read

        ::Gitlab::Ci::Reports::Sbom::Reports.new.tap do |sbom_reports|
          ::Gitlab::Ci::Reports::Sbom::Report.new.tap do |report|
            ::Gitlab::Ci::Parsers.fabricate!(:cyclonedx).parse!(sbom_file_content, report)
            sbom_reports.add_report(report)
          end
        end
      rescue StandardError => e
        raise UnprocessableSbomError, "The provided SBOM report can't be processed: #{e.message}"
      end

      def perform_security_scan(sbom_reports)
        ::Gitlab::VulnerabilityScanning::SecurityReportBuilder.new(
          sbom_reports: sbom_reports,
          project: project,
          pipeline: pipeline
        ).execute
      end

      def save_result(security_report)
        # TODO: consider optimizing empty scan results and maybe return a static empty array
        # rather than storing it in a file attachment.

        result_json = ::API::Entities::Security::VulnerabilityScanning::SbomScanResult.represent(security_report)

        begin
          result_file = Tempfile.new(['sbom_scan_result', '.json'])
          result_file.write(Gitlab::Json.dump(result_json))

          sbom_scan.result_file = result_file
          sbom_scan.result_file.filename = 'sbom_scan_result.json'
          sbom_scan.store_result_file!
        ensure
          result_file.close!
        end
      end

      def track_and_raise_error(error)
        ::Gitlab::ErrorTracking.track_and_raise_exception(
          error,
          sbom_scan_id: sbom_scan.id,
          project_id: project.id,
          pipeline_id: pipeline.id
        )
      end
    end
  end
end
