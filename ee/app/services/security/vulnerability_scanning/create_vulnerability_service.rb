# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    class CreateVulnerabilityService
      include Gitlab::Utils::StrongMemoize

      # This service creates vulnerabilities for an advisory and affected SBOM components.
      # Continuous vulnerability scans are expensive to perform, so the service tries to
      # handle errors gracefully whenever possible. In other words, if we cannot create a
      # vulnerability for Project A we still attempt to create one for Project B, Project C...Project N.
      #
      # @param advisory [::Gitlab::VulnerabilityScanning::Advisory] :advisory
      # @param affected_components [Array<::Gitlab::VulnerabilityScanning::PossiblyAffectedComponent>]
      #   :affected_components
      #
      # @return [ServiceResponse] The service responds with a success if one or more vulnerabilities were created,
      #   and an error if no vulnerabilities could be created. If successful, the service response payload contains
      #   a `vulnerability_ids` key with the IDs of the new vulnerabilities. In addition, it will always return the
      #   `project_ids_with_upsert` arrays field. This field contains the IDs of projects that were processed during
      #   vulnerability creation.
      def self.execute(...)
        new(...).execute
      end

      def initialize(finding_maps)
        # We need to deduplicate all finding maps by UUID so that they receive a finding ID.
        # Without this, the Security::Ingestion::Tasks::IngestFindings task will fail to set
        # the finding ID.
        # For full details of issue see https://gitlab.com/gitlab-org/gitlab/-/issues/432870#note_1681011775
        @finding_maps = finding_maps.uniq(&:uuid)
        @project_ids_with_upsert = Set[]
      end

      def execute
        reject_findings_maps_exceeding_quota

        if finding_maps.empty?
          return ServiceResponse.success(
            message: "All finding maps filtered out and no vulnerabilities created",
            payload: {
              vulnerability_ids: [],
              project_ids_with_upsert: project_ids_with_upsert.to_a
            })
        end

        vulnerability_ids = ::Security::Ingestion::IngestCvsSliceService.execute(finding_maps)

        trigger_vulnerabilities_created_event

        track_upsert_for_project_id

        process_archival_and_traversal_ids_changes

        ServiceResponse.success(message: "Vulnerabilities were created",
          payload: {
            vulnerability_ids: vulnerability_ids,
            project_ids_with_upsert: project_ids_with_upsert.to_a
          })
      rescue StandardError => error
        process_unrecoverable_error(error)
      end

      private

      attr_reader :finding_maps, :project_ids_with_upsert

      def reject_findings_maps_exceeding_quota
        finding_maps.reject! { |finding_map| !can_be_processed?(finding_map) }
      end

      def can_be_processed?(finding_map)
        finding_map.project.vulnerability_quota.validate!
      end

      def track_upsert_for_project_id
        project_ids_with_upsert.merge(project_ids)
      end

      def process_unrecoverable_error(error)
        ::Gitlab::ErrorTracking.track_exception(error,
          message: "Continuous vulnerability scanning failed to create vulnerabilities",
          project_ids_with_upsert: project_ids_with_upsert.to_a)

        ServiceResponse.error(message: "Vulnerabilities were not created", payload: {
          error: error,
          project_ids_with_upsert: project_ids_with_upsert.to_a
        })
      end

      def process_archival_and_traversal_ids_changes
        schedule_updating_archived_status_if_needed
        schedule_updating_traversal_ids_if_needed
      end

      def schedule_updating_archived_status_if_needed
        return unless map_of_projects_to_adjust[:archival_updated].present?

        Vulnerabilities::UpdateArchivedAttributeOfVulnerabilityReadsWorker.bulk_perform_async_with_contexts(
          map_of_projects_to_adjust[:archival_updated],
          arguments_proc: ->(project) { project.id },
          context_proc: ->(project) { { project: project } }
        )
      end

      def schedule_updating_traversal_ids_if_needed
        return unless map_of_projects_to_adjust[:traversal_ids_updated].present?

        Vulnerabilities::UpdateNamespaceIdsOfVulnerabilityReadsWorker.bulk_perform_async_with_contexts(
          map_of_projects_to_adjust[:traversal_ids_updated],
          arguments_proc: ->(project) { project.id },
          context_proc: ->(project) { { project: project } }
        )
      end

      def map_of_projects_to_adjust
        @map_of_projects_to_adjust ||= projects.each_with_object(Hash.new { |h, k| h[k] = [] }) do |project, map|
          project_with_most_recent_changes = projects_with_most_recent_changes.find { |p| p == project }

          add_into_archival_updated_list_if_needed(map, project, project_with_most_recent_changes)
          add_into_traversal_ids_updated_list_if_needed(map, project, project_with_most_recent_changes)
        end
      end

      def add_into_archival_updated_list_if_needed(map, project, project_with_most_recent_changes)
        return if project.archived == project_with_most_recent_changes.archived

        map[:archival_updated] << project
      end

      def add_into_traversal_ids_updated_list_if_needed(map, project, project_with_most_recent_changes)
        return if project.namespace.traversal_ids == project_with_most_recent_changes.namespace.traversal_ids

        map[:traversal_ids_updated] << project
      end

      def projects_with_most_recent_changes
        @projects_with_most_recent_changes ||= Project.id_in(project_ids).with_namespace.to_a
      end

      def project_ids
        projects.map(&:id)
      end
      strong_memoize_attr :project_ids

      def projects
        finding_maps.map(&:project)
      end
      strong_memoize_attr :projects

      def trigger_vulnerabilities_created_event
        return unless finding_data.present?

        ::Gitlab::EventStore.publish(vulnerabilities_created_event)
      end

      def vulnerabilities_created_event
        Sbom::VulnerabilitiesCreatedEvent.new(data: { findings: finding_data }.with_indifferent_access)
      end

      def finding_data
        finding_maps.filter_map do |finding_map|
          next unless include_finding_map?(finding_map)

          {
            uuid: finding_map.uuid,
            vulnerability_id: finding_map.vulnerability_id,
            project_id: finding_map.project.id,
            package_name: finding_map.location.package_name,
            package_version: finding_map.location.package_version,
            purl_type: finding_map.purl_type
          }
        end
      end
      strong_memoize_attr :finding_data

      def include_finding_map?(finding_map)
        finding_map.report_type == 'dependency_scanning' &&
          Feature.enabled?(:update_sbom_occurrences_vulnerabilities_on_cvs, finding_map.project)
      end
    end
  end
end
