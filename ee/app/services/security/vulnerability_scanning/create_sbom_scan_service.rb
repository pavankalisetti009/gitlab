# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    class CreateSbomScanService < ::BaseService
      FILE_TYPE = :cyclonedx

      def initialize(build)
        @build = build
        @project = build.project
      end

      # Authorize SBOM file upload to be scanned
      #
      # @param filesize [Integer] The size of the file to be uploaded
      # @return [ServiceResponse] The response object containing the authorization headers or an error
      def authorize(filesize: nil)
        result = validate_requirements(filesize: filesize)
        return result if result.error?

        headers = ::Security::VulnerabilityScanning::SbomScanUploader.workhorse_authorize(
          has_length: false,
          maximum_size: max_size,
          use_final_store_path: true,
          final_store_path_config: {
            override_path: ::Security::VulnerabilityScanning::SbomScanUploader
              .generate_final_store_path(project.id, build.id)
          }
        )

        ServiceResponse.success(payload: { headers: headers })
      end

      # Create an SbomScan record for the uploaded SBOM file and schedule a vulnerability scan
      # @param sbom_file [File] The uploaded SBOM file
      #
      # @return [ServiceResponse] The response object containing the created SbomScan record or an error
      def execute(sbom_file)
        result = validate_requirements(filesize: sbom_file.size)
        return result if result.error?

        sbom_scan = ::Security::VulnerabilityScanning::SbomScan.create(
          build: build,
          project: project,
          sbom_file: sbom_file
        )

        if sbom_scan.persisted?
          sbom_scan.store_sbom_file!

          ::Security::VulnerabilityScanning::ProcessSbomScanWorker.perform_async(sbom_scan.id)

          ServiceResponse.success(payload: { sbom_scan: sbom_scan })
        else
          ServiceResponse.error(
            message: sbom_scan.errors.full_messages,
            reason: :unprocessable_entity
          )
        end
      end

      private

      attr_reader :build, :project

      def validate_requirements(filesize:)
        return too_large_error if too_large?(filesize)

        ServiceResponse.success
      end

      def too_large?(size)
        size > max_size if size
      end

      def max_size
        Ci::JobArtifact.max_artifact_size(type: FILE_TYPE, project: project)
      end

      def too_large_error
        ServiceResponse.error(
          message: 'file size has reached maximum size limit',
          reason: :payload_too_large
        )
      end
    end
  end
end
