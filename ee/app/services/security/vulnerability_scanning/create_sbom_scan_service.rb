# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    class CreateSbomScanService < ::BaseService
      include Gitlab::Utils::StrongMemoize

      FILE_TYPE = :cyclonedx

      def initialize(build)
        @build = build
        @project = build.project
      end

      # Authorize SBOM file upload to be scanned
      #
      # @param filesize [Integer] The size of the file to be uploaded
      # @return [ServiceResponse] The response object containing the authorization headers or an error
      def authorize(filesize: nil)
        result = validate_requirements(filesize: filesize)
        return result if result.error?

        headers = ::Security::VulnerabilityScanning::SbomScanUploader.workhorse_authorize(
          has_length: false,
          maximum_size: max_size,
          use_final_store_path: true,
          final_store_path_config: {
            override_path: ::Security::VulnerabilityScanning::SbomScanUploader
              .generate_final_store_path(project.id, build.id)
          }
        )

        ServiceResponse.success(payload: { headers: headers })
      end

      # Create an SbomScan record for the uploaded SBOM file and schedule a vulnerability scan
      # @param sbom_file [File] The uploaded SBOM file
      #
      # @return [ServiceResponse] The response object containing the created SbomScan record or an error
      def execute(sbom_file)
        result = validate_requirements(filesize: sbom_file.size)
        return result if result.error?

        sbom_scan = ::Security::VulnerabilityScanning::SbomScan.create(
          build: build,
          project: project,
          sbom_file: sbom_file
        )

        if sbom_scan.persisted?
          sbom_scan.store_sbom_file!

          worker_class = if throttled?
                           ::Security::VulnerabilityScanning::ProcessSbomScanThrottledWorker
                         else
                           ::Security::VulnerabilityScanning::ProcessSbomScanWorker
                         end

          worker_class.perform_async(sbom_scan.id)

          ServiceResponse.success(payload: {
            sbom_scan: sbom_scan,
            throttled: throttled?,
            project_throttling_resets_in: calculate_throttling_resets_in
          })
        else
          ServiceResponse.error(
            message: sbom_scan.errors.full_messages,
            reason: :unprocessable_entity
          )
        end
      end

      private

      attr_reader :build, :project

      def validate_requirements(filesize:)
        return too_large_error if too_large?(filesize)

        ServiceResponse.success
      end

      def too_large?(size)
        size > max_size if size
      end

      def max_size
        Ci::JobArtifact.max_artifact_size(type: FILE_TYPE, project: project)
      end

      def too_large_error
        ServiceResponse.error(
          message: 'file size has reached maximum size limit',
          reason: :payload_too_large
        )
      end

      def throttled?
        Gitlab::ApplicationRateLimiter.throttled?(:dependency_scanning_sbom_scan_api_throttling, scope: project)
      end
      strong_memoize_attr :throttled?

      def calculate_throttling_resets_in
        return 0 unless throttled?

        interval_in_seconds = Gitlab::ApplicationRateLimiter.interval(:dependency_scanning_sbom_scan_api_throttling)

        # Using Time.now to mimic the behavior of ApplicationRateLimiter and get accurate retry after value
        _, time_elapsed_in_period = Time.now.to_i.divmod(interval_in_seconds)
        interval_in_seconds - time_elapsed_in_period + 1
      end
    end
  end
end
