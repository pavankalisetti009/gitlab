<script>
import {
  GlButton,
  GlTooltipDirective,
  GlAlert,
  GlSprintf,
  GlFormRadio,
  GlFormRadioGroup,
} from '@gitlab/ui';
import { s__, sprintf, n__ } from '~/locale';
import glFeatureFlagsMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import { extractPolicyContent } from 'ee/security_orchestration/components/utils';
import {
  policyBodyToYaml,
  policyToYaml,
} from 'ee/security_orchestration/components/policy_editor/utils';
import {
  RULES_LABEL,
  ADD_RULE_LABEL,
  ACTIONS_LABEL,
  EDITOR_MODE_RULE,
  EDITOR_MODE_YAML,
  SECURITY_POLICY_ACTIONS,
  MAX_ALLOWED_RULES_LENGTH,
  ACTION_SECTION_DISABLE_ERROR,
  RULES_SECTION_DISABLE_ERROR,
} from '../constants';
import EditorLayout from '../editor_layout.vue';
import DisabledSection from '../disabled_section.vue';
import {
  ACTION_TYPES_SELECTOR_FORMAT,
  DEFAULT_VULNERABILITY_MANAGEMENT_POLICY,
  AUTO_RESOLVE,
  OVERRIDE,
} from './constants';
import {
  createPolicyObject,
  buildAction,
  getSelectedActionType,
  buildRuleForAction,
  validatePolicyRuleActionCombination,
  setPolicyCache,
} from './utils';
import RuleSection from './rule/rule_section.vue';
import ActionSection from './action/action_section.vue';

export default {
  ACTION_TYPES_SELECTOR_FORMAT,
  SECURITY_POLICY_ACTIONS,
  EDITOR_MODE_RULE,
  EDITOR_MODE_YAML,
  i18n: {
    ACTION_SECTION_DISABLE_ERROR,
    RULES_SECTION_DISABLE_ERROR,
    RULES_LABEL,
    ADD_RULE_LABEL,
    ACTIONS_LABEL,
    limit: s__(
      'SecurityOrchestration|In each pipeline, a %{boldStart}maximum of 1000%{boldEnd} vulnerabilities that are %{italicStart}no longer detected%{italicEnd} will be set to status %{italicStart}Resolved%{italicEnd} until all have been auto-resolved.',
    ),
    exceedingRulesMessage: s__(
      'SecurityOrchestration|You can add a maximum of %{rulesCount} %{rules}.',
    ),
  },
  components: {
    GlButton,
    GlAlert,
    GlSprintf,
    GlFormRadio,
    GlFormRadioGroup,
    EditorLayout,
    RuleSection,
    ActionSection,
    DisabledSection,
  },
  directives: { GlTooltip: GlTooltipDirective },
  mixins: [glFeatureFlagsMixin()],
  inject: ['namespacePath'],
  props: {
    existingPolicy: {
      type: Object,
      required: false,
      default: null,
    },
    isCreating: {
      type: Boolean,
      required: true,
    },
    isDeleting: {
      type: Boolean,
      required: true,
    },
    isEditing: {
      type: Boolean,
      required: true,
    },
    selectedPolicyType: {
      type: String,
      required: true,
    },
  },
  data() {
    let yamlEditorValue;

    if (this.existingPolicy) {
      yamlEditorValue = policyToYaml(this.existingPolicy, this.selectedPolicyType);
    } else {
      yamlEditorValue = DEFAULT_VULNERABILITY_MANAGEMENT_POLICY;
    }

    const { policy, parsingError } = createPolicyObject(yamlEditorValue);

    return {
      mode: EDITOR_MODE_RULE,
      policy,
      cachedState: setPolicyCache(policy),
      yamlEditorValue,
      parsingError,
      selectedActionType: getSelectedActionType(policy?.actions),
    };
  },
  computed: {
    isAutoResolveAction() {
      return this.policy?.actions?.[0]?.type === AUTO_RESOLVE;
    },
    hasAutoDismissVulnerabilityPolicies() {
      return this.glFeatures.autoDismissVulnerabilityPolicies;
    },
    hasSecurityPoliciesSeverityCustomize() {
      return this.glFeatures.securityPoliciesSeverityCustomize;
    },
    validationActionRulesMessage() {
      if (this.hasAutoDismissVulnerabilityPolicies) {
        return (
          validatePolicyRuleActionCombination(this.policy) ||
          this.$options.i18n.ACTION_SECTION_DISABLE_ERROR
        );
      }

      return this.$options.i18n.ACTION_SECTION_DISABLE_ERROR;
    },
    validationAlertRulesMessage() {
      if (this.hasAutoDismissVulnerabilityPolicies) {
        return (
          validatePolicyRuleActionCombination(this.policy) ||
          this.$options.i18n.RULES_SECTION_DISABLE_ERROR
        );
      }

      return this.$options.i18n.RULES_SECTION_DISABLE_ERROR;
    },
    hasNewSplitView() {
      return this.glFeatures.securityPoliciesSplitView;
    },
    canAddRule() {
      return this.policy.rules?.length < MAX_ALLOWED_RULES_LENGTH;
    },
    addRuleTitle() {
      const rules = n__('rule', 'rules', this.policy.rules?.length);
      return sprintf(this.$options.i18n.exceedingRulesMessage, {
        rulesCount: MAX_ALLOWED_RULES_LENGTH,
        rules,
      });
    },
    actionTypeOptions() {
      if (!this.hasSecurityPoliciesSeverityCustomize) {
        return this.$options.ACTION_TYPES_SELECTOR_FORMAT.filter(
          (option) => option.value !== OVERRIDE,
        );
      }
      return this.$options.ACTION_TYPES_SELECTOR_FORMAT;
    },
  },
  methods: {
    areManifestsEqual(manifest) {
      const policyManifest = policyToYaml(this.policy, this.selectedPolicyType);
      return policyManifest === manifest && this.hasNewSplitView;
    },
    changeEditorMode(mode) {
      this.mode = mode;
    },
    async handleModifyPolicy(action) {
      /**
       * backend only accepts the old format
       * policy body is extracted
       * and policy type is added to a policy body
       */
      const policy = extractPolicyContent({
        manifest: this.yamlEditorValue,
        type: this.selectedPolicyType,
        withType: true,
      });

      this.$emit('save', {
        action,
        policy: policyBodyToYaml(policy),
      });
    },
    handleUpdateProperty(property, value) {
      this.policy[property] = value;
      this.updateYamlEditorValue(this.policy);
    },
    handleUpdateYaml(manifest) {
      if (this.areManifestsEqual(manifest)) {
        return;
      }

      const { policy, parsingError } = createPolicyObject(manifest);
      this.yamlEditorValue = manifest;
      this.parsingError = parsingError;
      this.policy = policy;
    },
    updateYamlEditorValue(policy) {
      this.yamlEditorValue = policyToYaml(policy, this.selectedPolicyType);
    },
    addRule() {
      this.policy.rules.push(buildRuleForAction(this.selectedActionType));
      this.updateYamlEditorValue(this.policy);
    },
    updateAction(values) {
      this.policy.actions.splice(0, 1, values);
      this.updateYamlEditorValue(this.policy);
    },
    updateRule(index, values) {
      this.policy.rules.splice(index, 1, values);
      this.updateYamlEditorValue(this.policy);
    },
    removeRule(index) {
      this.policy.rules.splice(index, 1);
      this.updateYamlEditorValue(this.policy);
    },
    setActionType(type) {
      this.selectedActionType = type;

      const cached = this.cachedState[type];

      if (cached) {
        this.policy = cached;
      } else {
        this.policy.rules = [buildRuleForAction(type)];
        this.policy.actions = [buildAction(type)];
      }

      this.cachedState[type] = { ...this.policy };

      this.updateYamlEditorValue(this.policy);
    },
  },
};
</script>
<template>
  <editor-layout
    :policy="policy"
    :yaml-editor-value="yamlEditorValue"
    :is-editing="isEditing"
    :is-removing-policy="isDeleting"
    :is-updating-policy="isCreating"
    @remove-policy="handleModifyPolicy($options.SECURITY_POLICY_ACTIONS.REMOVE)"
    @save-policy="handleModifyPolicy"
    @update-editor-mode="changeEditorMode"
    @update-property="handleUpdateProperty"
    @update-yaml="handleUpdateYaml"
  >
    <template #actions-first>
      <disabled-section
        :disabled="parsingError.actions"
        :error="validationActionRulesMessage"
        data-testid="disabled-action"
      >
        <template #title>
          <h4>{{ $options.i18n.ACTIONS_LABEL }}</h4>
        </template>

        <template #disabled>
          <div class="gl-rounded-base gl-bg-subtle gl-p-6"></div>
        </template>

        <gl-form-radio-group
          v-if="hasAutoDismissVulnerabilityPolicies"
          :checked="selectedActionType"
          stacked
          class="gl-mb-6"
          :class="{ 'gl-mt-4': parsingError.actions }"
          data-testid="action-type-selector"
          @change="setActionType"
        >
          <gl-form-radio
            v-for="option in actionTypeOptions"
            :key="option.value"
            :value="option.value"
          >
            {{ option.text }}
          </gl-form-radio>
        </gl-form-radio-group>

        <action-section :actions="policy.actions" @select="updateAction" />
      </disabled-section>
    </template>
    <template #rules>
      <disabled-section
        :disabled="parsingError.rules"
        :error="validationAlertRulesMessage"
        data-testid="disabled-rule"
      >
        <template #title>
          <h4>
            {{ $options.i18n.RULES_LABEL }}
          </h4>
        </template>

        <template #disabled>
          <div class="gl-rounded-base gl-bg-subtle gl-p-6"></div>
        </template>

        <gl-alert
          v-if="isAutoResolveAction"
          variant="info"
          :dismissible="false"
          class="gl-mb-4"
          :class="{ 'gl-mt-4': parsingError.rules }"
        >
          <gl-sprintf :message="$options.i18n.limit">
            <template #bold="{ content }">
              <strong>{{ content }}</strong>
            </template>
            <template #italic="{ content }">
              <em>{{ content }}</em>
            </template>
          </gl-sprintf>
        </gl-alert>

        <rule-section
          v-for="(rule, index) in policy.rules"
          :key="rule.id"
          :rule="rule"
          :index="index"
          @changed="updateRule(index, $event)"
          @remove="removeRule(index)"
        />

        <div class="security-policies-bg-subtle gl-mb-5 gl-rounded-base gl-p-5">
          <span
            v-gl-tooltip="{
              disabled: canAddRule,
              title: addRuleTitle,
            }"
            data-testid="add-rule-wrapper"
          >
            <gl-button
              variant="link"
              data-testid="add-rule"
              :disabled="!canAddRule"
              @click="addRule"
            >
              {{ $options.i18n.ADD_RULE_LABEL }}
            </gl-button>
          </span>
        </div>
      </disabled-section>
    </template>
  </editor-layout>
</template>
