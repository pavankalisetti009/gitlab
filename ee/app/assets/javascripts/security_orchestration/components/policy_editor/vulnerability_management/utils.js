import { uniqueId } from 'lodash';
import { s__ } from '~/locale';
import { POLICY_TYPE_COMPONENT_OPTIONS } from 'ee/security_orchestration/components/constants';
import { fromYaml } from 'ee/security_orchestration/components/utils';
import { hasInvalidKey } from 'ee/security_orchestration/components/policy_editor/utils';
import {
  NO_LONGER_DETECTED_RULE_TYPE,
  AUTO_RESOLVE,
  AUTO_DISMISS,
  OVERRIDE,
  VULNERABILITY_DETECTED_TYPE,
} from './constants';

/**
 * Validates valid combinations of rules and actions
 * for vulnerability policy
 * @param actions
 * @param rules
 * @returns {*|string}
 */
export const validatePolicyRuleActionCombination = ({ actions = [], rules = [] } = {}) => {
  if (!Array.isArray(actions) || !Array.isArray(rules)) {
    return s__(`SecurityOrchestration|Actions and rules must be an array.`);
  }

  const activeActions = actions?.filter(Boolean) || [];
  const activeRules = rules?.filter(Boolean) || [];

  const hasBothRuleTypes = new Set(activeRules.map(({ type }) => type)).size > 1;

  if (hasBothRuleTypes) {
    return s__(
      'SecurityOrchestration|A vulnerability management policy can contain only rules of same type.',
    );
  }

  const hasType = (items, type) => items.some((item) => item.type === type);

  const hasDetectedRule = hasType(activeRules, VULNERABILITY_DETECTED_TYPE);
  const hasNotFoundRules = hasType(activeRules, NO_LONGER_DETECTED_RULE_TYPE);
  const hasAutoResolveAction = hasType(activeActions, AUTO_RESOLVE);
  const hasAutoDismissAction = hasType(activeActions, AUTO_DISMISS);

  if (hasDetectedRule && hasAutoResolveAction) {
    return s__(
      'SecurityOrchestration|You can use auto-resolve actions only with no longer detected rules.',
    );
  }

  if (hasNotFoundRules && hasAutoDismissAction) {
    return s__('SecurityOrchestration|You can use auto-dismiss actions only with detected rules.');
  }

  if (hasAutoResolveAction && hasAutoDismissAction) {
    return s__(
      'SecurityOrchestration|A vulnerability management policy can contain only one action.',
    );
  }

  return '';
};

/**
 * Validate policy actions and rules keys
 * @param policy
 * @returns {Object} errors object. If empty, policy is valid.
 */
export const validatePolicy = (policy) => {
  const error = {};
  const rulesKeys = ['type', 'scanners', 'severity_levels'];
  const actionsKeys = ['type'];
  const actionTypes = [AUTO_RESOLVE];

  const { autoDismissVulnerabilityPolicies = false } = gon?.features || {};
  let hasInvalidRuleActionCombination = false;

  if (autoDismissVulnerabilityPolicies) {
    actionTypes.push(AUTO_DISMISS);
    actionsKeys.push('dismissal_reason');
    rulesKeys.push('criteria');
    hasInvalidRuleActionCombination = validatePolicyRuleActionCombination(policy).length > 0;
  }

  const hasInvalidActionTypes = (items) => items?.some((item) => !actionTypes.includes(item.type));

  const hasInvalidItems = (items, keys) =>
    items?.some((item) => hasInvalidKey(item, [...keys, 'id']));

  if (
    hasInvalidItems(policy.actions, actionsKeys) ||
    hasInvalidActionTypes(policy.actions) ||
    hasInvalidRuleActionCombination
  ) {
    error.actions = true;
  }

  if (hasInvalidItems(policy.rules, rulesKeys) || hasInvalidRuleActionCombination) {
    error.rules = true;
  }

  return error;
};

/**
 * Converts a security policy from yaml to an object
 * @param {String} manifest a security policy in yaml form
 * @returns {Object} security policy object and any errors
 */
export const createPolicyObject = (manifest) => {
  const policy = fromYaml({
    manifest,
    type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter,
  });
  const parsingError = validatePolicy(policy);
  return { policy, parsingError };
};

/*
  Returns a new default rule of the no longer detected type.
*/
export const buildDefaultNoLongerDetectedRule = () => {
  return {
    id: uniqueId('rule_'),
    type: NO_LONGER_DETECTED_RULE_TYPE,
    scanners: [],
    severity_levels: [],
  };
};

export const buildDefaultVulnerabilityFoundCriteria = () => {
  return {
    type: '',
    value: '',
  };
};

export const buildDefaultVulnerabilityFoundRule = () => {
  return {
    id: uniqueId('rule_'),
    type: VULNERABILITY_DETECTED_TYPE,
    criteria: [buildDefaultVulnerabilityFoundCriteria()],
  };
};

export const buildRuleForAction = (actionType) => {
  return actionType === AUTO_RESOLVE
    ? buildDefaultNoLongerDetectedRule()
    : buildDefaultVulnerabilityFoundRule();
};

export const buildAction = (type) => {
  if (type === OVERRIDE) {
    return {
      type,
      customize: '',
    };
  }
  return {
    type,
  };
};

export const getSelectedActionType = (actions = []) => {
  if (!Array.isArray(actions) || !actions.length) {
    return AUTO_RESOLVE;
  }

  return actions[0].type || AUTO_RESOLVE;
};

export const setPolicyCache = (policy) => {
  const cachedState = {
    [AUTO_DISMISS]: null,
    [AUTO_RESOLVE]: null,
    [OVERRIDE]: null,
  };

  const type = policy?.actions?.[0]?.type;

  if (type) {
    cachedState[type] = { ...policy };
  }

  return cachedState;
};
