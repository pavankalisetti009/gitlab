import { safeLoad } from 'js-yaml';
import { uniqueId } from 'lodash';
import { POLICY_TYPE_COMPONENT_OPTIONS } from 'ee/security_orchestration/components/constants';
import { extractPolicyContent } from 'ee/security_orchestration/components/utils';
import { hasInvalidKey } from '../utils';
import { NO_LONGER_DETECTED_RULE_TYPE } from './constants';

/**
 * Construct a policy object expected by the policy editor from a yaml manifest.
 * @param {Object} options
 * @param {String}  options.manifest a security policy in yaml form
 * @param {Boolean} options.validateRuleMode if properties should be validated
 * @returns {Object} security policy object and any errors
 */
export const fromYaml = ({ manifest, validateRuleMode = false }) => {
  const error = {};
  try {
    const { securityPoliciesNewYamlFormat = false } = window.gon?.features || {};
    const policy = securityPoliciesNewYamlFormat
      ? extractPolicyContent({
          manifest,
          type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter,
          withType: true,
        })
      : safeLoad(manifest, { json: true });

    if (validateRuleMode) {
      const actionsKeys = ['type'];
      const actionTypes = ['auto_resolve'];
      const rulesKeys = ['type', 'scanners', 'severity_levels'];

      const hasInvalidActionTypes = (items, keys) =>
        items?.some((item) => hasInvalidKey(item, keys, true));

      const hasInvalidItems = (items, keys) =>
        items?.some((item) => hasInvalidKey(item, [...keys, 'id']));

      if (
        hasInvalidItems(policy.actions, actionsKeys) ||
        hasInvalidActionTypes(policy.actions, actionTypes)
      ) {
        error.actions = true;
      }

      if (hasInvalidItems(policy.rules, rulesKeys)) {
        error.rules = true;
      }
    }

    return { policy, parsingError: error };
  } catch {
    /**
     * Catch parsing error of safeLoad
     */
    return { policy: {}, parsingError: { actions: true, rules: true } };
  }
};

/**
 * Converts a security policy from yaml to an object
 * @param {String} manifest a security policy in yaml form
 * @returns {Object} security policy object and any errors
 */
export const createPolicyObject = (manifest) => fromYaml({ manifest, validateRuleMode: true });

/*
  Returns a new default rule of the no longer detected type.
*/
export const buildDefaultNoLongerDetectedRule = () => {
  return {
    id: uniqueId('rule_'),
    type: NO_LONGER_DETECTED_RULE_TYPE,
    scanners: [],
    severity_levels: [],
  };
};
