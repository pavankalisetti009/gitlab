<script>
import { GlButton } from '@gitlab/ui';
import { convertToGraphQLId } from '~/graphql_shared/utils';
import { TYPENAME_ISSUE } from '~/graphql_shared/constants';
import RelatedIssuableInput from '~/related_issues/components/related_issuable_input.vue';
import createVulnerabilityIssueLinkMutation from 'ee/security_dashboard/graphql/mutations/vulnerability_issue_link_create.mutation.graphql';
import { getAddRelatedIssueRequestParams } from 'ee/vulnerabilities/helpers';
import * as Sentry from '~/sentry/sentry_browser_wrapper';

export default {
  components: {
    RelatedIssuableInput,
    GlButton,
  },
  inject: {
    vulnerabilitiesQuery: {
      required: true,
    },
    vulnerabilitiesCountsQuery: {
      required: false,
      default: null,
    },
  },
  props: {
    selectedVulnerabilities: {
      type: Array,
      required: true,
    },
  },
  data() {
    return {
      isSubmitting: false,
      value: '',
      pendingReferences: [],
    };
  },
  computed: {
    autoCompleteSources() {
      return gl.GfmAutoComplete?.dataSources;
    },
    vulnerabilityIds() {
      return this.selectedVulnerabilities.map((vuln) => vuln.id);
    },
  },
  methods: {
    async handleSubmit() {
      if (this.pendingReferences.length === 0) {
        return;
      }

      this.isSubmitting = true;
      this.$emit('clear-rejected');

      let fulfilledCount = 0;

      // For each pending reference (an issue),
      // we execute mutation which links the selected vulnerabilities to that issue.
      const promises = this.pendingReferences.map(async (ref) => {
        const {
          data: {
            vulnerabilityIssueLinkCreate: { errors },
          },
        } = await this.$apollo.mutate({
          mutation: createVulnerabilityIssueLinkMutation,
          variables: {
            vulnerabilityIds: this.vulnerabilityIds,
            issueId: this.getIssueId(ref),
          },
          refetchQueries: [this.vulnerabilitiesQuery, this.vulnerabilitiesCountsQuery],
          awaitRefetchQueries: true,
        });

        if (errors?.length > 0) {
          throw errors;
        }

        fulfilledCount += 1;
        this.$emit('vulnerabilities-updated', this.vulnerabilityIds);
      });

      try {
        await Promise.all(promises);

        if (fulfilledCount > 0) {
          this.value = '';
          this.pendingReferences = [];
        }
      } catch (error) {
        Sentry.captureException(error);
        this.$emit('update-rejected', this.selectedVulnerabilities);
      } finally {
        this.isSubmitting = false;
      }
    },
    onInput({ untouchedRawReferences, touchedReference }) {
      const issues = this.pendingReferences.concat(untouchedRawReferences);
      this.pendingReferences = issues.filter((ref, index) => issues.indexOf(ref) === index);

      this.formatInput(touchedReference);
    },
    onRemove(indexToRemove) {
      this.pendingReferences = this.pendingReferences.filter(
        (_ref, index) => index !== indexToRemove,
      );
    },
    formatInput(touchedReference = '') {
      const startsWithNumber = /^\d/.test(touchedReference);

      if (startsWithNumber) {
        this.value = `${this.$options.pathIdSeparator}${touchedReference}`;
      } else {
        this.value = touchedReference;
      }
    },
    getIssueId(ref) {
      const { target_issue_iid: issueId } = getAddRelatedIssueRequestParams(ref);
      return convertToGraphQLId(TYPENAME_ISSUE, issueId);
    },
  },
  autoCompleteOptions: {
    issues: true,
  },
  pathIdSeparator: '#',
};
</script>

<template>
  <form
    class="gl-flex gl-flex-grow gl-flex-wrap gl-items-start gl-gap-3"
    @submit.prevent="handleSubmit"
  >
    <related-issuable-input
      input-id="existing_issue_attach_vulnerability"
      :input-value="value"
      :references="pendingReferences"
      :auto-complete-sources="autoCompleteSources"
      focus-on-mount
      inline
      :auto-complete-options="$options.autoCompleteOptions"
      :path-id-separator="$options.pathIdSeparator"
      class="gl-mb-0 gl-flex-grow"
      @addIssuableFormInput="onInput"
      @pendingIssuableRemoveRequest="onRemove"
    />
    <gl-button
      class="gl-ml-auto"
      :disabled="isSubmitting"
      data-testid="cancel-add-to-existing-button"
      @click="$emit('cancel')"
    >
      {{ __('Cancel') }}
    </gl-button>
    <gl-button
      data-testid="add-to-existing-button"
      type="submit"
      variant="confirm"
      :loading="isSubmitting"
      class="js-no-auto-disable"
    >
      {{ __('Add') }}
    </gl-button>
  </form>
</template>
