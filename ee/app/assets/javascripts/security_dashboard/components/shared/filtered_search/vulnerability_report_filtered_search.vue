<script>
import { GlFilteredSearch } from '@gitlab/ui';
import { isEqual } from 'lodash';
import glFeatureFlagMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import glAbilitiesMixin from '~/vue_shared/mixins/gl_abilities_mixin';
import { FILTERS } from '../vulnerability_report/constants';
import { ALL_ID } from '../filters/constants';
import {
  STATUS_TOKEN_DEFINITION,
  SEVERITY_TOKEN_DEFINITION,
  PROJECT_TOKEN_DEFINITION,
  IMAGE_TOKEN_DEFINITION,
  ACTIVITY_TOKEN_DEFINITION,
  CLUSTER_TOKEN_DEFINITION,
  SCANNER_TOKEN_DEFINITION,
  IDENTIFIER_TOKEN_DEFINITION,
  REPORT_TYPE_VENDOR_TOKEN_DEFINITION,
  REACHABILITY_TOKEN_DEFINITION,
  VALIDITY_CHECK_TOKEN_DEFINITION,
} from './tokens/constants';

const DEFINITIONS = {
  severity: SEVERITY_TOKEN_DEFINITION.token,
  state: STATUS_TOKEN_DEFINITION.token,
  projectId: PROJECT_TOKEN_DEFINITION.token,
  image: IMAGE_TOKEN_DEFINITION.token,
  activity: ACTIVITY_TOKEN_DEFINITION.token,
  cluster: CLUSTER_TOKEN_DEFINITION.token,
  scanner: SCANNER_TOKEN_DEFINITION.token,
  identifier: IDENTIFIER_TOKEN_DEFINITION.token,
  reportType: REPORT_TYPE_VENDOR_TOKEN_DEFINITION.token,
  reachability: REACHABILITY_TOKEN_DEFINITION.token,
  validityCheck: VALIDITY_CHECK_TOKEN_DEFINITION.token,
};

export default {
  components: {
    GlFilteredSearch,
  },
  mixins: [glFeatureFlagMixin(), glAbilitiesMixin()],
  inject: {
    projectFullPath: {
      default: '',
    },
    groupFullPath: {
      default: '',
    },
    dashboardType: {
      default: '',
    },
  },
  props: {
    availableFilters: {
      type: Array,
      required: true,
    },
  },
  data() {
    return {
      value: [],
      filters: {},
      filterKeys: {},
    };
  },
  computed: {
    tokens() {
      return this.availableFilters.map(this.getTokenDefinition).filter((token) => token);
    },
    advancedVulnerabilityManagement() {
      if (!this.glAbilities?.accessAdvancedVulnerabilityManagement) {
        return false;
      }

      return Boolean(this.projectFullPath || this.groupFullPath);
    },
  },
  created() {
    this.value = this.tokens
      .map((token) => ({
        type: token.type,
        value: {
          data: this.getValueForType(token.type, token.token.defaultValues),
          operator: token.operators[0]?.value,
        },
      }))
      .filter((token) => token.value.data?.length);

    this.handleTokenComplete();
  },
  methods: {
    clear() {
      const query = { ...this.$route.query };

      Object.keys(DEFINITIONS).forEach((tokenType) => {
        if (DEFINITIONS[tokenType]?.defaultValues) {
          query[tokenType] = ALL_ID;
        } else {
          delete query[tokenType];
        }
      });

      if (!isEqual(this.$route.query, query)) {
        this.$router.push({ query });
      }

      this.$emit('filters-changed', {});
    },
    getValueForType(type, defaultValues = []) {
      return this.$route.query[type]?.split?.(',') || defaultValues;
    },
    getTokenDefinition(type) {
      switch (type) {
        case FILTERS.STATUS:
          return STATUS_TOKEN_DEFINITION;
        case FILTERS.SEVERITY:
          return SEVERITY_TOKEN_DEFINITION;
        case FILTERS.PROJECT:
          return PROJECT_TOKEN_DEFINITION;
        case FILTERS.IMAGE:
          return IMAGE_TOKEN_DEFINITION;
        case FILTERS.ACTIVITY:
          return ACTIVITY_TOKEN_DEFINITION;
        case FILTERS.CLUSTER:
          return CLUSTER_TOKEN_DEFINITION;
        case FILTERS.SCANNER:
          return SCANNER_TOKEN_DEFINITION;
        case FILTERS.IDENTIFIER:
          if (this.advancedVulnerabilityManagement) {
            return IDENTIFIER_TOKEN_DEFINITION;
          }

          return undefined;
        case FILTERS.TOOL_SIMPLE:
        case FILTERS.TOOL_VENDOR:
        case FILTERS.REPORT_TYPE_SIMPLE:
        case FILTERS.REPORT_TYPE_VENDOR:
          return REPORT_TYPE_VENDOR_TOKEN_DEFINITION;
        case FILTERS.REACHABILITY:
          if (this.advancedVulnerabilityManagement) {
            return REACHABILITY_TOKEN_DEFINITION;
          }

          return undefined;
        case FILTERS.VALIDITY_CHECK:
          if (this.advancedVulnerabilityManagement && this.glFeatures?.validityCheckEsFilter) {
            return VALIDITY_CHECK_TOKEN_DEFINITION;
          }

          return undefined;
        default:
          return undefined;
      }
    },
    async handleTokenComplete() {
      await this.$nextTick();

      const newQuery = { ...this.$route.query };
      let newFilters = {};

      this.value.forEach(({ type, value }) => {
        const definition = DEFINITIONS[type];

        if (!definition) {
          return;
        }

        const filtersFn = definition.transformFilters;

        let transformedValue;

        if (typeof filtersFn === 'function') {
          const tokenFilters = filtersFn(value.data, { dashboardType: this.dashboardType });
          this.filterKeys[type] = Object.keys(tokenFilters);
          transformedValue = tokenFilters;
        } else {
          transformedValue = {
            [type]: Array.isArray(value.data) ? value.data.filter((i) => i !== ALL_ID) : value.data,
          };
        }

        newFilters = { ...newFilters, ...transformedValue };

        if (definition.transformQueryParams) {
          newQuery[type] = definition.transformQueryParams(value.data);
        } else if (isEqual(value.data, definition.defaultValues)) {
          newQuery[type] = undefined;
        } else {
          newQuery[type] = Array.isArray(value.data) ? value.data.join(',') : value.data;
        }
      });

      if (!isEqual(this.filters, newFilters)) {
        this.filters = newFilters;
        this.$emit('filters-changed', newFilters);
      }

      if (!isEqual(this.$route.query, newQuery)) {
        this.$router.push({ query: newQuery });
      }
    },
    handleTokenDestroy({ type: tokenType }) {
      const newQuery = { ...this.$route.query };

      // When we remove a token by clicking on X, the inputValues does not contain
      // that token anymore. Some of the tokens we have (e.g. Status and Activity Filter)
      // has a different default state when there are no query parameters. These filters
      // need to have an `ALL` value in the query parameter to prevent restoring default state
      // on page load.
      if (DEFINITIONS[tokenType]?.defaultValues) {
        newQuery[tokenType] = ALL_ID;
      } else {
        delete newQuery[tokenType];
      }

      if (!isEqual(this.$route.query, newQuery)) {
        this.$router.push({ query: newQuery });
      }

      const filters = { ...this.filters, [tokenType]: undefined };

      if (DEFINITIONS[tokenType]?.transformFilters) {
        this.filterKeys[tokenType]?.forEach((key) => {
          filters[key] = undefined;
        });
      }

      this.filters = filters;
      this.$emit('filters-changed', filters);
    },
  },
};
</script>
<template>
  <gl-filtered-search
    v-model="value"
    :placeholder="s__('Vulnerability|Search or filter vulnerabilities...')"
    :available-tokens="tokens"
    @token-destroy="handleTokenDestroy"
    @token-complete="handleTokenComplete"
    @clear="clear"
  />
</template>
