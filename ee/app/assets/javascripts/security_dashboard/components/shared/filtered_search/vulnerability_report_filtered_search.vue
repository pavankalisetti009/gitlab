<script>
import { nextTick } from 'vue';
import { GlFilteredSearch } from '@gitlab/ui';
import { isEqual, omitBy } from 'lodash';
import glFeatureFlagMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import glAbilitiesMixin from '~/vue_shared/mixins/gl_abilities_mixin';
import { FILTERS } from '../vulnerability_report/constants';
import { ALL_ID } from '../filters/constants';
import {
  STATUS_TOKEN_DEFINITION,
  SEVERITY_TOKEN_DEFINITION,
  PROJECT_TOKEN_DEFINITION,
  IMAGE_TOKEN_DEFINITION,
  ACTIVITY_TOKEN_DEFINITION,
  CLUSTER_TOKEN_DEFINITION,
  SCANNER_TOKEN_DEFINITION,
  IDENTIFIER_TOKEN_DEFINITION,
  REPORT_TYPE_VENDOR_TOKEN_DEFINITION,
  REACHABILITY_TOKEN_DEFINITION,
  VALIDITY_CHECK_TOKEN_DEFINITION,
} from './tokens/constants';

const TYPE_TO_TOKEN = {
  severity: SEVERITY_TOKEN_DEFINITION.token,
  state: STATUS_TOKEN_DEFINITION.token,
  projectId: PROJECT_TOKEN_DEFINITION.token,
  image: IMAGE_TOKEN_DEFINITION.token,
  activity: ACTIVITY_TOKEN_DEFINITION.token,
  cluster: CLUSTER_TOKEN_DEFINITION.token,
  scanner: SCANNER_TOKEN_DEFINITION.token,
  identifier: IDENTIFIER_TOKEN_DEFINITION.token,
  reportType: REPORT_TYPE_VENDOR_TOKEN_DEFINITION.token,
  reachability: REACHABILITY_TOKEN_DEFINITION.token,
  validityCheck: VALIDITY_CHECK_TOKEN_DEFINITION.token,
};

export default {
  name: 'VulnerabilityReportFilteredSearch',
  components: {
    GlFilteredSearch,
  },
  mixins: [glFeatureFlagMixin(), glAbilitiesMixin()],
  inject: {
    projectFullPath: {
      default: '',
    },
    groupFullPath: {
      default: '',
    },
    dashboardType: {
      default: '',
    },
  },
  props: {
    availableFilters: {
      type: Array,
      required: true,
    },
  },
  data() {
    return { value: [], filters: {} };
  },
  computed: {
    tokens() {
      return this.availableFilters
        .filter(this.isFilterEnabled)
        .map(this.convertFilterToToken)
        .filter((token) => token);
    },
    filteredValue() {
      return this.value.filter(({ type }) => Boolean(TYPE_TO_TOKEN[type]));
    },
    advancedVulnerabilityManagement() {
      if (!this.glAbilities?.accessAdvancedVulnerabilityManagement) {
        return false;
      }

      return Boolean(this.projectFullPath || this.groupFullPath);
    },
  },
  watch: {
    filters: {
      handler(newFilters) {
        this.$emit('filters-changed', newFilters);
      },
      deep: true,
    },
  },
  created() {
    this.value = this.tokens
      .map((token) => ({
        type: token.type,
        value: {
          data: this.getValueFromQuery(token.type) || this.getDefaultValues(token.token),
          operator: token.operators[0]?.value,
        },
      }))
      .filter((token) => token.value.data?.length);

    this.updateFilters();
    this.updateRouter();
  },
  methods: {
    isFilterEnabled(type) {
      switch (type) {
        case FILTERS.IDENTIFIER:
        case FILTERS.REACHABILITY:
          return this.advancedVulnerabilityManagement;
        case FILTERS.VALIDITY_CHECK:
          return this.advancedVulnerabilityManagement && this.glFeatures?.validityCheckEsFilter;
        default:
          return true;
      }
    },
    convertFilterToToken(type) {
      switch (type) {
        case FILTERS.STATUS:
          return STATUS_TOKEN_DEFINITION;
        case FILTERS.SEVERITY:
          return SEVERITY_TOKEN_DEFINITION;
        case FILTERS.PROJECT:
          return PROJECT_TOKEN_DEFINITION;
        case FILTERS.IMAGE:
          return IMAGE_TOKEN_DEFINITION;
        case FILTERS.ACTIVITY:
          return ACTIVITY_TOKEN_DEFINITION;
        case FILTERS.CLUSTER:
          return CLUSTER_TOKEN_DEFINITION;
        case FILTERS.SCANNER:
          return SCANNER_TOKEN_DEFINITION;
        case FILTERS.IDENTIFIER:
          return IDENTIFIER_TOKEN_DEFINITION;
        case FILTERS.REPORT_TYPE_SIMPLE:
        case FILTERS.REPORT_TYPE_VENDOR:
          return REPORT_TYPE_VENDOR_TOKEN_DEFINITION;
        case FILTERS.REACHABILITY:
          return REACHABILITY_TOKEN_DEFINITION;
        case FILTERS.VALIDITY_CHECK:
          return VALIDITY_CHECK_TOKEN_DEFINITION;
        default:
          return undefined;
      }
    },
    getValueFromQuery(type) {
      return this.$route.query[type]?.split?.(',');
    },
    getDefaultValues(token) {
      return token.defaultValues?.() || [];
    },
    getTokenData(type) {
      const token = this.value.find((t) => t.type === type);
      return token?.value?.data;
    },
    transformFilters(type, data) {
      const token = TYPE_TO_TOKEN[type];
      if (token?.transformFilters) {
        return token.transformFilters(data, { dashboardType: this.dashboardType });
      }

      return {
        [type]: Array.isArray(data) ? data.filter((i) => i !== ALL_ID) : data,
      };
    },
    transformQueryParams(type, data = []) {
      const token = TYPE_TO_TOKEN[type];
      if (isEqual(data, this.getDefaultValues(token))) {
        return undefined;
      }

      if (token?.transformQueryParams) {
        return token.transformQueryParams(data);
      }

      return Array.isArray(data) ? data.join(',') : data;
    },
    updateFilters() {
      this.filters = this.filteredValue.reduce((acc, { type, value }) => {
        return { ...acc, ...this.transformFilters(type, value.data) };
      }, {});
    },
    updateRouter() {
      const newQuery = this.tokens.reduce(
        (acc, { type }) => {
          const data = this.getTokenData(type);
          return {
            ...acc,
            [type]: this.transformQueryParams(type, data),
          };
        },
        { ...this.$route.query },
      );

      const filteredNewQuery = omitBy(newQuery, (i) => i === undefined);
      if (isEqual(this.$route.query, filteredNewQuery)) return;
      this.$router.push({ query: filteredNewQuery });
    },
    async update() {
      await nextTick();
      this.updateFilters();
      this.updateRouter();
    },
  },
};
</script>
<template>
  <gl-filtered-search
    v-model="value"
    :placeholder="s__('Vulnerability|Search or filter vulnerabilities...')"
    :available-tokens="tokens"
    @token-destroy="update"
    @token-complete="update"
    @clear="update"
  />
</template>
