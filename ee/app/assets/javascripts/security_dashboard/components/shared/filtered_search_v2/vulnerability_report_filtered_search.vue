<script>
import { GlFilteredSearch } from '@gitlab/ui';
import { isEqual } from 'lodash';
import { FILTERS } from '../vulnerability_report/constants';
import { ALL_ID } from '../filters/constants';
import {
  STATUS_TOKEN_DEFINITION,
  SEVERITY_TOKEN_DEFINITION,
  PROJECT_TOKEN_DEFINITION,
  IMAGE_TOKEN_DEFINITION,
  ACTIVITY_TOKEN_DEFINITION,
  CLUSTER_TOKEN_DEFINITION,
  SCANNER_TOKEN_DEFINITION,
  IDENTIFIER_TOKEN_DEFINITION,
  REPORT_TYPE_VENDOR_TOKEN_DEFINITION,
} from './tokens/constants';

const DEFINITIONS = {
  severity: SEVERITY_TOKEN_DEFINITION.token,
  state: STATUS_TOKEN_DEFINITION.token,
  projectId: PROJECT_TOKEN_DEFINITION.token,
  image: IMAGE_TOKEN_DEFINITION.token,
  activity: ACTIVITY_TOKEN_DEFINITION.token,
  cluster: CLUSTER_TOKEN_DEFINITION.token,
  scanner: SCANNER_TOKEN_DEFINITION.token,
  identifier: IDENTIFIER_TOKEN_DEFINITION.token,
  reportType: REPORT_TYPE_VENDOR_TOKEN_DEFINITION.token,
};

export default {
  components: {
    GlFilteredSearch,
  },
  props: {
    availableFilters: {
      type: Array,
      required: true,
    },
  },
  data() {
    return {
      value: [],
      filters: {},
    };
  },
  computed: {
    tokens() {
      return this.availableFilters.map(this.getTokenDefinition).filter((token) => token);
    },
  },
  created() {
    this.value = this.tokens
      .map((token) => ({
        type: token.type,
        value: {
          data: this.getValueForType(token.type, token.token.defaultValues),
          operator: token.operators[0]?.value,
        },
      }))
      .filter((token) => token.value.data?.length);
  },
  methods: {
    clear() {
      this.$emit('filters-changed', {});
    },
    getValueForType(type, defaultValues = []) {
      return this.$route.query[type]?.split(',') || defaultValues;
    },
    getTokenDefinition(type) {
      switch (type) {
        case FILTERS.STATUS:
          return STATUS_TOKEN_DEFINITION;
        case FILTERS.SEVERITY:
          return SEVERITY_TOKEN_DEFINITION;
        case FILTERS.PROJECT:
          return PROJECT_TOKEN_DEFINITION;
        case FILTERS.IMAGE:
          return IMAGE_TOKEN_DEFINITION;
        case FILTERS.ACTIVITY:
          return ACTIVITY_TOKEN_DEFINITION;
        case FILTERS.CLUSTER:
          return CLUSTER_TOKEN_DEFINITION;
        case FILTERS.SCANNER:
          return SCANNER_TOKEN_DEFINITION;
        case FILTERS.IDENTIFIER:
          return IDENTIFIER_TOKEN_DEFINITION;
        case FILTERS.REPORT_TYPE_SIMPLE:
        case FILTERS.REPORT_TYPE_VENDOR:
          return REPORT_TYPE_VENDOR_TOKEN_DEFINITION;
        default:
          return undefined;
      }
    },
    handleInput(inputValues) {
      const filterTokens = inputValues.filter(({ type }) =>
        Object.keys(DEFINITIONS).includes(type),
      );

      if (!filterTokens.length && this.isFirstLoad !== false) {
        this.isFirstLoad = false;
        return;
      }

      const processedTokens = [];
      const newQuery = { tab: this.$route.query.tab };
      let newFilters = {};

      // When the user clicks on the selected value (placeholder), the filtered search
      // empties the selection handler and sends a null value
      // We don't want to cause a new API call when this happens. Instead
      // we want to wait until user either destroys the token or selects a new token.
      if (filterTokens.some(({ value }) => !value.data)) {
        return;
      }

      filterTokens.forEach(({ type, value }) => {
        processedTokens.push(type);
        const filtersFn = DEFINITIONS[type]?.transformFilters;

        let transformedValue;

        if (typeof filtersFn === 'function') {
          transformedValue = filtersFn(value.data);
        } else {
          transformedValue = { [type]: value.data.filter((i) => i !== ALL_ID) };
        }

        newFilters = { ...newFilters, ...transformedValue };

        if (DEFINITIONS[type].transformQueryParams) {
          newQuery[type] = DEFINITIONS[type].transformQueryParams(value.data);
        } else if (isEqual(value.data, DEFINITIONS[type].defaultValues)) {
          newQuery[type] = undefined;
        } else {
          newQuery[type] = value.data.join(',');
        }
      });

      // Hack:
      //
      // When we remove a token by clicking on X, the inputValues does not contain
      // that token anymore. Some of the tokens we have (e.g. Status and Activity Filter)
      // has a different default state when there are no query parameters. These filters
      // need to have an `ALL` value in the query parameter to prevent restoring default state
      // on page load.
      Object.keys(DEFINITIONS)
        .filter((token) => !processedTokens.includes(token))
        .forEach((token) => {
          if (newQuery[token]) {
            return;
          }

          if (!newQuery[token] && DEFINITIONS[token]?.defaultValues) {
            newQuery[token] = ALL_ID;
          }
        });

      if (!isEqual(newQuery, this.$route.query)) {
        this.$router.push({ query: newQuery });
      }

      if (!isEqual(newFilters, this.filters)) {
        this.filters = newFilters;
        this.$emit('filters-changed', newFilters);
      }
    },
  },
};
</script>
<template>
  <gl-filtered-search
    :placeholder="s__('Vulnerability|Search or filter vulnerabilities...')"
    :available-tokens="tokens"
    :value="value"
    @input="handleInput"
    @clear="clear"
  />
</template>
