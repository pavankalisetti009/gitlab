<script>
import { GlLoadingIcon } from '@gitlab/ui';
import { GlLineChart } from '@gitlab/ui/dist/charts';
import projectsHistoryQuery from 'ee/security_dashboard/graphql/queries/project_vulnerabilities_by_day_and_count.query.graphql';
import severitiesCountQuery from 'ee/security_dashboard/graphql/queries/vulnerability_severities_count.query.graphql';
import SecurityTrainingPromoBanner from 'ee/security_dashboard/components/project/security_training_promo_banner.vue';
import { PROJECT_LOADING_ERROR_MESSAGE } from 'ee/security_dashboard/helpers';
import { createAlert } from '~/alert';
import { formatDate, getDateInPast } from '~/lib/utils/datetime_utility';
import { s__, __ } from '~/locale';

const CHART_DEFAULT_DAYS = 30;
const MAX_DAYS = 100;
const ISO_DATE = 'isoDate';
const SEVERITIES = [
  { key: 'critical', name: s__('severity|Critical'), color: '#660e00' },
  { key: 'high', name: s__('severity|High'), color: '#ae1800' },
  { key: 'medium', name: s__('severity|Medium'), color: '#9e5400' },
  { key: 'low', name: s__('severity|Low'), color: '#c17d10' },
  { key: 'info', name: s__('severity|Info'), color: '#428fdc' },
  { key: 'unknown', name: s__('severity|Unknown'), color: '#868686' },
];

export default {
  components: {
    SecurityTrainingPromoBanner,
    GlLoadingIcon,
    GlLineChart,
  },
  props: {
    projectFullPath: {
      type: String,
      required: false,
      default: '',
    },
    shouldShowPromoBanner: {
      type: Boolean,
      required: true,
      default: true,
    },
  },
  apollo: {
    // up-do-date count of vulnerabilities by severity, used to show the most recent data point
    // eslint-disable-next-line @gitlab/vue-no-undef-apollo-properties
    todaysVulnerabilitiesCount: {
      query: severitiesCountQuery,
      variables() {
        return {
          fullPath: this.projectFullPath,
          isProject: true,
          state: ['DETECTED', 'CONFIRMED'],
        };
      },
      update({ project }) {
        return project.vulnerabilitySeveritiesCount;
      },
      error() {
        createAlert({ message: PROJECT_LOADING_ERROR_MESSAGE });
      },
    },
    // historical, trending data, which gets generated by a cron job
    trendsByDay: {
      query: projectsHistoryQuery,
      variables() {
        return {
          fullPath: this.projectFullPath,
          endDate: this.todaysDate,
          startDate: this.startDate,
        };
      },
      update({ project }) {
        return project.vulnerabilitiesCountByDay.nodes;
      },
      error() {
        createAlert({ message: PROJECT_LOADING_ERROR_MESSAGE });
      },
    },
  },
  data() {
    return {
      chartWidth: 0,
      trendsByDay: [],
    };
  },
  computed: {
    chartStartDate() {
      return formatDate(getDateInPast(new Date(), CHART_DEFAULT_DAYS), ISO_DATE);
    },
    startDate() {
      return formatDate(getDateInPast(new Date(), MAX_DAYS), ISO_DATE);
    },
    todaysDate() {
      return formatDate(new Date(), ISO_DATE);
    },
    trendsByDayWithMostRecentData() {
      const lastTrendEntry = this.trendsByDay.at(-1);

      const trendDataWithoutLastEntry = this.trendsByDay.slice(0, -1);
      const isLastTrendEntryFromToday = lastTrendEntry?.date === this.todaysDate;

      return [
        // if the last entry is from today, replace it with the most recent data. otherwise, just append it.
        ...(isLastTrendEntryFromToday ? trendDataWithoutLastEntry : this.trendsByDay),
        { ...this.todaysVulnerabilitiesCount, date: this.todaysDate },
      ];
    },
    dataSeries() {
      const series = SEVERITIES.map(({ key, name, color }) => ({
        key,
        name,
        data: [],
        itemStyle: {
          color,
        },
        lineStyle: {
          color,
        },
      }));

      this.trendsByDayWithMostRecentData.forEach((trend) => {
        const { date, ...severities } = trend;

        SEVERITIES.forEach(({ key }) => {
          series.find((s) => s.key === key).data.push([date, severities[key]]);
        });
      });

      return series;
    },
    isLoading() {
      return (
        this.$apollo.queries.trendsByDay.loading ||
        this.$apollo.queries.todaysVulnerabilitiesCount.loading
      );
    },
    chartOptions() {
      return {
        xAxis: {
          name: __('Time'),
          key: 'time',
          type: 'category',
        },
        yAxis: {
          name: __('Vulnerabilities'),
          key: 'vulnerabilities',
          type: 'value',
          minInterval: 1,
        },
        dataZoom: [
          {
            type: 'slider',
            startValue: this.chartStartDate,
          },
        ],
        toolbox: {
          show: true,
        },
      };
    },
  },
};
</script>

<template>
  <gl-loading-icon v-if="isLoading" size="lg" class="gl-mt-6" />

  <div v-else>
    <security-training-promo-banner v-if="shouldShowPromoBanner" />
    <gl-line-chart
      class="gl-mt-6"
      :data="dataSeries"
      :option="chartOptions"
      responsive
      :include-legend-avg-max="false"
    />
  </div>
</template>
