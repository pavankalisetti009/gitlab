# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    # This worker parses and scans SBOM document after it has been uploaded by an analyzer client running in a CI job.
    # It is triggered by the `CreateSbomScanService` and is responsible for extracting the SBOM components
    # and scanning them for vulnerabilities. Scan results are built in memory in the form of Ruby objects
    # before being serialized and stored as an attachment to the ephemeral SbomScan record.
    #
    # The analyzer client asking for this SBOM scan will most likely timeout if the results are not available
    # within a reasonable delay (minutes), so we use :high urgency and only retry the job a couple of times.
    # Once these retries are exhausted, the scan is marked as failed.
    class ProcessSbomScanWorker
      include ApplicationWorker

      CONCURRENCY_LIMIT = 25
      MAX_RETRIES = 2

      feature_category :software_composition_analysis
      data_consistency :sticky
      idempotent!
      deduplicate :until_executed

      urgency :high
      sidekiq_options retry: false
      concurrency_limit -> { CONCURRENCY_LIMIT }

      def perform(sbom_scan_id, retry_count = 0)
        sbom_scan = find_and_validate_sbom_scan(sbom_scan_id)

        return unless sbom_scan

        perform_sbom_scan(sbom_scan, retry_count)
      end

      private

      def find_and_validate_sbom_scan(sbom_scan_id)
        sbom_scan = ::Security::VulnerabilityScanning::SbomScan.find_by_id(sbom_scan_id)

        if sbom_scan.blank?
          Gitlab::AppLogger.error(message: "Couldn't find Sbom Scan, skipping processing", sbom_scan_id: sbom_scan_id)
          return
        end

        unless sbom_scan.created?
          Gitlab::AppLogger.error(message: "Sbom Scan is not in created state, skipping processing",
            sbom_scan_id: sbom_scan_id, sbom_scan_status: sbom_scan.status_name)
          return
        end

        sbom_scan
      end

      def perform_sbom_scan(sbom_scan, retry_count)
        ::Security::VulnerabilityScanning::ProcessSbomScanService.new(sbom_scan).execute
      rescue StandardError => error
        handle_error(error, sbom_scan, retry_count)
      end

      def handle_error(error, sbom_scan, retry_count)
        if retryable_error?(error, retry_count)
          schedule_retry(sbom_scan, error, retry_count)
        else
          mark_scan_as_failed(sbom_scan, error)
        end
      end

      def retryable_error?(error, retry_count)
        return false if retry_count >= MAX_RETRIES

        return false if error.respond_to?(:retryable?) && !error.retryable?

        true
      end

      def schedule_retry(sbom_scan, error, retry_count)
        sbom_scan.reset_state! if sbom_scan.running?
        delay = error.respond_to?(:retry_delay) ? error.retry_delay : 0
        self.class.perform_in(delay, sbom_scan.id, retry_count + 1)
      end

      def mark_scan_as_failed(sbom_scan, error)
        sbom_scan.fail_with_error_message!(error.message)
        raise error
      end
    end
  end
end
