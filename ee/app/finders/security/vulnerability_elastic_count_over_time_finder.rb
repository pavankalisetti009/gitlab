# frozen_string_literal: true

# Security::VulnerabilityElasticCountOverTimeFinder
#
# Used to filter Vulnerability records for Vulnerabilities API from vulnerabilities elasticsearch index
#
# Arguments:
#   see in ee/app/finders/security/vulnerability_elastic_base_finder.rb

module Security
  class VulnerabilityElasticCountOverTimeFinder < VulnerabilityElasticBaseFinder
    def execute
      options = search_params.merge({ vulnerabilities_over_time: true,
        created_after: overriden_created_after,
        bucket_start_date: bucket_start_date,
        bucket_end_date: bucket_end_date })
      query = ::Search::Elastic::VulnerabilityQueryBuilder.build(query: nil, options: options)

      Gitlab::Search::Client.execute_search(query: query, options: es_search_options) do |es_response|
        response = ::Search::Elastic::ResponseMapper.new(es_response).aggregations
        parsed_aggregations = parse_aggregation(response)
        count_over_time(parsed_aggregations, options)
      end
    end

    private

    # Top level filter range should be the last 12 months as the aggregation buckets require open vulnerabilities count.
    def overriden_created_after
      search_params[:created_before] - 1.year
    end

    def bucket_start_date
      search_params[:created_after]
    end

    def bucket_end_date
      search_params[:created_before]
    end

    def parse_aggregation(response)
      return {} unless response.present?

      response.dig('open_by_day', 'buckets')&.transform_values do |bucket|
        extract_bucket_data(bucket)
      end
    end

    def extract_bucket_data(bucket)
      return { "by_severity" => bucket['by_severity']['buckets'] } if bucket["by_severity"].present?

      { "by_report_type" => bucket['by_report_type']['buckets'] } if bucket["by_report_type"].present?
    end

    def count_over_time(parsed_aggregation, options)
      return [] unless parsed_aggregation.present?

      parsed_aggregation.map do |date, metrics|
        build_date_metrics(date, metrics, options)
      end
    end

    def build_date_metrics(date, metrics, options)
      result = { "date" => date }

      (metrics || []).each do |metric_name, buckets|
        result[metric_name.to_sym] = build_metric_data(metric_name, buckets, options)
      end

      result
    end

    def build_metric_data(metric_name, buckets, options)
      case metric_name
      when "by_severity"
        filtered_severities = options[:severity].presence || []
        build_severity_data(buckets, filtered_severities)
      when "by_report_type"
        filtered_report_types = options[:report_type].presence || []
        build_report_type_data(buckets, filtered_report_types)
      end
    end

    def build_severity_data(buckets, filtered_severities)
      bucket_lookup = create_bucket_lookup(buckets)

      selected_severities = if filtered_severities.empty?
                              ::Vulnerability.severities
                            else
                              ::Vulnerability.severities.select do |_, v|
                                filtered_severities.include?(v)
                              end
                            end

      selected_severities.map do |severity_name, severity_num|
        {
          "count" => extract_count_from_bucket(bucket_lookup[severity_num]),
          "severity" => severity_name.upcase
        }
      end
    end

    def build_report_type_data(buckets, filtered_report_types)
      bucket_lookup = create_bucket_lookup(buckets)

      selected_report_types = if filtered_report_types.empty?
                                ::Vulnerability.report_types
                              else
                                ::Vulnerability.report_types.select do |_, v|
                                  filtered_report_types.include?(v)
                                end
                              end

      selected_report_types.map do |type_name, type_num|
        {
          "count" => extract_count_from_bucket(bucket_lookup[type_num]),
          "report_type" => type_name.upcase
        }
      end
    end

    def create_bucket_lookup(buckets)
      buckets.index_by { |bucket| bucket["key"] }
    end

    def extract_count_from_bucket(bucket)
      bucket ? bucket["doc_count"] : 0
    end
  end
end
