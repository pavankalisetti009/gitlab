# frozen_string_literal: true

# Security::VulnerabilityReadsElasticAggregationFinder
#
# Used to filter Vulnerability records for Vulnerabilities API from vulnerabilities elasticsearch index
#
# Arguments:
#   vulnerable: any object that has a #vulnerabilities method that returns a collection of `Vulnerability`s
#   params: optional! a hash with one or more of the following:
#     project_id: if `vulnerable` includes multiple projects (like a Group), this filter will restrict
#                   the vulnerabilities returned to those in the group's projects that also match these IDs
#     include_archived_projects: defaulted to `false`. Determines if results will include vulnerabilities
#                                 associated with archived projects
#     image: only return vulnerabilities with these location images
#     report_type: only return vulnerabilities from these report types
#     severity: only return vulnerabilities with these severities
#     state: only return vulnerabilities in these states
#     dismissal_reason: only return vulnerabilities with these dismisal reasons
#     scanner: only return vulnerabilities with these external_id
#     scanner_id: only return vulnerabilities with these scanner_ids
#     has_resolution: only return vulnerabilities that have resolution
#     has_ai_resolution: only return vulnerabilities that are eligible to be resolved by an LLM
#     has_issues: only return vulnerabilities that have issues linked
#     has_merge_request: only return vulnerabilities that have MR(s) linked
#     cluster_agent_id: only return vulnerabilities with these cluster_agent_ids
#     has_remediations: only return vulnerabilities that have remediations
#     owasp_top_10: only return vulnerabilities with these owasp values
#     owasp_top_10_2021: only return vulnerabilities with these owasp 2021 values
#     before_severity: only return vulnerabilities with lower severity than given value if sorting is ascending,
#                      returns vulnerabilities with higher severity otherwise. Works only for groups.
#     after_severity: only return vulnerabilities with higher severity than given value if sorting is ascending,
#                     returns vulnerabilities with lower severity otherwise. Works only for groups.
#     identifier_name: only return vulnerabilities with these identifier names
#     sort: return vulnerabilities ordered by severity_asc or severity_desc

module Security
  class VulnerabilityElasticAggregationFinder < VulnerabilityElasticFinder # rubocop:disable Search/NamespacedClass -- Keeping this in the Security namespace as it is used specifically by security classes
    def execute(aggregation)
      raise(ArgumentError, "Unknown aggregation: #{aggregation}") unless AGGREGATIONS.has_key?(aggregation)

      instance_exec(&AGGREGATIONS[aggregation])
    end

    private

    def parsed_aggregations(query_options)
      query = ::Search::Elastic::VulnerabilityQueryBuilder.build(query: nil, options: query_options)
      Gitlab::Search::Client.execute_search(query: query, options: es_search_options) do |es_response|
        aggregations = ::Search::Elastic::ResponseMapper.new(es_response).aggregations
        Gitlab::Search::AggregationParser.call(aggregations).first
      end
    end

    def count_by_severity
      options = search_params.merge({ count_by_severity: true })

      parsed_aggregations = parsed_aggregations(options)
      severity_counts(parsed_aggregations)
    end

    def search_identifier_name
      options = search_params.merge(
        {
          partial_identifier_name: params[:partial_identifier_name],
          search_identifier_names: true
        })

      parsed_aggregations = parsed_aggregations(options)
      identifier_names(parsed_aggregations)
    end

    def severity_counts(parsed_aggregations)
      severities = {}
      severity_hash = ::Vulnerabilities::Read.severities.invert
      parsed_aggregations.buckets.each do |bucket|
        key = severity_hash[bucket[:key]]
        value = bucket[:count]

        severities[key] = value
      end

      severities
    end

    def identifier_names(parsed_aggregations)
      parsed_aggregations.buckets.pluck(:key) # rubocop:disable CodeReuse/ActiveRecord,Database/AvoidUsingPluckWithoutLimit -- not an active record object
    end

    AGGREGATIONS = {
      count_by_severity: -> { count_by_severity },
      search_identifier_name: -> { search_identifier_name }
    }.freeze
    private_constant :AGGREGATIONS
  end
end
