# frozen_string_literal: true

# Security::VulnerabilityReadsElasticFinder
#
# Used to filter Vulnerability records for Vulnerabilities API from vulnerabilities elasticsearch index
#
# Arguments:
#   vulnerable: any object that has a #vulnerabilities method that returns a collection of `Vulnerability`s
#   params: optional! a hash with one or more of the following:
#     project_id: if `vulnerable` includes multiple projects (like a Group), this filter will restrict
#                   the vulnerabilities returned to those in the group's projects that also match these IDs
#     include_archived_projects: defaulted to `false`. Determines if results will include vulnerabilities
#                                 associated with archived projects
#     image: only return vulnerabilities with these location images
#     report_type: only return vulnerabilities from these report types
#     severity: only return vulnerabilities with these severities
#     state: only return vulnerabilities in these states
#     dismissal_reason: only return vulnerabilities with these dismisal reasons
#     scanner: only return vulnerabilities with these external_id
#     scanner_id: only return vulnerabilities with these scanner_ids
#     has_resolution: only return vulnerabilities that have resolution
#     has_ai_resolution: only return vulnerabilities that are eligible to be resolved by an LLM
#     has_issues: only return vulnerabilities that have issues linked
#     has_merge_request: only return vulnerabilities that have MR(s) linked
#     cluster_agent_id: only return vulnerabilities with these cluster_agent_ids
#     has_remediations: only return vulnerabilities that have remediations
#     owasp_top_10: only return vulnerabilities with these owasp values
#     owasp_top_10_2021: only return vulnerabilities with these owasp 2021 values
#     before_severity: only return vulnerabilities with lower severity than given value if sorting is ascending,
#                      returns vulnerabilities with higher severity otherwise. Works only for groups.
#     after_severity: only return vulnerabilities with higher severity than given value if sorting is ascending,
#                     returns vulnerabilities with lower severity otherwise. Works only for groups.
#     identifier_name: only return vulnerabilities with these identifier names
#     sort: return vulnerabilities ordered by severity_asc or severity_desc

module Security
  class VulnerabilityReadsElasticFinder < VulnerabilityReadsBaseFinder # rubocop:disable Search/NamespacedClass -- Keeping this in the Security namespace as it is used specifically by security classes
    include Gitlab::Utils::StrongMemoize

    extend ::Gitlab::Utils::Override

    INDEX_NAME = Search::Elastic::References::Vulnerability.index

    def initialize(vulnerable, params = {})
      @params = params
      @vulnerable = vulnerable
      @search_params = initialize_search_params
    end

    def execute
      query = ::Search::Elastic::VulnerabilityQueryBuilder.build(query: nil, options: search_params)

      options = es_search_options.merge({
        primary_key: Vulnerabilities::Read.primary_key.to_sym
      })

      Search::Elastic::Relation.new(Vulnerability, query, options)
    end

    def count_by_severity
      options = search_params.merge({ count_by_severity: true })

      query = ::Search::Elastic::VulnerabilityQueryBuilder.build(query: nil, options: options)

      Gitlab::Search::Client.execute_search(query: query, options: es_search_options) do |es_response|
        aggregations = ::Search::Elastic::ResponseMapper.new(es_response).aggregations
        parsed_aggregations = Gitlab::Search::AggregationParser.call(aggregations).first

        severity_counts(parsed_aggregations)
      end
    end

    def search_identifier_name(partial_identifier_name)
      options = search_params.merge({
        partial_identifier_name: partial_identifier_name,
        search_identifier_names: true
      })

      query = ::Search::Elastic::VulnerabilityQueryBuilder.build(query: nil, options: options)

      Gitlab::Search::Client.execute_search(query: query, options: es_search_options) do |es_response|
        aggregations = ::Search::Elastic::ResponseMapper.new(es_response).aggregations
        parsed_aggregations = Gitlab::Search::AggregationParser.call(aggregations).first

        identifier_names(parsed_aggregations)
      end
    end

    private

    attr_reader :params, :vulnerable, :search_params

    def initialize_search_params
      {
        search_level: vulnerable_is_a_group? ? "group" : "project",
        include_archived_projects: params[:include_archived_projects],
        traversal_ids: traversal_ids,
        project_id: project_id,
        image: Array.wrap(params[:image]),
        report_type: report_types,
        severity: severities,
        state: states,
        dismissal_reason: dismissal_reasons,
        scanner_external_id: Array.wrap(params[:scanner]),
        scanner_id: Array.wrap(params[:scanner_id]),
        has_resolution: params[:has_resolution],
        has_ai_resolution: params[:has_ai_resolution],
        has_issues: params[:has_issues],
        has_merge_request: params[:has_merge_request],
        cluster_agent_id: Array.wrap(params[:cluster_agent_id]),
        has_remediations: params[:has_remediations],
        owasp_top_10_2017: params[:owasp_top_10],
        owasp_top_10_2021: params[:owasp_top_10_2021],
        identifier_name: params[:identifier_name],
        sort: sort
      }
    end

    def traversal_ids
      if vulnerable_is_a_group?
        [vulnerable.elastic_namespace_ancestry]
      else
        [vulnerable.namespace.elastic_namespace_ancestry]
      end
    end

    def project_id
      vulnerable.is_a?(Project) ? [vulnerable.id] : Array.wrap(params[:project_id])
    end

    def report_types
      return unless params[:report_type]

      Vulnerability.report_types.slice(*params[:report_type]).values
    end

    def states
      return unless params[:state]

      Vulnerability.states.slice(*params[:state]).values
    end

    def dismissal_reasons
      return unless params[:dismissal_reason]

      Vulnerabilities::Read.dismissal_reasons.slice(*params[:dismissal_reason]).values
    end

    def sort
      # Search::Elastic::Pagination expects a default sort
      return :severity_desc unless params[:sort]

      params[:sort].to_sym
    end

    def es_search_options
      {
        index_name: INDEX_NAME,
        # This key is used by es to find the correct shard.
        # See Elastic::Latest::Routing for how its used
        root_ancestor_ids: root_ancestor_ids
      }
    end

    def root_ancestor_ids
      [vulnerable.root_ancestor.id]
    end

    def severity_counts(parsed_aggregations)
      severities = {}
      severity_hash = ::Vulnerabilities::Read.severities.invert
      parsed_aggregations.buckets.each do |bucket|
        key = severity_hash[bucket[:key]]
        value = bucket[:count]

        severities[key] = value
      end

      severities
    end

    def identifier_names(parsed_aggregations)
      parsed_aggregations.buckets.pluck(:key) # rubocop:disable CodeReuse/ActiveRecord,Database/AvoidUsingPluckWithoutLimit -- not not an active record object
    end
  end
end
