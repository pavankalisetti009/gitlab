# frozen_string_literal: true

# Security::VulnerabilityElasticRiskScoresFinder
#
# Used to calculate total risk score of all active vulnerabilities
# in a project or a group.
#
# Arguments:
#   see in ee/app/finders/security/vulnerability_elastic_base_finder.rb

module Security
  class VulnerabilityElasticRiskScoresFinder < VulnerabilityElasticBaseFinder
    REQUIRED_PROJECTS_SIZE = 96

    def initialize(vulnerable, params = {})
      super(vulnerable, params.merge({ state: Vulnerability.active_states }))
    end

    def execute
      query = ::Search::Elastic::VulnerabilityQueryBuilder.build(query: nil, options: options)

      Gitlab::Search::Client.execute_search(query: query, options: es_search_options) do |es_response|
        response = ::Search::Elastic::ResponseMapper.new(es_response)
        parse_response_and_calculate_risk_scores(response)
      end
    end

    private

    def options
      search_params.merge({
        total_risk_score: true,
        group_risk_score_by: group_by
      })
    end

    def parse_response_and_calculate_risk_scores(response)
      result = { total_risk_score: calculate_top_level_risk_score(response) }

      return result unless group_by

      result[:risk_score_by_project] = parse_project_buckets(response)
      result[:total_project_count] = total_projects_count(response)

      result
    end

    def calculate_top_level_risk_score(response)
      risk_scores_sum = response.aggregations.dig("risk_scores_sum", "value") || 0
      created_at_sum = response.aggregations.dig("created_at_sum", "value") || 0
      active_vulnerabilities_count = response.total_count || 0

      Vulnerabilities::AggregateRiskScore.score(
        risk_scores_sum: risk_scores_sum,
        created_at_sum: created_at_sum,
        active_vulnerabilities_count: active_vulnerabilities_count
      )
    end

    def parse_project_buckets(response)
      project_scores = {}
      response.aggregations.dig("by_projects", "buckets")&.each do |bucket|
        project_scores[bucket["key"]] = calculate_bucket_risk_score(bucket)
      end

      # Project scores are sorted by descending order count of vulnerabilities by default
      # we need them to be sorted by the risk score of the project.
      project_scores.sort_by { |_, value| -value }.first(REQUIRED_PROJECTS_SIZE).to_h
    end

    def calculate_bucket_risk_score(bucket)
      risk_scores_sum = bucket.dig("risk_scores_sum", "value") || 0
      created_at_sum = bucket.dig("created_at_sum", "value") || 0
      active_vulnerabilities_count = bucket["doc_count"] || 0

      Vulnerabilities::AggregateRiskScore.score(
        risk_scores_sum: risk_scores_sum,
        created_at_sum: created_at_sum,
        active_vulnerabilities_count: active_vulnerabilities_count
      )
    end

    def total_projects_count(response)
      response.aggregations.dig("by_projects", "buckets")&.size || 0
    end

    def group_by
      params[:group_by] if project_grouping_enabled?
    end

    def project_grouping_enabled?
      if vulnerable_is_a_group?
        Feature.enabled?(:group_vulnerability_risk_scores_by_project, vulnerable)
      else
        false
      end
    end
    strong_memoize_attr :project_grouping_enabled?
  end
end
