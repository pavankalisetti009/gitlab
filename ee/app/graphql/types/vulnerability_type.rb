# frozen_string_literal: true

module Types
  class VulnerabilityType < BaseObject
    graphql_name 'Vulnerability'
    description 'Represents a vulnerability'

    implements Types::Notes::NoteableInterface
    implements Types::TodoableInterface

    authorize :read_vulnerability

    def self.authorization_scopes
      super + [:ai_workflows]
    end

    expose_permissions Types::PermissionTypes::Vulnerability

    field :id, GraphQL::Types::ID,
      null: false, description: 'GraphQL ID of the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :uuid, GraphQL::Types::String, method: :finding_uuid,
      null: false, description: 'UUID of the vulnerability finding. Can be used to look up ' \
                                'the associated security report finding.'

    field :title, GraphQL::Types::String,
      null: true, description: 'Title of the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :description, GraphQL::Types::String,
      null: true, description: 'Description of the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :solution, GraphQL::Types::String,
      null: true,
      description: 'Recommended solution for the vulnerability.'

    field :state, VulnerabilityStateEnum,
      null: true, description: "State of the vulnerability (#{::Vulnerability.states.keys.join(', ').upcase})",
      scopes: [:api, :read_api, :ai_workflows]

    field :severity, VulnerabilitySeverityEnum,
      null: true, description: "Severity of the vulnerability (#{::Enums::Vulnerability.severity_levels.keys.join(', ').upcase})",
      scopes: [:api, :read_api, :ai_workflows]

    field :severity_overrides, ::Types::Vulnerabilities::SeverityOverrideType.connection_type,
      resolver: Resolvers::Vulnerabilities::SeverityOverridesResolver,
      null: true, description: "List of severity changes for the vulnerability."

    field :latest_security_report_finding,
      type: ::Types::PipelineSecurityReportFindingType,
      null: true,
      experiment: { milestone: '18.4' },
      description: "Latest security report finding for the vulnerability."

    field :cve_enrichment, ::Types::Vulnerabilities::CveEnrichmentType,
      null: true, description: 'Enrichment (EPSS score and KEV) for CVE vulnerabilities.',
      scopes: [:api, :read_api, :ai_workflows]

    field :report_type, VulnerabilityReportTypeEnum,
      null: true, description: "Type of the security report that found the vulnerability (#{::Enums::Vulnerability.report_types.keys.join(', ').upcase}). `Scan Type` in the UI.",
      scopes: [:api, :read_api, :ai_workflows]

    field :resolved_on_default_branch, GraphQL::Types::Boolean,
      null: false, description: "Indicates whether the vulnerability is fixed on the default branch or not.",
      scopes: [:api, :read_api, :ai_workflows]

    field :user_notes_count, GraphQL::Types::Int,
      null: false, description: 'Number of user notes attached to the vulnerability.'

    field :vulnerability_path, GraphQL::Types::String,
      null: true, description: "Path to the vulnerability's details page."

    field :issue_links, ::Types::Vulnerability::IssueLinkType.connection_type,
      null: false, resolver: Resolvers::Vulnerabilities::IssueLinksResolver,
      description: "List of issue links related to the vulnerability."

    field :external_issue_links, ::Types::Vulnerability::ExternalIssueLinkType.connection_type,
      null: false,
      description: 'List of external issue links related to the vulnerability.'

    field :links, [::Types::Vulnerabilities::LinkType],
      null: false, description: 'List of links associated with the vulnerability.'

    field :dependencies, ::Types::Sbom::DependencyType.connection_type,
      null: false, description: 'Dependencies for the vulnerability.',
      resolver: ::Resolvers::Sbom::DependenciesResolver,
      experiment: { milestone: '18.2' }

    field :location, VulnerabilityLocationType,
      null: true, description: 'Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :scanner, VulnerabilityScannerType,
      null: true, description: 'Scanner metadata for the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :primary_identifier, VulnerabilityIdentifierType,
      null: true, description: 'Primary identifier of the vulnerability.'

    field :identifiers, [VulnerabilityIdentifierType],
      null: false, description: 'Identifiers of the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :project, ::Types::ProjectType,
      null: true, authorize: :read_project, description: 'Project on which the vulnerability was found.',
      scopes: [:api, :read_api, :ai_workflows]

    field :detected_at, Types::TimeType,
      null: false, method: :created_at, description: 'Timestamp of when the vulnerability was first detected.',
      scopes: [:api, :read_api, :ai_workflows]

    field :confirmed_at, Types::TimeType,
      null: true, description: 'Timestamp of when the vulnerability state was changed to confirmed.',
      scopes: [:api, :read_api, :ai_workflows]

    field :resolved_at, Types::TimeType,
      null: true, description: 'Timestamp of when the vulnerability state was changed to resolved.'

    field :dismissed_at, Types::TimeType,
      null: true, description: 'Timestamp of when the vulnerability state was changed to dismissed.',
      scopes: [:api, :read_api, :ai_workflows]

    field :updated_at, Types::TimeType,
      null: true, description: 'Timestamp of when the vulnerability was last updated.',
      scopes: [:api, :read_api, :ai_workflows]

    field :has_remediations, GraphQL::Types::Boolean,
      method: :has_remediations?,
      description: 'Indicates whether there is a remediation available for the vulnerability.'

    field :state_comment, GraphQL::Types::String,
      null: true, description: 'Comment given for the vulnerability state change.'

    field :merge_request, ::Types::MergeRequestType,
      null: true, description: 'Merge request that fixes the vulnerability.'

    field :merge_requests, ::Types::MergeRequestType.connection_type,
      null: true, description: 'Merge requests that are linked to fix the vulnerability.', method: :ordered_merge_requests,
      scopes: [:api, :read_api, :ai_workflows]

    field :confirmed_by, ::Types::UserType,
      null: true, description: 'User that confirmed the vulnerability.'

    field :resolved_by, ::Types::UserType,
      null: true, description: 'User that resolved the vulnerability.'

    field :dismissed_by, ::Types::UserType,
      null: true, description: 'User that dismissed the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :details, [VulnerabilityDetailType],
      null: false,
      resolver: Resolvers::Vulnerabilities::DetailsResolver,
      description: 'Details of the vulnerability.',
      scopes: [:api, :read_api, :ai_workflows]

    field :false_positive, GraphQL::Types::Boolean,
      null: true, resolver_method: :false_positive?,
      description: 'Indicates whether the vulnerability is a false positive.'

    field :representation_information, Types::Vulnerabilities::RepresentationInformationType,
      null: true,
      experiment: { milestone: '17.7' },
      description: 'Information about the representation of the vulnerability, such as resolved commit SHA.'

    field :web_url, GraphQL::Types::String,
      null: true, description: "URL to the vulnerability's details page."

    field :state_transitions, ::Types::Vulnerability::StateTransitionType.connection_type,
      null: true,
      description: "List of state transitions related to the vulnerability."

    field :dismissal_reason, ::Types::Vulnerabilities::DismissalReasonEnum,
      null: true,
      description: "Reason for dismissal. Returns `null` for states other than `dismissed`."

    field :present_on_default_branch, GraphQL::Types::Boolean,
      null: false, description: "Indicates whether the vulnerability is present on the default branch or not."

    field :cvss, [::Types::Vulnerabilities::CvssType],
      null: false, description: "CVSS information for the vulnerability."

    field :ai_resolution_available, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates whether the type of vulnerability can be resolved with AI.'

    field :ai_resolution_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates whether the specific vulnerability can be resolved with AI.', method: :ai_resolution_enabled?

    field :archival_information, ::Types::Vulnerabilities::ArchivalInformationType,
      null: false,
      experiment: { milestone: '17.11' },
      description: 'Indicates whether the vulnerability is about to be archived in the next month.'

    field :reachability, ::Types::Sbom::ReachabilityEnum,
      null: true, experiment: { milestone: '17.11' },
      description: "Reachability status of the vulnerability.",
      scopes: [:api, :read_api, :ai_workflows]

    field :finding_token_status, Types::Vulnerabilities::FindingTokenStatusType,
      null: true,
      description: 'Status of the secret token associated with this vulnerability. Returns `null` if the `validity_checks` feature flag is disabled.',
      resolver: Resolvers::Vulnerabilities::FindingTokenStatusResolver

    field :flags,
      ::Types::Vulnerabilities::FlagType.connection_type,
      experiment: { milestone: '18.5' },
      null: true,
      description: 'Flags set on the vulnerability.'

    field :latest_flag,
      ::Types::Vulnerabilities::FlagType,
      experiment: { milestone: '18.5' },
      null: true,
      description: 'Latest flag for the vulnerability.'

    field :initial_detected_pipeline, Ci::PipelineType,
      method: :initial_finding_pipeline,
      null: true, experiment: { milestone: '18.2' },
      description: 'Pipeline where the vulnerability was first detected.',
      scopes: [:api, :read_api, :ai_workflows]

    field :latest_detected_pipeline, Ci::PipelineType,
      method: :latest_finding_pipeline,
      null: true, experiment: { milestone: '18.2' },
      description: 'Pipeline where the vulnerability was last detected.'

    field :policy_violations, ::Types::SecurityOrchestration::PolicyViolationsEnum,
      null: true, experiment: { milestone: '18.6' },
      description: 'Policy violation for the vulnerability.'

    markdown_field :description_html, null: true

    def dismissal_reason
      object.vulnerability_read&.dismissal_reason
    end

    def cve_enrichment
      BatchLoader::GraphQL.for(object.cve_value).batch do |cves, loader|
        ::PackageMetadata::CveEnrichment.by_cves(cves).each do |enrichment|
          loader.call(enrichment.cve, enrichment)
        end
      end
    end

    def latest_security_report_finding
      BatchLoader::GraphQL.for(object.finding_uuid).batch do |uuids, loader|
        valid_uuids = uuids.compact
        next if valid_uuids.empty?

        latest_findings = ::Security::Finding.by_uuid(valid_uuids).latest_scan.index_by(&:uuid)
        uuids.each { |uuid| loader.call(uuid, latest_findings[uuid]) }
      end
    end

    def confirmed_by
      ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::User, object.confirmed_by_id).find
    end

    def resolved_by
      ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::User, object.resolved_by_id).find
    end

    def dismissed_by
      ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::User, object.dismissed_by_id).find
    end

    def user_notes_count
      ::Gitlab::Graphql::Aggregations::Vulnerabilities::LazyUserNotesCountAggregate.new(context, object)
    end

    def vulnerability_path
      ::Gitlab::Routing.url_helpers.project_security_vulnerability_path(object.project, object)
    end

    def web_url
      ::Gitlab::Routing.url_helpers.project_security_vulnerability_url(object.project, object)
    end

    def location
      object_location = object.finding&.location
      object_location&.merge(blob_path: object.blob_path, report_type: object.report_type)&.compact
    end

    def scanner
      Representation::VulnerabilityScannerEntry.new(object.finding&.scanner, object.report_type)
    end

    def primary_identifier
      object.finding&.primary_identifier
    end

    def identifiers
      object.finding&.identifiers || []
    end

    def description
      object.description || object.finding_description
    end

    def description_html_resolver
      ::MarkupHelper.markdown(description, context.to_h.dup)
    end

    def project
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
    end

    def state_comment
      object.state_transitions.last&.comment
    end

    def merge_request
      merge_requests.first
    end

    def merge_requests
      object.ordered_merge_requests
    end

    def false_positive?
      return unless expose_false_positive?

      object.finding&.false_positive? || false
    end

    def ai_resolution_available
      object.finding&.ai_resolution_available?
    end

    def archival_information
      BatchLoader::GraphQL.for(object).batch do |vulnerabilities, loader|
        namespaces = vulnerabilities.map(&:project).map(&:namespace)

        ::Namespaces::Preloaders::NamespaceRootAncestorPreloader.new(namespaces).execute

        vulnerabilities.each do |vulnerability|
          loader.call(vulnerability, archival_information_for(vulnerability))
        end
      end
    end

    def reachability
      return unless object.dependency_scanning?

      BatchLoader::GraphQL.for(object.id).batch do |vulnerability_ids, loader|
        reachabilities_per_vulnerability_id = reachabilities_per_vulnerability_id(vulnerability_ids)

        vulnerability_ids.each do |vulnerability_id|
          reachabilities = reachabilities_per_vulnerability_id[vulnerability_id]
          loader.call(vulnerability_id, reachability_value(reachabilities))
        end
      end
    end

    def flags
      object&.finding&.vulnerability_flags
    end

    def latest_flag
      flags&.last
    end

    def policy_violations
      return unless Feature.enabled?(:security_policy_approval_warn_mode, object.project)

      BatchLoader::GraphQL.for(object).batch do |vulnerabilities, loader|
        project_ids = vulnerabilities.map(&:project_id)
        security_findings_uuids = vulnerabilities.map { |vulnerability| vulnerability.finding.uuid }

        dismissed_uuids = dismissed_uuids(project_ids, security_findings_uuids)

        vulnerabilities.each do |vulnerability|
          loader.call(vulnerability, policy_violations_for(dismissed_uuids, vulnerability.finding.uuid))
        end
      end
    end

    private

    def archival_information_for(vulnerability)
      {
        about_to_be_archived: vulnerability.about_to_be_archived?,
        expected_to_be_archived_on: vulnerability.expected_to_be_archived_on
      }
    end

    def expose_false_positive?
      object.project.licensed_feature_available?(:sast_fp_reduction)
    end

    def reachability_value(reachabilities)
      if reachabilities&.any?(&:in_use_reachability?)
        ::Enums::Sbom::IN_USE
      elsif reachabilities&.any?(&:not_found_reachability?)
        ::Enums::Sbom::NOT_FOUND
      else
        ::Enums::Sbom::UNKNOWN
      end
    end

    def reachabilities_per_vulnerability_id(vulnerability_ids)
      ::Sbom::Occurrence
        .filter_by_vulnerability_id(vulnerability_ids)
        .filter_by_reachability(%w[in_use not_found])
        .select(:reachability, 'occurrences_vulnerabilities.vulnerability_id')
        .group_by(&:vulnerability_id)
    end

    def dismissed_uuids(project_ids, security_findings_uuids)
      ::Security::PolicyDismissal
        .for_projects(project_ids)
        .preserved
        .for_security_findings_uuids(security_findings_uuids)
        .pluck_security_findings_uuid.to_set
    end

    def policy_violations_for(dismissed_uuids, uuid)
      dismissed_uuids.include?(uuid) ? ::Enums::Vulnerability::POLICY_VIOLATIONS_DISMISSED_IN_MR : nil
    end
  end
end
