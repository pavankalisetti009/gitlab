# frozen_string_literal: true

module Resolvers
  module VulnerabilityFilterable
    extend ActiveSupport::Concern
    include ::Security::GroupIdentifierSearch
    include Gitlab::Utils::StrongMemoize

    private

    ADVANCED_FILTERS = %i[
      owasp_top_10_2021
      identifier_name
      reachability
      validity_check
      policy_violations
      policy_auto_dismissed
      false_positive
      security_project_tracked_context_id
    ].freeze

    def validate_filters(filters)
      # identifier_name is also supported on postgres
      validate_advanced_vuln_management! if (ADVANCED_FILTERS - [:identifier_name]).any? { |f| filters[f].present? }

      validate_identifier_name!(filters)

      validate_owasp_top_ten(filters[:owasp_top_10], "owasp_top_ten") if filters[:owasp_top_10].present?
      validate_owasp_top_ten(filters[:owasp_top_10_2021], "owasp_top_ten_2021") if filters[:owasp_top_10_2021].present?

      validate_validity_check!(vulnerable, filters)
      validate_policy_auto_dismissed!(vulnerable, filters)
      validate_false_positive!(vulnerable, filters)
      validate_security_tracked_contexts!(vulnerable, filters)
    end

    def validate_owasp_top_ten(owasp_top_ten, argument_name)
      includes_filter_none = owasp_top_ten.include?(::Security::VulnerabilityReadsFinder::FILTER_NONE)

      return if owasp_top_ten.size <= 1

      return unless includes_filter_none

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        "Incompatible argument: #{argument_name}. 'NONE' wildcard cannot be combined with other OWASP top 10 values."
    end

    def validate_instance_security_dashboard_not_supported!
      return unless object.is_a?(::InstanceSecurityDashboard)

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        "Feature is not supported for InstanceSecurityDashboard"
    end

    def validate_advanced_vuln_management!
      validate_instance_security_dashboard_not_supported!

      validate_self_managed_first_backfill! if ::Search::Elastic::VulnerabilityIndexHelper.self_managed_with_es?

      return if advanced_vuln_mgmt_available?

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        "Require advanced vulnerability management to be enabled!"
    end

    def validate_identifier_name!(filters)
      return if filters[:identifier_name].blank?

      validate_instance_security_dashboard_not_supported!

      search_by_identifier_allowed_on_db!(vulnerable: object) unless advanced_vuln_mgmt_available?
    end

    def advanced_vuln_mgmt_available?
      current_user.can?(:access_advanced_vulnerability_management, object)
    end
    strong_memoize_attr :advanced_vuln_mgmt_available?

    def use_elasticsearch?(filters)
      (ADVANCED_FILTERS & filters.keys).any? && advanced_vuln_mgmt_available?
    end

    def validate_self_managed_first_backfill!
      return if ::Search::Elastic::VulnerabilityIndexHelper
                      .self_managed_and_first_backfill_completed?

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        "Require data backfill migration to be completed!"
    end
    strong_memoize_attr :validate_self_managed_first_backfill!

    def validate_validity_check!(vulnerable, filters)
      return if filters[:validity_check].blank?

      group =
        if vulnerable.is_a?(Project)
          vulnerable.group
        elsif vulnerable.is_a?(Group)
          vulnerable
        end

      return unless group

      # For self-managed instances, 'backfill_vulnerabilities_for_self_managed' supersedes
      # 'backfill_token_status_by_report_types_in_vulnerabilities' so using the helper.
      return if ::Search::Elastic::VulnerabilityIndexHelper
        .backfill_migration_completed?(
          :backfill_token_status_by_report_types_in_vulnerabilities
        )

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        'The required migrations are not completed.'
    end

    def validate_policy_auto_dismissed!(vulnerable, filters)
      return if filters[:policy_auto_dismissed].blank?

      group =
        if vulnerable.is_a?(Project)
          vulnerable.group
        elsif vulnerable.is_a?(Group)
          vulnerable
        end

      if group.blank?
        raise ::Gitlab::Graphql::Errors::ArgumentError, 'The filter policy_auto_dismissed is not available.'
      end

      return if Feature.enabled?(:policy_auto_dismissed_es_filter, group) &&
        ::Elastic::DataMigrationService.migration_has_finished?(:add_policy_auto_dismissed_field_to_vulnerability)

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        'The feature flag is not enabled or the required migrations are not completed.'
    end

    def validate_false_positive!(vulnerable, filters)
      return if filters[:false_positive].blank?

      group =
        if vulnerable.is_a?(Project)
          vulnerable.group
        elsif vulnerable.is_a?(Group)
          vulnerable
        end

      raise ::Gitlab::Graphql::Errors::ArgumentError, 'The false_positive filter is not available.' if group.blank?

      return if Feature.enabled?(:ai_experiment_sast_fp_detection, group) &&
        ::Elastic::DataMigrationService.migration_has_finished?(:add_false_positive_detected_as_fp_to_vulnerability)

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        'The feature flag is not enabled or the required migrations are not completed.'
    end

    def validate_security_tracked_contexts!(vulnerable, filters)
      return if filters[:security_project_tracked_context_id].blank?

      actor = vulnerable.is_a?(Project) ? vulnerable : Feature.current_request
      return if Feature.enabled?(:vulnerabilities_across_contexts, actor)

      raise ::Gitlab::Graphql::Errors::ArgumentError,
        'The vulnerabilities_across_contexts feature flag is not enabled.'
    end
  end
end
