# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    class SbomScan < ::SecApplicationRecord
      self.table_name = :sbom_vulnerability_scans

      EXPIRED_AGE = 2.days

      belongs_to :project
      belongs_to :build, class_name: 'Ci::Build'
      belongs_to :result, class_name: 'Security::VulnerabilityScanning::SbomScanResult',
        foreign_key: 'sbom_vulnerability_scan_result_id', optional: true, inverse_of: :sbom_scans

      validates :project, :build, presence: true
      validates :sbom_file, presence: true, if: -> { running? }
      validates :sbom_file_final_path, length: { maximum: 1024 }
      validates :error_message, length: { maximum: 1024 }

      # This model holds two file attachments and uses a custom uploader that don't create Upload records.
      # See https://gitlab.com/gitlab-org/gitlab/-/issues/425484 about why creating Upload records is now discouraged.
      mount_uploader :sbom_file, Security::VulnerabilityScanning::SbomScanUploader
      mount_uploader :result_file, Security::VulnerabilityScanning::SbomScanUploader

      # Avoid storing large files during DB transaction. We call these methods manually instead.
      skip_callback :save, :after, :store_sbom_file!
      skip_callback :save, :after, :store_result_file!

      # Setting default store dynamically based on the instance storage configuration
      attribute :sbom_file_store, default: -> { ::Security::VulnerabilityScanning::SbomScanUploader.default_store }
      attribute :result_file_store, default: -> { ::Security::VulnerabilityScanning::SbomScanUploader.default_store }

      scope :expired, -> { where(created_at: ...EXPIRED_AGE.ago) }
      scope :not_expired, -> { where(created_at: EXPIRED_AGE.ago..) }
      scope :for_build, ->(build) { where(build: build) }
      scope :for_project_and_sbom_digest, ->(project, sbom_digest) {
        where(project: project, sbom_digest: sbom_digest).where.not(sbom_digest: nil)
      }
      scope :most_recently_finished, -> { where(status: 2).order('created_at desc').limit(1) }

      state_machine :status, initial: :created do
        state :created, value: 0
        state :running, value: 1
        state :finished, value: 2
        state :failed, value: -1

        event :start do
          transition created: :running
        end

        event :finish do
          transition running: :finished
        end

        event :failed do
          transition [:created, :running] => :failed
        end

        event :reset_state do
          transition running: :created
        end
      end

      def fail_with_error_message!(message)
        self.error_message = message&.truncate(1024)
        failed!
      end

      # result_file_attribute enables a dual path for the rollout of the caching feature
      # (see: https://gitlab.com/gitlab-org/gitlab/-/work_items/562694#rollout-plan)
      # where it's possible for the scan results to be stored in either the SbomScan model
      # under the `result_file` attribute or in the SbomScanResult model.
      # For SbomScans in the finished state:
      # - If result is nil, it means the result file is stored in the SbomScan model.
      # - If result is not nil, it means the result file is stored in the SbomScanResult model.
      # Removing this is tracked in https://gitlab.com/gitlab-org/gitlab/-/issues/582203
      alias_method :result_file_attribute, :result_file

      def delete_files_from_storage
        sbom_file.remove!
        result_file_attribute.remove!
        true
      rescue StandardError => e
        Gitlab::ErrorTracking.track_exception(e)
        false
      end

      def result_file
        if result.nil?
          result_file_attribute
        else
          result.result_file
        end
      end
    end
  end
end
