# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    module AdvisoryUtils
      include Gitlab::Utils::StrongMemoize

      def occurrence_is_affected?(purl_type:, range:, version:, distro:, source:, project_id:, xid:, source_xid:)
        matcher = build_matcher(purl_type: purl_type, range: range)
        if Enums::Sbom.container_scanning_purl_type?(purl_type)
          matcher.affected?(distro, source, version)
        else
          matcher.affected?(version)
        end
      rescue SemverDialects::InvalidVersionError, SemverDialects::UnsupportedVersionError => error
        track_indetermined_if_occurence_is_affected(error: error, purl_type: purl_type, version: version,
          project_id: project_id, xid: xid, source_xid: source_xid)
        false
      end

      def build_matcher(purl_type:, range:)
        strong_memoize_with(:build_matcher, purl_type, range) do
          if Enums::Sbom.container_scanning_purl_type?(purl_type)
            Gitlab::VulnerabilityScanning::ContainerScanning::AffectedVersionRangeMatcher.new(
              purl_type: purl_type, range: range)
          else
            Gitlab::VulnerabilityScanning::DependencyScanning::AffectedVersionRangeMatcher.new(
              purl_type: purl_type, range: range)
          end
        end
      end

      def track_indetermined_if_occurence_is_affected(error:, purl_type:, version:, project_id:, xid:, source_xid:)
        ::Gitlab::ErrorTracking.track_exception(
          error,
          message: 'Cannot determine if component is affected',
          purl_type: purl_type,
          version: version,
          project_id: project_id,
          advisory_xid: xid,
          source_xid: source_xid)
      end

      def create_vulnerabilities(advisory:, affected_components:)
        response = ::Security::VulnerabilityScanning::CreateVulnerabilityService.execute(
          advisory: advisory, affected_components: affected_components)

        project_ids_with_upsert = response.payload[:project_ids_with_upsert]
        project_ids_with_error = response.payload[:project_ids_with_error]
        if response.success?
          log_success(advisory: advisory, project_ids_with_upsert: project_ids_with_upsert,
            project_ids_with_error: project_ids_with_error)
        else
          log_error(response.payload[:error], advisory: advisory, project_ids_with_upsert: project_ids_with_upsert,
            project_ids_with_error: project_ids_with_error)
        end
      end

      def log_success(advisory:, project_ids_with_upsert:, project_ids_with_error:)
        Gitlab::AppJsonLogger.debug(message: "Successfully created vulnerabilities on advisory ingestion",
          project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error,
          source_xid: advisory.source_xid, advisory_xid: advisory.xid)
      end

      def log_error(error, advisory:, project_ids_with_upsert:, project_ids_with_error:)
        Gitlab::AppJsonLogger.error(message: "Failed to create vulnerabilities on advisory ingestion", error: error,
          project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error,
          source_xid: advisory.source_xid, advisory_xid: advisory.xid)
      end
    end
  end
end
