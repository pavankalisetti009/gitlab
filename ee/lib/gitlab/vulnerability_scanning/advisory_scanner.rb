# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class AdvisoryScanner
      include Gitlab::Utils::StrongMemoize

      # Scans eligible projects that contain software components affected
      # by an advisory. If affected, it creates new vulnerabilities in the
      # project.
      #
      # @param advisory [PackageMetadata::Advisory] advisory
      def self.scan_projects_for(advisory)
        new(advisory).execute
      end

      # Create a new advisory scanner instance.
      #
      # @param advisory [PackageMetadata::Advisory] advisory
      #
      # @return [Gitlab::VulnerabilityScanning::AdvisoryScanner]
      def initialize(advisory)
        @advisory = advisory
        @possibly_affected_sbom_occurrences_count = 0
        @known_affected_sbom_occurrences_count = 0
        @possibly_affected_projects = {}
        @known_affected_projects = {}
      end

      def execute
        start_time = Time.current.iso8601

        affected_packages.each do |affected_package|
          advisory_data_object = vulnerability_scanning_advisory(solution: solution(affected_package))
          purl_type = affected_package.purl_type
          package_name = affected_package.package_name
          ::Sbom::PossiblyAffectedOccurrencesFinder.new(
            purl_type: purl_type,
            package_name: package_name
          ).execute_in_batches do |batch|
            bulk_vulnerability_ingestion(affected_package, advisory_data_object, batch)
          end
        end

        Gitlab::VulnerabilityScanning::TrackCvsService.new(
          advisory: advisory,
          start_time: start_time,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: possibly_affected_projects_count,
            known_affected_projects: known_affected_projects_count,
            possibly_affected_sbom_occurrences: possibly_affected_sbom_occurrences_count,
            known_affected_sbom_occurrences: known_affected_sbom_occurrences_count
          }
        ).execute
      end

      private

      SUPPORTED_CONTAINER_SCANNING_PURL_TYPES = %w[deb rpm apk].freeze

      attr_reader :advisory, :possibly_affected_sbom_occurrences_count, :known_affected_sbom_occurrences_count

      def affected_packages
        if advisory.from_container_scanning?
          return advisory.affected_packages.filter do |affected_package|
            SUPPORTED_CONTAINER_SCANNING_PURL_TYPES.include?(affected_package.purl_type)
          end
        end

        advisory.affected_packages
      end
      strong_memoize_attr :affected_packages

      def occurrence_is_affected?(purl_type:, range:, version:, distro:, source:, project_id:)
        matcher = build_matcher(purl_type: purl_type, range: range)
        if Enums::Sbom.container_scanning_purl_type?(purl_type)
          matcher.affected?(distro, source, version)
        else
          matcher.affected?(version)
        end
      rescue SemverDialects::InvalidVersionError, SemverDialects::UnsupportedVersionError => error
        log_cannot_determine_if_occurence_is_affected(error: error, purl_type: purl_type, version: version,
          project_id: project_id)
        false
      end

      def build_matcher(purl_type:, range:)
        strong_memoize_with(:build_matcher, purl_type, range) do
          if Enums::Sbom.container_scanning_purl_type?(purl_type)
            Gitlab::VulnerabilityScanning::ContainerScanning::AffectedVersionRangeMatcher.new(
              purl_type: purl_type, range: range)
          else
            Gitlab::VulnerabilityScanning::DependencyScanning::AffectedVersionRangeMatcher.new(
              purl_type: purl_type, range: range)
          end
        end
      end

      def log_cannot_determine_if_occurence_is_affected(error:, purl_type:, version:, project_id:)
        ::Gitlab::ErrorTracking.track_exception(
          error,
          message: 'Cannot determine if component is affected',
          purl_type: purl_type,
          version: version,
          project_id: project_id,
          advisory_xid: advisory.advisory_xid,
          source_xid: advisory.source_xid)
      end

      def vulnerability_scanning_advisory(solution:)
        Gitlab::VulnerabilityScanning::Advisory.new(
          xid: advisory.advisory_xid,
          title: advisory.title,
          description: advisory.description,
          identifiers: advisory.identifiers,
          urls: advisory.urls,
          cvss_v2: advisory.cvss_v2,
          cvss_v3: advisory.cvss_v3,
          solution: solution,
          source_xid: advisory.source_xid
        )
      end

      def solution(affected_package)
        return affected_package.solution if affected_package.solution.present?

        # This is a Container Scanning affected package, check for presence of fixed_versions.
        fixed_versions = affected_package.fixed_versions.delete_if { |v| v == '*' }
        return 'Unfortunately, there is no solution available yet.' if fixed_versions.empty?

        "Upgrade to version #{fixed_versions.join(', ')} or above"
      end

      def bulk_vulnerability_ingestion(affected_package, advisory_data_object, occurrences_batch)
        affected_components = occurrences_batch.filter_map do |occurrence|
          count_possibly_affected_sbom_occurrence(occurrence)

          next unless occurrence_is_affected?(
            purl_type: affected_package.purl_type,
            range: affected_package.affected_range,
            version: occurrence.version,
            distro: affected_package.distro_version,
            source: occurrence.source,
            project_id: occurrence.project_id
          )

          count_known_affected_sbom_occurrence(occurrence)

          Gitlab::VulnerabilityScanning::PossiblyAffectedComponent
            .from_sbom_occurrence(occurrence)
        end

        return if affected_components.empty?

        create_vulnerabilities(advisory_data_object, affected_components)
      end

      def create_vulnerabilities(advisory, affected_components)
        response = ::Security::VulnerabilityScanning::CreateVulnerabilityService.execute(
          advisory: advisory, affected_components: affected_components)

        project_ids_with_upsert = response.payload[:project_ids_with_upsert]
        project_ids_with_error = response.payload[:project_ids_with_error]
        if response.success?
          log_success(project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error)
        else
          log_error(response.payload[:error], project_ids_with_upsert: project_ids_with_upsert,
            project_ids_with_error: project_ids_with_error)
        end
      end

      def count_possibly_affected_sbom_occurrence(occurrence)
        @possibly_affected_sbom_occurrences_count += 1
        @possibly_affected_projects[occurrence.project.id] = true
      end

      def count_known_affected_sbom_occurrence(occurrence)
        @known_affected_sbom_occurrences_count += 1
        @known_affected_projects[occurrence.project.id] = true
      end

      def possibly_affected_projects_count
        @possibly_affected_projects.keys.size
      end

      def known_affected_projects_count
        @known_affected_projects.keys.size
      end

      def log_success(project_ids_with_upsert:, project_ids_with_error:)
        Gitlab::AppJsonLogger.debug(message: "Successfully created vulnerabilities on advisory ingestion",
          project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error,
          source_xid: advisory.source_xid, advisory_xid: advisory.advisory_xid)
      end

      def log_error(error, project_ids_with_upsert:, project_ids_with_error:)
        Gitlab::AppJsonLogger.error(message: "Failed to create vulnerabilities on advisory ingestion", error: error,
          project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error,
          source_xid: advisory.source_xid, advisory_xid: advisory.advisory_xid)
      end
    end
  end
end
