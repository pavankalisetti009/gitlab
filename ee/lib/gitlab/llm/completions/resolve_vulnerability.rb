# frozen_string_literal: true

module Gitlab
  module Llm
    module Completions
      class ResolveVulnerability < Gitlab::Llm::Completions::Base
        DEFAULT_ERROR = 'An unexpected error has occurred.'
        CLIENT_TIMEOUT_ERROR = 'The upstream AI provider request timed out without responding.'
        FORBIDDEN_ERROR = "Unfortunately, you don't have access to vulnerability resolution."
        RESOLUTION_FAILURE_ERROR = 'Something went wrong while attempting to apply the ' \
                                   'AI resolution to a merge request.'
        MR_LINK_ERROR = 'An error occurred while attempting to link the MR to the vulnerability.'
        RESPONSE_FAILURE_ERROR = 'Response from AI is unreadable. Please try again.'
        START_CODE = "<fixed_code>\n"
        END_CODE = "</fixed_code>"
        START_ANALYSIS = "<analysis>\n"
        END_ANALYSIS = "</analysis>"
        START_SUMMARY = "<summary>\n"
        END_SUMMARY = "</summary>"
        START_IS_FALSE_POSITIVE = "<is_false_positive>\n"
        END_IS_FALSE_POSITIVE = "</is_false_positive>"

        def execute
          ai_response, diff_extracted, description_options = response_for(user, vulnerability, options)
          response = if diff_extracted
                       if suggestion_merge_request_id
                         create_merge_request_suggestion(user,
                           vulnerability,
                           suggestion_merge_request_id,
                           ai_response,
                           description_options)
                       else
                         create_merge_request(user, vulnerability, ai_response, description_options)
                       end
                     else
                       ai_response
                     end

          response_modifier = modify_response(response, vulnerability)

          ::Gitlab::Llm::GraphqlSubscriptionResponseService.new(
            user, vulnerability, response_modifier, options: response_options
          ).execute

          response_modifier
        rescue StandardError => error
          Gitlab::ErrorTracking.track_exception(error)
          log_local_error(error)

          response = formatted_error_response(error_message(error))
          response_modifier = modify_response(response, vulnerability)
          ::Gitlab::Llm::GraphqlSubscriptionResponseService.new(
            user, vulnerability, response_modifier, options: response_options
          ).execute

          response_modifier
        end

        def response_for(user, vulnerability, options)
          Rails.cache.fetch(cache_key(user, vulnerability), expires_in: 10.minutes, skip_nil: true) do
            prompt = ai_prompt_class.new(vulnerability, options).to_prompt
            ai_response = request(user, prompt)

            extract_llm_change(ai_response)
          end
        end

        private

        def extract_llm_change(ai_response)
          content = ai_response.dig('predictions', 0, 'content') || ai_response.dig('content', 0, 'text') || ''
          description_options = {}
          regex = /(?<=#{Regexp.escape(START_CODE)}).*?(?=#{Regexp.escape(END_CODE)})/mo

          match_data = content.match(regex)
          return [ai_response, false, description_options] unless match_data
          return [{ false_positive: true }, false, description_options] if match_data[0].blank?

          description_options[:analysis_data] = get_analysis_data(content)
          description_options[:summary_data] = get_summary_data(content)

          return [{ false_positive: true }, false, description_options] if false_positive?(content)

          [match_data[0], true, description_options]
        end

        def create_merge_request_suggestion(
          user, vulnerability, suggestion_merge_request_id, response,
          _description_options = {})

          suggestion_merge_request = MergeRequest.find(suggestion_merge_request_id)

          merge_request_result = ::MergeRequests::CreateFromVulnerabilityDataService.new(
            vulnerability.project,
            vulnerability,
            user,
            llm_patch: response,
            suggestion_merge_request: suggestion_merge_request
          ).execute

          unless merge_request_result[:status] == :success
            message = RESOLUTION_FAILURE_ERROR
            if merge_request_result[:unreadable_response]
              message = RESPONSE_FAILURE_ERROR
              invalidate_cache!
            end

            log_local_error(message)
            return formatted_error_response(message,
              context: merge_request_result)
          end

          suggestion = merge_request_result[:merge_request]

          { merge_request_url: Gitlab::UrlBuilder.note_url(suggestion), suggestion_id: suggestion.id }
        end

        def suggestion_merge_request_id
          return unless @options[:suggestion_merge_request_id]

          GitlabSchema.parse_gid(@options[:suggestion_merge_request_id]).model_id
        end

        def create_merge_request(user, vulnerability, response, description_options = {})
          return unless response.present? && !@null_prompt_error

          merge_request_result = ::MergeRequests::CreateFromVulnerabilityDataService.new(
            vulnerability.project,
            vulnerability,
            user,
            llm_patch: response,
            description_options: description_options
          ).execute

          unless merge_request_result[:status] == :success
            message = RESOLUTION_FAILURE_ERROR
            if merge_request_result[:unreadable_response]
              message = RESPONSE_FAILURE_ERROR
              invalidate_cache!
            end

            log_local_error(message)
            return formatted_error_response(message,
              context: merge_request_result)
          end

          merge_request = merge_request_result[:merge_request]

          mr_link_result = VulnerabilityMergeRequestLinks::CreateService.new(
            project: vulnerability.project,
            current_user: user,
            params: {
              vulnerability: vulnerability,
              merge_request: merge_request
            }
          ).execute

          unless mr_link_result[:status] == :success
            return formatted_error_response(MR_LINK_ERROR,
              context: mr_link_result)
          end

          mr_url = Gitlab::Routing.url_helpers.project_merge_request_url(
            merge_request.project,
            merge_request
          )

          { merge_request_url: mr_url }
        end

        def error_message(error)
          case error
          when Gitlab::Llm::Templates::Vulnerabilities::PromptError
            error.message
          when Net::ReadTimeout
            CLIENT_TIMEOUT_ERROR
          when Gitlab::AiGateway::ForbiddenError
            FORBIDDEN_ERROR
          else
            DEFAULT_ERROR
          end
        end

        def formatted_error_response(message, context = {})
          { error: { message: message, context: context } }.to_json
        end

        def modify_response(response, _vulnerability)
          ::Gitlab::Llm::ResponseModifiers::ResolveVulnerability.new(response)
        end

        def request(user, prompt)
          ::Gitlab::Llm::ResolveVulnerability::Client.new(user,
            unit_primitive: 'resolve_vulnerability',
            tracking_context: tracking_context
          ).messages_complete(**prompt)
        end

        def cache_key(user, vulnerability)
          [user.id, vulnerability.cache_key, 'resolve'].join('/')
        end

        def vulnerability
          resource
        end

        def get_analysis_data(content)
          analysis_regex = /(?<=#{Regexp.escape(START_ANALYSIS)}).*?(?=#{Regexp.escape(END_ANALYSIS)})/mo

          analysis_match_data = content.match(analysis_regex)
          analysis_match_data[0] if analysis_match_data
        end

        def get_summary_data(content)
          summary_regex = /(?<=#{Regexp.escape(START_SUMMARY)}).*?(?=#{Regexp.escape(END_SUMMARY)})/mo

          summary_match_data = content.match(summary_regex)
          summary_match_data[0] if summary_match_data
        end

        def false_positive?(content)
          is_false_positive_regex = %r{
            (?<=#{Regexp.escape(START_IS_FALSE_POSITIVE)})
            .*?
            (?=#{Regexp.escape(END_IS_FALSE_POSITIVE)})
          }xmo

          is_false_positive_match_data = content.match(is_false_positive_regex)
          is_false_positive_match_data[0].strip.casecmp?('true') if is_false_positive_match_data
        end

        def invalidate_cache!
          Rails.cache.delete(cache_key(user, vulnerability))
        end
      end
    end
  end
end
