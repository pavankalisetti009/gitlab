# frozen_string_literal: true

module Search
  module Elastic
    module References
      class Vulnerability < Reference
        include Search::Elastic::Concerns::DatabaseReference
        include ::Gitlab::Utils::StrongMemoize

        SCHEMA_VERSION = 25_14
        DOC_TYPE = 'vulnerability'
        INDEX_NAME = 'vulnerabilities'

        # Create a new reference string from a vulnerability record
        override :serialize
        def self.serialize(record)
          new(record.vulnerability_id, record.es_parent).serialize
        end

        # Parse a reference string into a new instance
        override :instantiate
        def self.instantiate(string)
          _, id, routing = delimit(string)
          new(id, routing)
        end

        # Efficiently preload data for a batch of references to avoid N+1 queries
        override :preload_indexing_data
        def self.preload_indexing_data(refs)
          ids = refs.map(&:identifier)

          records_array = Array(model_klass.preload_indexing_data.find_by_vulnerability_id(ids))

          records_by_id = records_array.index_by(&:vulnerability_id)

          cve_map = extract_cve_values(records_array)
          enrichments_by_cve = preload_cve_enrichments(cve_map.values)

          assign_proxied_records_to_refs(refs, records_by_id, cve_map, enrichments_by_cve)

          refs
        end

        def self.index
          environment_specific_index_name(INDEX_NAME)
        end

        def self.model_klass
          ::Vulnerabilities::Read
        end

        attr_reader :identifier, :routing

        def initialize(identifier, routing)
          @identifier = identifier.to_i
          @routing = routing
        end

        # Convert this reference to a string
        override :serialize
        def serialize
          self.class.join_delimited([klass, identifier, routing].compact)
        end

        # Generate the JSON representation for elasticsearch indexing
        override :as_indexed_json
        def as_indexed_json
          fields = {}

          direct_fields = %w[
            id vulnerability_id project_id scanner_id uuid location_image
            cluster_agent_id casted_cluster_agent_id has_issues
            resolved_on_default_branch has_merge_request
            has_remediations archived has_vulnerability_resolution auto_resolved
          ]

          direct_fields.each { |field| fields[field] = database_record.read_attribute(field) }

          typecast_fields = %w[report_type severity state dismissal_reason]
          typecast_fields.each { |field| fields[field] = database_record.method(:"#{field}_before_type_cast").call }

          # Add other fields
          fields["scanner_external_id"] = database_record.scanner&.external_id
          fields["created_at"] = database_record.vulnerability.created_at
          fields["updated_at"] = database_record.vulnerability.updated_at
          fields["traversal_ids"] = database_record.project.namespace.elastic_namespace_ancestry
          fields["identifier_names"] = database_record.identifier_names
          fields["epss_scores"] = fetch_epss_scores(database_record)

          internal_es_fields.merge(fields)
        end

        override :index_name
        def index_name
          self.class.index
        end

        # Get the actual vulnerability record from the database
        # The primary key is `vulnerability_id` and in the original method we are using `find_by_id`
        override :database_record
        def database_record
          model_klass.find_by(vulnerability_id: identifier) # rubocop: disable CodeReuse/ActiveRecord -- One off case.
        end
        strong_memoize_attr :database_record

        # Get the model class for database operations
        def model_klass
          self.class.model_klass
        end

        # Get EPSS scores for a vulnerability record, optimized to avoid N+1 queries
        def fetch_epss_scores(record)
          # Check if the record responds to proxy epss_scores
          return record.epss_scores if record.respond_to?(:epss_scores)

          # Fallback for records not processed through our preloading
          []
        end

        def internal_es_fields
          {
            schema_version: SCHEMA_VERSION,
            type: DOC_TYPE
          }
        end

        #
        # Proxy class for optimized record access
        #

        # Simple proxy class that delegates to the original record
        # but can override specific methods for performance
        class RecordProxy < SimpleDelegator
          # Methods are defined dynamically in create_record_proxy
        end

        #
        # Private class methods for implementation details
        #

        class << self
          private

          # Extract CVE values from records in a single pass to avoid N+1 queries
          def extract_cve_values(records)
            cve_map = {}
            records.each do |record|
              cve = record.cve_value
              cve_map[record.id] = cve if cve.present?
            end
            cve_map
          end

          # Preload all CVE enrichments in a single query
          def preload_cve_enrichments(cve_values)
            unique_cves = cve_values.uniq
            return {} if unique_cves.empty?

            cve_enrichments = ::PackageMetadata::CveEnrichment.by_cves(unique_cves)
            cve_enrichments.group_by(&:cve)
          end

          # Assign proxied records to references
          def assign_proxied_records_to_refs(refs, records_by_id, cve_map, enrichments_by_cve)
            refs.each do |ref|
              record = records_by_id[ref.identifier]
              next unless record

              proxy = create_record_proxy(record, cve_map, enrichments_by_cve)
              ref.database_record = proxy
            end
          end

          # Create a proxy object that wraps a record and provides optimized methods
          def create_record_proxy(record, cve_map, enrichments_by_cve)
            proxy = RecordProxy.new(record)

            cve = cve_map[record.id]
            enrichments = enrichments_by_cve[cve] || []

            # Override methods with optimized versions
            proxy.define_singleton_method(:cve_value) { cve }
            proxy.define_singleton_method(:epss_scores) { enrichments.map(&:epss_score) }

            proxy
          end
        end
      end
    end
  end
end
