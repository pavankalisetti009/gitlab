# frozen_string_literal: true

module Search
  module Elastic
    module VulnerabilityFilters
      class << self
        include ::Elastic::Latest::QueryContext::Aware
        include Search::Elastic::Concerns::FilterUtils

        OWASP_IDENTIFIER_PARAM_REGEXPS = {
          '2017' => %r{A([1-9]|10)_2017},
          '2021' => %r{A(0?[1-9]|10)_2021}
        }.freeze

        def by_archived_projects(query_hash:, options:)
          raise ArgumentError, 'search_level is a required option' unless options.key?(:search_level)

          search_level = options[:search_level].to_sym
          return query_hash if search_level == :project

          archived = options[:archived] || false
          return query_hash if archived

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { archived: { _name: context.name(:archived_projects), value: archived } } }
            end
          end
        end

        def by_cluster_agent_id(query_hash:, options:)
          cluster_agent_id = options[:cluster_agent_id]
          return query_hash if cluster_agent_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { cluster_agent_id: { _name: context.name(:cluster_agent_id), value: cluster_agent_id } } }
            end
          end
        end

        def by_dismissal_reason(query_hash:, options:)
          dismissal_reason = options[:dismissal_reason]
          return query_hash if dismissal_reason.blank?
          return query_hash unless options[:state] == 2 # "dismissed"=>2
          return query_hash unless ::Vulnerabilities::DismissalReasonEnum.values.value?(dismissal_reason)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { dismissal_reason: { _name: context.name(:dismissal_reason), value: dismissal_reason } } }
            end
          end
        end

        def by_has_ai_resolution(query_hash:, options:)
          has_ai_resolution = options[:has_ai_resolution]
          return query_hash if has_ai_resolution.nil?
          return query_hash unless has_ai_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                term: {
                  has_vulnerability_resolution: {
                    _name: context.name(:has_ai_resolution), value: has_ai_resolution
                  }
                }
              }
            end
          end
        end

        def by_has_issues(query_hash:, options:)
          has_issues = options[:has_issues]
          return query_hash if has_issues.nil?
          return query_hash unless has_issues.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_issues: { _name: context.name(:has_issues), value: has_issues } } }
            end
          end
        end

        def by_has_merge_request(query_hash:, options:)
          has_merge_request = options[:has_merge_request]
          return query_hash if has_merge_request.nil?
          return query_hash unless has_merge_request.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_merge_request: { _name: context.name(:has_merge_request), value: has_merge_request } } }
            end
          end
        end

        def by_has_remediations(query_hash:, options:)
          has_remediations = options[:has_remediations]
          return query_hash if has_remediations.nil?
          return query_hash unless has_remediations.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_remediations: { _name: context.name(:has_remediations), value: has_remediations } } }
            end
          end
        end

        def by_has_resolution(query_hash:, options:)
          has_resolution = options[:has_resolution]
          return query_hash if has_resolution.nil?
          return query_hash unless has_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { resolved_on_default_branch: { _name: context.name(:has_resolution), value: has_resolution } } }
            end
          end
        end

        def by_identifier_names(query_hash:, options:)
          identifier_names = options[:identifier_names]
          return query_hash if identifier_names.nil? || identifier_names.empty?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  must: {
                    terms: {
                      _name: context.name(:identifier_names),
                      "identifier_names.keyword": Array.wrap(identifier_names)
                    }
                  }
                }
              }
            end
          end
        end

        def by_partial_identifier_name(query_hash:, options:)
          partial_identifier_name = options[:partial_identifier_name]
          return query_hash if partial_identifier_name.nil?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  must: {
                    simple_query_string: {
                      _name: context.name(:partial_identifier_name),
                      fields: [
                        "identifier_names",
                        "identifier_names.ngram"
                      ],
                      query: partial_identifier_name,
                      lenient: true,
                      default_operator: :and
                    }
                  }
                }
              }
            end
          end
        end

        def by_image(query_hash:, options:)
          image = options[:image]
          return query_hash if image.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { image: { _name: context.name(:image), value: image } } }
            end
          end
        end

        def by_owasp_top_10(query_hash:, options:, year:)
          option_key = :"owasp_top_10_#{year}"
          owasp_value = options[option_key]
          return query_hash unless owasp_value

          # Get the appropriate regex for the year
          regex_constant = OWASP_IDENTIFIER_PARAM_REGEXPS.fetch(year)

          unless owasp_value == "NONE" || regex_constant.match?(owasp_value)
            raise ArgumentError, "invalid value for #{option_key}"
          end

          nested_query = if owasp_value == "NONE"
                           {
                             must_not: {
                               bool: {
                                 should: ::Enums::Vulnerability::OWASP_TOP_10_BY_YEAR[year].keys.map do |k|
                                   formatted_key = k.split("-").first
                                   {
                                     prefix: {
                                       "identifier_names.keyword": {
                                         value: formatted_key
                                       }
                                     }
                                   }
                                 end,
                                 minimum_should_match: 1
                               }
                             }
                           }
                         else
                           {
                             must: {
                               prefix: {
                                 "identifier_names.keyword": {
                                   value: owasp_value.split('_').join(':')
                                 }
                               }
                             }
                           }
                         end

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  _name: context.name(option_key),
                  **nested_query
                }
              }
            end
          end
        end

        def by_owasp_top_10_2017(query_hash:, options:)
          by_owasp_top_10(query_hash: query_hash, options: options, year: '2017')
        end

        def by_owasp_top_10_2021(query_hash:, options:)
          by_owasp_top_10(query_hash: query_hash, options: options, year: '2021')
        end

        def by_projects(query_hash:, options:)
          raise ArgumentError, 'search_level is a required option' unless options.key?(:search_level)

          search_level = options[:search_level].to_sym
          return query_hash if search_level == :project

          project_id = options[:project_id]
          return query_hash if project_id.nil?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { project_id: { _name: context.name(:project_id), value: project_id } } }
            end
          end
        end

        def by_report_type(query_hash:, options:)
          report_type = options[:report_type]
          return query_hash if report_type.blank?
          return query_hash unless ::Vulnerability.report_types.value?(report_type)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { report_type: { _name: context.name(:report_type), value: report_type } } }
            end
          end
        end

        def by_scanner_ids(query_hash:, options:)
          scanner_id = options[:scanner_id]
          return query_hash if scanner_id.nil?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { scanner_id: { _name: context.name(:scanner_id), value: scanner_id } } }
            end
          end
        end

        def by_severities(query_hash:, options:)
          severity = options[:severity]
          return query_hash if severity.blank?
          return query_hash unless ::Vulnerability.severities.value?(severity)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { severity: { _name: context.name(:severity), value: severity } } }
            end
          end
        end

        def by_state(query_hash:, options:)
          state = options[:state]
          return query_hash if state.blank?
          return query_hash unless ::Vulnerability.states.value?(state)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { state: { _name: context.name(:state), value: state } } }
            end
          end
        end
      end
    end
  end
end
