# frozen_string_literal: true

module Search
  module Elastic
    module VulnerabilityFilters
      class << self
        include ::Elastic::Latest::QueryContext::Aware
        include Search::Elastic::Concerns::FilterUtils

        def by_archived_projects(query_hash:, options:)
          raise ArgumentError, 'search_level is a required option' unless options.key?(:search_level)

          search_level = options[:search_level].to_sym
          return query_hash if search_level == :project

          archived = options[:archived] || false
          return query_hash if archived

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { archived: { _name: context.name(:archived_projects), value: archived } } }
            end
          end
        end

        def by_cluster_agent_id(query_hash:, options:)
          cluster_agent_id = options[:cluster_agent_id]
          return query_hash if cluster_agent_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { cluster_agent_id: { _name: context.name(:cluster_agent_id), value: cluster_agent_id } } }
            end
          end
        end

        def by_dismissal_reason(query_hash:, options:)
          dismissal_reason = options[:dismissal_reason]
          return query_hash if dismissal_reason.blank?
          return query_hash unless options[:state] == 2 # "dismissed"=>2
          return query_hash unless ::Vulnerabilities::DismissalReasonEnum.values.value?(dismissal_reason)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { dismissal_reason: { _name: context.name(:dismissal_reason), value: dismissal_reason } } }
            end
          end
        end

        def by_has_ai_resolution(query_hash:, options:)
          has_ai_resolution = options[:has_ai_resolution]
          return query_hash if has_ai_resolution.nil?
          return query_hash unless has_ai_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                term: {
                  has_vulnerability_resolution: {
                    _name: context.name(:has_ai_resolution), value: has_ai_resolution
                  }
                }
              }
            end
          end
        end

        def by_has_issues(query_hash:, options:)
          has_issues = options[:has_issues]
          return query_hash if has_issues.nil?
          return query_hash unless has_issues.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_issues: { _name: context.name(:has_issues), value: has_issues } } }
            end
          end
        end

        def by_has_merge_request(query_hash:, options:)
          has_merge_request = options[:has_merge_request]
          return query_hash if has_merge_request.nil?
          return query_hash unless has_merge_request.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_merge_request: { _name: context.name(:has_merge_request), value: has_merge_request } } }
            end
          end
        end

        def by_has_remediations(query_hash:, options:)
          has_remediations = options[:has_remediations]
          return query_hash if has_remediations.nil?
          return query_hash unless has_remediations.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_remediations: { _name: context.name(:has_remediations), value: has_remediations } } }
            end
          end
        end

        def by_has_resolution(query_hash:, options:)
          has_resolution = options[:has_resolution]
          return query_hash if has_resolution.nil?
          return query_hash unless has_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { resolved_on_default_branch: { _name: context.name(:has_resolution), value: has_resolution } } }
            end
          end
        end

        def by_identifier_names(query_hash:, options:)
          identifier_names = options[:identifier_names]
          return query_hash if identifier_names.nil? || identifier_names.empty?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  must: {
                    terms: {
                      _name: context.name(:identifier_names),
                      identifier_names: identifier_names
                    }
                  }
                }
              }
            end
          end
        end

        def by_image(query_hash:, options:)
          image = options[:image]
          return query_hash if image.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { image: { _name: context.name(:image), value: image } } }
            end
          end
        end

        def by_owasp_10_2017(query_hash:, options:)
          owasp_10_2017 = options[:owasp_10_2017]
          return query_hash unless owasp_10_2017

          patterns = %w[
            A1:2017* A01:2017* A2:2017* A02:2017*
            A3:2017* A03:2017* A4:2017* A04:2017*
            A5:2017* A05:2017* A6:2017* A06:2017*
            A7:2017* A07:2017* A8:2017* A08:2017*
            A9:2017* A09:2017* A10:2017*
          ].freeze

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              should_clauses = patterns.map do |pattern|
                { wildcard: { identifier_name: pattern } }
              end

              {
                _name: context.name(:owasp_10_2017),
                should: should_clauses,
                minimum_should_match: 1
              }
            end
          end
        end

        def by_projects(query_hash:, options:)
          raise ArgumentError, 'search_level is a required option' unless options.key?(:search_level)

          search_level = options[:search_level].to_sym
          return query_hash if search_level == :project

          project_id = options[:project_id]
          return query_hash if project_id.nil?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { project_id: { _name: context.name(:project_id), value: project_id } } }
            end
          end
        end

        def by_report_type(query_hash:, options:)
          report_type = options[:report_type]
          return query_hash if report_type.blank?
          return query_hash unless ::Vulnerability.report_types.value?(report_type)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { report_type: { _name: context.name(:report_type), value: report_type } } }
            end
          end
        end

        def by_scanner_ids(query_hash:, options:)
          scanner_id = options[:scanner_id]
          return query_hash if scanner_id.nil?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { scanner_id: { _name: context.name(:scanner_id), value: scanner_id } } }
            end
          end
        end

        def by_severities(query_hash:, options:)
          severity = options[:severity]
          return query_hash if severity.blank?
          return query_hash unless ::Vulnerability.severities.value?(severity)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { severity: { _name: context.name(:severity), value: severity } } }
            end
          end
        end

        def by_state(query_hash:, options:)
          state = options[:state]
          return query_hash if state.blank?
          return query_hash unless ::Vulnerability.states.value?(state)

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { state: { _name: context.name(:state), value: state } } }
            end
          end
        end
      end
    end
  end
end
