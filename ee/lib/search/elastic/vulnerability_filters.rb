# frozen_string_literal: true

module Search
  module Elastic
    module VulnerabilityFilters
      class << self
        include ::Elastic::Latest::QueryContext::Aware
        include Search::Elastic::Concerns::FilterUtils

        DISMISSED_STATE = 2

        def by_archived_projects(query_hash:, options:)
          raise ArgumentError, 'search_level is a required option' unless options.key?(:search_level)

          search_level = options[:search_level].to_sym
          return query_hash if search_level == :project

          include_archived_projects = !!options[:include_archived_projects]
          return query_hash if include_archived_projects

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { archived: { _name: context.name(:archived_projects), value: false } } }
            end
          end
        end

        def by_cluster_agent_id(query_hash:, options:)
          cluster_agent_id = options[:cluster_agent_id]
          return query_hash if cluster_agent_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:cluster_agent_id),
                  cluster_agent_id: cluster_agent_id
                }
              }
            end
          end
        end

        def by_state_and_dismissal_reason(query_hash:, options:)
          dismissal_reason = options[:dismissal_reason]
          state = options[:state]
          return query_hash if dismissal_reason.blank? && state.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              if state.present? && dismissal_reason.present?
                {
                  bool: {
                    _name: context.name(:state_and_dismissal_reason),
                    should: [
                      { terms: { state: state } },
                      {
                        bool: {
                          must: [
                            {
                              terms: { state: [DISMISSED_STATE] }
                            },
                            {
                              terms: { dismissal_reason: dismissal_reason }
                            }
                          ]
                        }
                      }
                    ],
                    minimum_should_match: 1
                  }
                }
              elsif state.present?
                { terms: { _name: context.name(:state), state: state } }
              else
                {
                  bool: {
                    _name: context.name(:dismissal_reason),
                    must: [
                      {
                        terms: { state: [DISMISSED_STATE] }
                      },
                      {
                        terms: { dismissal_reason: dismissal_reason }
                      }
                    ]
                  }
                }
              end
            end
          end
        end

        def by_has_ai_resolution(query_hash:, options:)
          has_ai_resolution = options[:has_ai_resolution]
          return query_hash if has_ai_resolution.nil?
          return query_hash unless has_ai_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                term: {
                  has_vulnerability_resolution: {
                    _name: context.name(:has_ai_resolution),
                    value: has_ai_resolution
                  }
                }
              }
            end
          end
        end

        def by_has_issues(query_hash:, options:)
          has_issues = options[:has_issues]
          return query_hash if has_issues.nil?
          return query_hash unless has_issues.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_issues: { _name: context.name(:has_issues), value: has_issues } } }
            end
          end
        end

        def by_has_merge_request(query_hash:, options:)
          has_merge_request = options[:has_merge_request]
          return query_hash if has_merge_request.nil?
          return query_hash unless has_merge_request.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_merge_request: { _name: context.name(:has_merge_request), value: has_merge_request } } }
            end
          end
        end

        def by_has_remediations(query_hash:, options:)
          has_remediations = options[:has_remediations]
          return query_hash if has_remediations.nil?
          return query_hash unless has_remediations.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { has_remediations: { _name: context.name(:has_remediations), value: has_remediations } } }
            end
          end
        end

        def by_has_resolution(query_hash:, options:)
          has_resolution = options[:has_resolution]
          return query_hash if has_resolution.nil?
          return query_hash unless has_resolution.in?([true, false])

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              { term: { resolved_on_default_branch: { _name: context.name(:has_resolution), value: has_resolution } } }
            end
          end
        end

        def by_identifier_names(query_hash:, options:)
          identifier_name = options[:identifier_name]
          return query_hash if identifier_name.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  must: {
                    terms: {
                      _name: context.name(:identifier_name),
                      "identifier_names.keyword": identifier_name
                    }
                  }
                }
              }
            end
          end
        end

        def by_partial_identifier_name(query_hash:, options:)
          partial_identifier_name = options[:partial_identifier_name]
          return query_hash if partial_identifier_name.nil?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  must: {
                    simple_query_string: {
                      _name: context.name(:partial_identifier_name),
                      fields: [
                        "identifier_names",
                        "identifier_names.ngram"
                      ],
                      query: partial_identifier_name,
                      lenient: true,
                      default_operator: :and
                    }
                  }
                }
              }
            end
          end
        end

        def by_image(query_hash:, options:)
          image = options[:image]
          return query_hash if image.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:image),
                  location_image: image
                }
              }
            end
          end
        end

        def by_owasp_top_10_2017(query_hash:, options:)
          owasp_value = options[:owasp_top_10_2017]&.join
          return query_hash unless owasp_value

          # owasp 2017 will support both 2017 and 2021 identifiers for
          # backwards compatibility
          regex_constant = %r{A(0?[1-9]|10):(2017|2021)-.*}
          return query_hash unless owasp_value.casecmp("none") == 0 || regex_constant.match?(owasp_value)

          nested_query = if owasp_value.casecmp("none") == 0
                           {
                             must_not: {
                               bool: {
                                 should: ::Enums::Vulnerability::OWASP_TOP_10.keys.map do |k|
                                   formatted_key = k.split("-").first
                                   {
                                     prefix: {
                                       "identifier_names.keyword": {
                                         value: formatted_key
                                       }
                                     }
                                   }
                                 end,
                                 minimum_should_match: 1
                               }
                             }
                           }
                         else
                           {
                             must: {
                               prefix: {
                                 "identifier_names.keyword": {
                                   value: owasp_value.split("-").first
                                 }
                               }
                             }
                           }
                         end

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  _name: context.name(:owasp_top_10_2017),
                  **nested_query
                }
              }
            end
          end
        end

        def by_owasp_top_10_2021(query_hash:, options:)
          owasp_value = options[:owasp_top_10_2021]&.join
          return query_hash unless owasp_value

          regex_constant = %r{A(0?[1-9]|10):2021-.*}

          return query_hash unless owasp_value.casecmp("none") == 0 || regex_constant.match?(owasp_value)

          nested_query = if owasp_value.casecmp("none") == 0
                           {
                             must_not: {
                               bool: {
                                 should: ::Enums::Vulnerability::OWASP_TOP_10_BY_YEAR["2021"].keys.map do |k|
                                   formatted_key = k.split("-").first
                                   {
                                     prefix: {
                                       "identifier_names.keyword": {
                                         value: formatted_key
                                       }
                                     }
                                   }
                                 end,
                                 minimum_should_match: 1
                               }
                             }
                           }
                         else
                           {
                             must: {
                               prefix: {
                                 "identifier_names.keyword": {
                                   value: owasp_value.split("-").first
                                 }
                               }
                             }
                           }
                         end

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                bool: {
                  _name: context.name(:owasp_top_10_2021),
                  **nested_query
                }
              }
            end
          end
        end

        def by_projects(query_hash:, options:)
          project_id = options[:project_id]
          return query_hash if project_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:project_id),
                  project_id: project_id
                }
              }
            end
          end
        end

        def by_report_type(query_hash:, options:)
          report_type = options[:report_type]
          return query_hash if report_type.blank?
          return query_hash unless (report_type - ::Vulnerability.report_types.values).empty?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:report_type),
                  report_type: report_type
                }
              }
            end
          end
        end

        def by_scanner_external_ids(query_hash:, options:)
          scanner_external_id = options[:scanner_external_id]
          return query_hash if scanner_external_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:scanner_external_id),
                  scanner_external_id: scanner_external_id
                }
              }
            end
          end
        end

        def by_scanner_ids(query_hash:, options:)
          scanner_id = options[:scanner_id]
          return query_hash if scanner_id.blank?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:scanner_id),
                  scanner_id: scanner_id
                }
              }
            end
          end
        end

        def by_severities(query_hash:, options:)
          severity = options[:severity]
          return query_hash if severity.blank?
          return query_hash unless (severity - ::Vulnerability.severities.values).empty?

          context.name(:filters) do
            add_filter(query_hash, :query, :bool, :filter) do
              {
                terms: {
                  _name: context.name(:severity),
                  severity: severity
                }
              }
            end
          end
        end
      end
    end
  end
end
