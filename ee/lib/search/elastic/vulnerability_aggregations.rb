# frozen_string_literal: true

module Search
  module Elastic
    module VulnerabilityAggregations
      class << self
        include ::Elastic::Latest::QueryContext::Aware

        VULNERABILITIES_OVER_TIME_DAYS_LIMIT = 31

        def by_severity_counts(query_hash:, options:)
          count_by_severity = options[:count_by_severity]
          return query_hash unless count_by_severity

          context.name(:aggregations) do
            query_hash.merge(
              size: 0,
              aggs: {
                severity_counts: {
                  terms: {
                    field: "severity"
                  }
                }
              }
            )
          end
        end

        def by_vulnerabilities_over_time(query_hash:, options:)
          vulnerabilities_over_time = options[:vulnerabilities_over_time]
          return query_hash unless vulnerabilities_over_time

          group_by = options[:group_by]
          raise ArgumentError, "group_by is required" unless group_by.in?(%w[severity report_type])

          end_date = options[:bucket_end_date]
          start_date = options[:bucket_start_date]
          raise ArgumentError, "bucket_start_date and bucket_end_date are required" if start_date.blank? ||
            end_date.blank?

          if start_date > end_date
            raise ArgumentError,
              "bucket_start_date must be before or equal to bucket_end_date"
          end

          if (end_date - start_date).to_i > VULNERABILITIES_OVER_TIME_DAYS_LIMIT
            raise ArgumentError, "bucket_start_date and bucket_end_date must be within 31 days"
          end

          date_filters = {}

          (start_date..end_date).each do |date|
            date_key = date.to_date.iso8601
            date_end_of_day = date.end_of_day.iso8601

            date_filters[date_key] = {
              bool: {
                must: [
                  { range: { created_at: { lte: date_end_of_day } } }
                ],
                must_not: [
                  { range: { resolved_at: { lte: date_end_of_day } } },
                  { range: { dismissed_at: { lte: date_end_of_day } } }
                ]
              }
            }
          end

          context.name(:aggregations) do
            query_hash.merge(
              size: 0,
              aggs: {
                open_by_day: {
                  filters: {
                    filters: date_filters
                  },
                  aggs: {
                    "by_#{group_by}": {
                      terms: {
                        field: group_by,
                        size: 10
                      }
                    }
                  }
                }
              }
            )
          end
        end

        def by_identifiers_search(query_hash:, options:)
          partial_identifier_name = options[:partial_identifier_name]
          return query_hash if partial_identifier_name.blank?

          regexp =
            ".*(#{partial_identifier_name.downcase}|#{partial_identifier_name.upcase}|#{partial_identifier_name}).*"

          query_hash.merge(
            size: 0,
            aggs: {
              unique_identifiers: {
                terms: {
                  field: "identifier_names.original",
                  size: ::Vulnerabilities::Identifier::SEARCH_RESULTS_LIMIT,
                  include: regexp
                }
              }
            }
          )
        end

        def by_risk_score_sum(query_hash:, options:)
          return query_hash unless options[:risk_score_sum]

          query_hash.deep_merge(
            size: 0,
            aggs: {
              risk_scores_sum: {
                sum: {
                  field: "risk_score"
                }
              }
            }
          )
        end

        def by_created_at_sum(query_hash:, options:)
          return query_hash unless options[:created_at_sum]

          query_hash.deep_merge(
            size: 0,
            aggs: {
              created_at_sum: {
                sum: {
                  field: "created_at"
                }
              }
            }
          )
        end
      end
    end
  end
end
