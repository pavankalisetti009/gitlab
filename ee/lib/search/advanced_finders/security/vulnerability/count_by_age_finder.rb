# frozen_string_literal: true

# Vulnerability::CountByAgeFinder
#
# Used to filter Vulnerability records for Vulnerabilities API from vulnerabilities elasticsearch index
#
# Arguments:
#   see in ee/lib/search/advanced_finders/security/base_finder.rb

module Search
  module AdvancedFinders
    module Security
      module Vulnerability
        class CountByAgeFinder < BaseFinder
          def execute
            options = search_params.merge({ count_by_age: true })
            query = ::Search::Elastic::VulnerabilityQueryBuilder.build(query: nil, options: options)

            Gitlab::Search::Client.execute_search(query: query, options: es_search_options) do |es_response|
              response = ::Search::Elastic::ResponseMapper.new(es_response).aggregations
              parsed_aggregations = parse_aggregation(response)
              count_by_age(parsed_aggregations, options)
            end
          end

          private

          def parse_aggregation(response)
            return {} unless response.present?

            response.dig('age_counts', 'buckets')&.transform_values do |bucket|
              extract_bucket_data(bucket)
            end
          end

          def extract_bucket_data(bucket)
            return { "by_severity" => bucket['by_severity']['buckets'] } if bucket["by_severity"].present?

            { "by_report_type" => bucket['by_report_type']['buckets'] } if bucket["by_report_type"].present?
          end

          def count_by_age(parsed_aggregation, options)
            return [] unless parsed_aggregation.present?

            # Define the order we want
            age_band_order = [
              '< 7 days',
              '7 - 14 days',
              '15 - 30 days',
              '31 - 60 days',
              '61 - 90 days',
              '91 - 180 days',
              '> 180 days'
            ]

            age_band_order.filter_map do |age_range|
              metrics = parsed_aggregation[age_range]
              next unless metrics

              build_age_range_metrics(age_range, metrics, options)
            end
          end

          def build_age_range_metrics(age_range, metrics, options)
            result = { "name" => age_range }

            (metrics || []).each do |metric_name, buckets|
              result[metric_name.to_sym] = build_metric_data(metric_name, buckets, options)
            end

            result
          end

          def build_metric_data(metric_name, buckets, options)
            case metric_name
            when "by_severity"
              filtered_severities = options[:severity].presence || []
              build_severity_data(buckets, filtered_severities)
            when "by_report_type"
              filtered_report_types = options[:report_type].presence || []
              build_report_type_data(buckets, filtered_report_types)
            end
          end

          def build_severity_data(buckets, filtered_severities)
            bucket_lookup = create_bucket_lookup(buckets)

            selected_severities = if filtered_severities.empty?
                                    ::Vulnerability.severities
                                  else
                                    ::Vulnerability.severities.select do |_, v|
                                      filtered_severities.include?(v)
                                    end
                                  end

            selected_severities.map do |severity_name, severity_num|
              {
                "count" => extract_count_from_bucket(bucket_lookup[severity_num]),
                "severity" => severity_name.upcase
              }
            end
          end

          def build_report_type_data(buckets, filtered_report_types)
            bucket_lookup = create_bucket_lookup(buckets)

            selected_report_types = if filtered_report_types.empty?
                                      ::Vulnerability.report_types
                                    else
                                      ::Vulnerability.report_types.select do |_, v|
                                        filtered_report_types.include?(v)
                                      end
                                    end

            selected_report_types.map do |type_name, type_num|
              {
                "count" => extract_count_from_bucket(bucket_lookup[type_num]),
                "report_type" => type_name.upcase
              }
            end
          end

          def create_bucket_lookup(buckets)
            buckets.index_by { |bucket| bucket["key"] }
          end

          def extract_count_from_bucket(bucket)
            bucket ? bucket["doc_count"] : 0
          end
        end
      end
    end
  end
end
