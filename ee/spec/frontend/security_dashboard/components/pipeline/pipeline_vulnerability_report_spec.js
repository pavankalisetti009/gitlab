import { GlAlert, GlSprintf } from '@gitlab/ui';
import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import PipelineVulnerabilityReport from 'ee/security_dashboard/components/pipeline/pipeline_vulnerability_report.vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import { visitUrl } from '~/lib/utils/url_utility';
import { createAlert } from '~/alert';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import VulnerabilityReport from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_report.vue';
import FindingModal from 'ee/security_dashboard/components/pipeline/vulnerability_finding_modal.vue';
import enabledScansQuery from 'ee/vue_merge_request_widget/queries/enabled_scans.query.graphql';
import {
  FIELDS,
  FILTERS,
} from 'ee/security_dashboard/components/shared/vulnerability_report/constants';

jest.mock('~/alert');
jest.mock('~/lib/utils/url_utility');

Vue.use(VueApollo);

describe('Pipeline vulnerability report', () => {
  let wrapper;
  const TEST_PIPELINE = { iid: 1, sourceBranch: 'main' };
  const TEST_PROJECT_FULL_PATH = 'path/to/my/project';

  const createWrapper = ({ vulnerabilityPartialScans = false, mockApolloProvider } = {}) => {
    wrapper = shallowMountExtended(PipelineVulnerabilityReport, {
      apolloProvider: mockApolloProvider || createMockApollo(),
      stubs: {
        GlAlert,
        GlSprintf,
      },
      provide: {
        pipeline: TEST_PIPELINE,
        projectFullPath: TEST_PROJECT_FULL_PATH,
        glFeatures: {
          vulnerabilityPartialScans,
        },
      },
    });
  };

  const findModal = () => wrapper.findComponent(FindingModal);
  const findReport = () => wrapper.findComponent(VulnerabilityReport);

  it('passes the expected props to the vulnerability report component', () => {
    createWrapper();

    expect(findReport().props()).toMatchObject({
      fields: [
        FIELDS.STATUS,
        FIELDS.SEVERITY,
        FIELDS.DESCRIPTION,
        FIELDS.IDENTIFIER,
        FIELDS.REPORT_TYPE,
        FIELDS.ACTIVITY,
      ],
      filterDropdowns: [FILTERS.PIPELINE_STATUS, FILTERS.SEVERITY, FILTERS.TOOL_PIPELINE],
      filterFn: wrapper.vm.transformFilters,
    });
  });

  describe('filters', () => {
    it.each`
      property        | value                                         | expected
      ${'severity'}   | ${['HIGH', 'LOW']}                            | ${['high', 'low']}
      ${'severity'}   | ${[]}                                         | ${undefined}
      ${'severity'}   | ${undefined}                                  | ${undefined}
      ${'reportType'} | ${['CONTAINER_SCANNING', 'SECRET_DETECTION']} | ${['container_scanning', 'secret_detection']}
      ${'reportType'} | ${[]}                                         | ${undefined}
      ${'reportType'} | ${undefined}                                  | ${undefined}
      ${'state'}      | ${['DETECTED', 'CONFIRMED']}                  | ${['DETECTED', 'CONFIRMED']}
      ${'state'}      | ${[]}                                         | ${[]}
      ${'state'}      | ${undefined}                                  | ${undefined}
    `(
      'formats the filters correctly for the pipeline GraphQL endpoint when $property is $value',
      ({ property, value, expected }) => {
        createWrapper();
        const filters = wrapper.vm.transformFilters({ [property]: value });

        expect(filters).toEqual({ [property]: expected });
        expect(findReport().props('filterFn')).toBe(wrapper.vm.transformFilters);
      },
    );
  });

  describe('finding modal', () => {
    const finding = { id: '1' };

    beforeEach(() => {
      createWrapper();
    });

    const clickVulnerability = async () => {
      findReport().vm.$emit('vulnerability-clicked', finding);
      await nextTick();
    };
    const hideModal = async () => {
      findModal().vm.$emit('hidden');
      await nextTick();
    };

    it('hides the modal initially', () => {
      expect(findModal().exists()).toBe(false);
    });

    it('shows the modal when a vulnerability is clicked and passes the correct props', async () => {
      await clickVulnerability();

      expect(findModal().props()).toMatchObject({
        findingUuid: finding.id,
        pipelineIid: TEST_PIPELINE.iid,
        branchRef: TEST_PIPELINE.sourceBranch,
        projectFullPath: TEST_PROJECT_FULL_PATH,
      });

      await hideModal();

      expect(findModal().exists()).toBe(false);
    });

    it(`hides the modal when 'hidden' is emitted`, async () => {
      await clickVulnerability();

      await hideModal();

      expect(findModal().exists()).toBe(false);
    });

    it('navigates to the result URL when resolveWithAiSuccess is emitted', async () => {
      const testUrl = 'https://example.com/merge_request/123';

      await clickVulnerability();
      findModal().vm.$emit('resolveWithAiSuccess', testUrl);

      expect(visitUrl).toHaveBeenCalledWith(testUrl);
    });
  });

  describe('with partial scans', () => {
    const enabledScansQueryResult = (overrides = { full: {}, partial: {} }) => ({
      data: {
        project: {
          id: 2,
          pipeline: {
            id: 11,
            enabledSecurityScans: {
              ready: true,
              sast: true,
              dast: false,
              dependencyScanning: false,
              containerScanning: false,
              coverageFuzzing: false,
              apiFuzzing: false,
              secretDetection: false,
              clusterImageScanning: false,
              __typename: 'EnabledSecurityScans',
              ...overrides?.full,
            },
            enabledPartialSecurityScans: {
              ready: true,
              sast: false,
              dast: false,
              dependencyScanning: false,
              containerScanning: false,
              coverageFuzzing: false,
              apiFuzzing: false,
              secretDetection: false,
              clusterImageScanning: false,
              __typename: 'EnabledSecurityScans',
              ...overrides?.partial,
            },
          },
        },
      },
    });

    it('should create an alert when enabled scans query fails', async () => {
      createWrapper({
        vulnerabilityPartialScans: true,
        mockApolloProvider: createMockApollo([
          [enabledScansQuery, jest.fn().mockRejectedValue({})],
        ]),
      });

      await waitForPromises();

      expect(createAlert).toHaveBeenCalledWith({
        message: 'Error while fetching enabled scans. Please try again later.',
      });
    });

    it.each`
      enabledPartialScans | hasBanner | text
      ${{ sast: true }}   | ${true}   | ${'display'}
      ${{}}               | ${false}  | ${'not display'}
    `(
      'should $text the banner when partial scans are enabled=$hasBanner',
      async ({ enabledPartialScans, hasBanner }) => {
        createWrapper({
          vulnerabilityPartialScans: true,
          mockApolloProvider: createMockApollo([
            [
              enabledScansQuery,
              jest
                .fn()
                .mockResolvedValue(enabledScansQueryResult({ partial: enabledPartialScans })),
            ],
          ]),
        });

        await waitForPromises();

        expect(
          wrapper.findByText(/Diff-based SAST scanning is turned on for this project./).exists(),
        ).toBe(hasBanner);
      },
    );
  });
});
