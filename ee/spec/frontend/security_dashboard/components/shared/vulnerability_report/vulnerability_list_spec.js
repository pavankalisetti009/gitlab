import { GlSkeletonLoader, GlTable, GlTruncate, GlFormCheckbox, GlLink } from '@gitlab/ui';
import { Portal } from 'portal-vue';
import { nextTick } from 'vue';
import { createMockDirective, getBinding } from 'helpers/vue_mock_directive';
import DashboardHasNoVulnerabilities from 'ee/security_dashboard/components/shared/empty_states/dashboard_has_no_vulnerabilities.vue';
import FiltersProducedNoResults from 'ee/security_dashboard/components/shared/empty_states/filters_produced_no_results.vue';
import IssuesBadge from 'ee/security_dashboard/components/shared/issues_badge.vue';
import SelectionSummary from 'ee/security_dashboard/components/shared/vulnerability_report/selection_summary.vue';
import VulnerabilityCommentIcon from 'ee/security_dashboard/components/shared/vulnerability_comment_icon.vue';
import VulnerabilityList from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list.vue';
import VulnerabilityListStatus from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list_status.vue';
import MergeRequestBadge from 'ee/security_dashboard/components/shared/merge_request_badge.vue';
import PolicyViolationBadge from 'ee/security_dashboard/components/shared/policy_violation_badge.vue';
import SolutionBadge from 'ee/security_dashboard/components/shared/solution_badge.vue';
import AiFixedBadge from 'ee/security_dashboard/components/shared/ai_fixed_badge.vue';
import AiResolutionBadge from 'ee/security_dashboard/components/shared/ai_resolution_badge.vue';
import AiFixInProgressBadge from 'ee/security_dashboard/components/shared/ai_fix_in_progress_badge.vue';
import AiPossibleFpBadge from 'ee/security_dashboard/components/shared/ai_possible_fp_badge.vue';
import { DASHBOARD_TYPE_PROJECT } from 'ee/security_dashboard/constants';
import FalsePositiveBadge from 'ee/vulnerabilities/components/false_positive_badge.vue';
import ArchivalBadge from 'ee/vulnerabilities/components/archival_badge.vue';
import ResolutionBadge from 'ee/vulnerabilities/components/resolution_badge.vue';
import { trimText } from 'helpers/text_helper';
import { mountExtended } from 'helpers/vue_test_utils_helper';
import {
  FIELD_PRESETS,
  FIELDS,
} from 'ee/security_dashboard/components/shared/vulnerability_report/constants';
import { stubComponent } from 'helpers/stub_component';
import {
  clusterImageScanningVulnerability,
  containerScanningForRegistryVulnerability,
  generateVulnerabilities,
  vulnerabilities,
  findings,
} from '../../mock_data';

const portalName = 'portal-name';

describe('Vulnerability list component', () => {
  let wrapper;

  const createWrapper = ({
    props = {},
    listeners,
    provide = {},
    stubs,
    directives = { GlTooltip: createMockDirective('gl-tooltip') },
  } = {}) => {
    wrapper = mountExtended(VulnerabilityList, {
      directives,
      propsData: {
        vulnerabilities: [],
        fields: FIELD_PRESETS.DEVELOPMENT,
        portalName,
        pageSize: 20,
        ...props,
      },
      stubs: {
        Portal: {
          name: 'Portal',
          props: {
            to: String,
          },
          render() {
            return this.$scopedSlots.default();
          },
        },
        ...stubs,
      },
      listeners,
      provide: () => ({
        dashboardType: DASHBOARD_TYPE_PROJECT,
        noVulnerabilitiesSvgPath: '#',
        emptyStateSvgPath: '#',
        hasVulnerabilities: true,
        hasJiraVulnerabilitiesIntegrationEnabled: false,
        canAdminVulnerability: true,
        validityChecksEnabled: false,
        glFeatures: {
          validityChecksSecurityFindingStatus: true,
          aiExperimentSastFpDetection: false,
        },
        ...provide,
      }),
    });
  };

  const locationText = ({ file, startLine }) => `${file}:${startLine}`;
  const findTable = () => wrapper.findComponent(GlTable);
  const findCell = (label) => wrapper.find(`.js-${label}`);
  const findRows = () => wrapper.findAll('tbody tr');
  const findRow = (index = 0) => findRows().at(index);
  const findSelectionSummary = () => wrapper.findComponent(SelectionSummary);
  const findVulnerabilityListStatus = () => wrapper.findComponent(VulnerabilityListStatus);
  const findRowVulnerabilityCommentIcon = (row) =>
    findRow(row).findComponent(VulnerabilityCommentIcon);
  const findDataCell = (label) => wrapper.findByTestId(label);
  const findDataCells = (label) => wrapper.findAll(`[data-testid="${label}"]`);
  const findClusterCell = (id) => wrapper.findByTestId(`cluster-${id}`);
  const findImageAndTagCell = (id) => wrapper.findByTestId(`image-and-tag-${id}`);
  const findImageAndTagCellPopover = (id) => wrapper.findByTestId(`image-and-tag-${id}-popover`);
  const findLocationCell = (id) => wrapper.findByTestId(`location-${id}`);
  const findTitleCell = (id) => wrapper.findByTestId(`title-${id}`);
  const findAllStatusCells = () => wrapper.findAll(`[data-testid="vulnerability-status-content"]`);
  const findLocationTextWrapper = (cell) => cell.findComponent(GlTruncate);
  const findFiltersProducedNoResults = () => wrapper.findComponent(FiltersProducedNoResults);
  const findDashboardHasNoVulnerabilities = () =>
    wrapper.findComponent(DashboardHasNoVulnerabilities);
  const findVulnerabilityCheckbox = () => wrapper.findAllComponents(GlFormCheckbox).at(1);
  const findCheckAllCheckbox = () => wrapper.findByTestId('vulnerability-checkbox-all');
  const findAllRowCheckboxes = () => wrapper.findAllByTestId('vulnerability-checkbox');
  const findSkeletonLoading = () => wrapper.findAllComponents(GlSkeletonLoader);
  const findSecurityScore = (id) => wrapper.findByTestId(`security-scores-${id}`);
  const findValidityCheck = (id) => wrapper.findByTestId(`validity-check-${id}`);

  describe('with vulnerabilities', () => {
    let newVulnerabilities;

    beforeEach(() => {
      newVulnerabilities = generateVulnerabilities();
      createWrapper({
        props: { vulnerabilities: newVulnerabilities },
      });
    });

    it('should render a list of vulnerabilities', () => {
      expect(findAllStatusCells()).toHaveLength(newVulnerabilities.length);
    });

    it('should pass state and dismissalReason to vulnerability-list-status', () => {
      expect(findVulnerabilityListStatus().props()).toEqual({
        state: newVulnerabilities[0].state,
        dismissalReason: newVulnerabilities[0].dismissalReason,
      });
    });

    it('should correctly render the severity', () => {
      const cell = findCell('severity');
      expect(cell.text().toLowerCase()).toBe(newVulnerabilities[0].severity);
    });

    it('should render the security score', () => {
      const vuln = newVulnerabilities[0];

      expect(findSecurityScore(vuln.id).props()).toMatchObject({
        cvss: vuln.cvss,
        cveEnrichment: vuln.cveEnrichment,
      });
    });

    it('should correctly render the description', () => {
      const cell = findCell('description');
      expect(cell.text()).toBe(newVulnerabilities[0].title);
    });

    it('should correctly render the identifier cell', () => {
      const identifiers = findDataCells('vulnerability-identifier');
      const extraIdentifierCounts = findDataCells('vulnerability-more-identifiers');

      const firstIdentifiers = newVulnerabilities[0].identifiers;
      expect(identifiers.at(0).text()).toBe(firstIdentifiers[0].name);
      expect(trimText(extraIdentifierCounts.at(0).text())).toContain(
        `${firstIdentifiers.length - 1} more`,
      );

      expect(identifiers.at(1).text()).toBe(newVulnerabilities[1].identifiers[0].name);
      expect(extraIdentifierCounts).toHaveLength(1);
    });

    it('should correctly render the report type cell', () => {
      const cells = findDataCells('vulnerability-report-type');
      expect(cells.at(0).text()).toContain('SAST');
      expect(cells.at(0).text()).toContain('Gemnasium');
      expect(cells.at(1).text()).toContain('Dependency Scanning');
      expect(cells.at(1).text()).toContain('GitLeaks');
      expect(cells.at(2).text()).toContain('Custom scanner without translation');
      expect(cells.at(2).text()).toContain('GitLeaks');
    });

    it('should correctly render the scanner name', () => {
      const scannerNames = findDataCells('vulnerability-scanner-name');
      expect(scannerNames.at(0).text()).toBe('Gemnasium');
      expect(scannerNames.at(1).text()).toBe('GitLeaks');
    });

    it('should portal the selection summary to the expected portal', () => {
      expect(wrapper.findComponent(Portal).props('to')).toBe(portalName);
    });

    it('should not show the selection summary if no vulnerabilities are selected', () => {
      expect(findSelectionSummary().props('visible')).toBe(false);
    });

    it('should show the selection summary when a checkbox is selected', async () => {
      await findVulnerabilityCheckbox().vm.$emit('change');

      expect(findSelectionSummary().props('visible')).toBe(true);
    });

    it('passes the selected vulnerabilities to the selection summary', async () => {
      await findRow(0).trigger('click');
      await findRow(1).trigger('click');
      await findRow(2).trigger('click');

      expect(findSelectionSummary().props('selectedVulnerabilities')).toEqual([
        newVulnerabilities[0],
        newVulnerabilities[1],
        newVulnerabilities[2],
      ]);
    });

    it('should sync selected vulnerabilities when the vulnerability list is updated', async () => {
      createWrapper({
        props: { vulnerabilities: newVulnerabilities },
        directives: {},
      });

      await findVulnerabilityCheckbox().vm.$emit('change');
      expect(findSelectionSummary().props('selectedVulnerabilities')).toHaveLength(1);

      wrapper.setProps({ vulnerabilities: [] });

      await nextTick();
      await nextTick();
      expect(findSelectionSummary().props('visible')).toBe(false);
    });

    it('should uncheck a selected vulnerability after the vulnerability is updated', async () => {
      const checkbox = () => findVulnerabilityCheckbox();
      await checkbox().vm.$emit('change');
      expect(checkbox().props('checked')).toBe(true);

      await nextTick();
      findSelectionSummary().vm.$emit('vulnerabilities-updated', [newVulnerabilities[0].id]);
      await nextTick();

      expect(checkbox().props('checked')).toBe(false);
    });
  });

  describe('should correctly render the vendor tooltip', () => {
    beforeEach(() => {
      const vulnerabilitiesWithScanner = generateVulnerabilities();
      vulnerabilitiesWithScanner[0].scanner = { name: 'GitLeaks' };

      createWrapper({
        props: {
          vulnerabilities: vulnerabilitiesWithScanner,
          shouldShowReportType: true,
        },
      });
    });

    it('should correctly render the scanner name tooltip', () => {
      const vendorTooltip = findDataCells('vulnerability-vendor-name-tooltip').at(0);
      const tooltip = getBinding(vendorTooltip.element, 'gl-tooltip');

      expect(vendorTooltip.attributes('title')).toBe('Vendor: Unknown');
      expect(tooltip).toBeDefined();
    });
  });

  describe('when user has no permission to admin vulnerabilities', () => {
    beforeEach(() => {
      createWrapper({
        props: { vulnerabilities },
        provide: { canAdminVulnerability: false },
      });
    });

    it('should not show the checkboxes', () => {
      expect(findDataCell('vulnerability-checkbox-all').exists()).toBe(false);
      expect(findDataCell('vulnerability-checkbox').exists()).toBe(false);
    });

    it('should not select a clicked vulnerability', async () => {
      findRow(1).trigger('click');
      await nextTick();

      expect(findSelectionSummary().props()).toMatchObject({
        visible: false,
        selectedVulnerabilities: [],
      });
    });
  });

  describe('when displayed on instance or group level dashboard', () => {
    let newVulnerabilities;

    beforeEach(() => {
      newVulnerabilities = generateVulnerabilities();
      createWrapper({
        props: { vulnerabilities: newVulnerabilities, shouldShowProjectNamespace: true },
      });
    });

    it('should display the vulnerability locations for images', () => {
      const { id, project, location } = newVulnerabilities[0];
      const cell = findLocationCell(id);
      expect(cell.text()).toContain(project.nameWithNamespace);
      expect(findLocationTextWrapper(cell).props()).toEqual(
        expect.objectContaining({
          text: location.image,
          position: 'middle',
        }),
      );
    });

    it('should display the vulnerability locations for code', () => {
      const { id, project, location } = newVulnerabilities[1];
      const cell = findLocationCell(id);
      expect(cell.text()).toContain(project.nameWithNamespace);
      expect(findLocationTextWrapper(cell).props()).toEqual(
        expect.objectContaining({
          text: locationText(location),
          position: 'middle',
        }),
      );
    });

    it('should display the vulnerability locations for code with no line data', () => {
      const { id, project, location } = newVulnerabilities[2];
      const cell = findLocationCell(id);
      expect(cell.text()).toContain(project.nameWithNamespace);
      expect(findLocationTextWrapper(cell).props()).toEqual(
        expect.objectContaining({
          text: location.file,
          position: 'middle',
        }),
      );
    });

    it('should not display the vulnerability locations for vulnerabilities without a location', () => {
      const { id, project } = newVulnerabilities[4];
      const cellText = findLocationCell(id).text();
      expect(cellText).toEqual(project.nameWithNamespace);
      expect(cellText).not.toContain(':');
    });

    it('should display the vulnerability locations for path', () => {
      const { id, project, location } = newVulnerabilities[5];
      const cell = findLocationCell(id);
      expect(cell.text()).toContain(project.nameWithNamespace);
      expect(findLocationTextWrapper(cell).props()).toEqual(
        expect.objectContaining({
          text: location.path,
          position: 'middle',
        }),
      );
    });
  });

  describe('when displayed on a project level dashboard', () => {
    let newVulnerabilities;
    beforeEach(() => {
      newVulnerabilities = generateVulnerabilities();
      createWrapper({
        props: {
          vulnerabilities: newVulnerabilities,
          shouldShowIdentifier: true,
          shouldShowReportType: true,
        },
      });
    });

    it('should not display the vulnerability group/project locations for images', () => {
      const { id, project, location } = newVulnerabilities[0];
      const cell = findLocationCell(id);
      expect(cell.text()).not.toContain(project.nameWithNamespace);
      expect(findLocationTextWrapper(cell).props()).toEqual(
        expect.objectContaining({
          text: location.image,
          position: 'middle',
        }),
      );
    });

    it('should display the detected time', () => {
      const { id } = newVulnerabilities[1];
      const cell = findDataCell(`detected-${id}`);
      expect(cell.text()).toEqual(`2020-07-22`);
      expect(cell.attributes('title')).toEqual('Jul 22, 2020 7:31pm UTC');
    });

    it('should display the vulnerability locations for code', () => {
      const { id, project, location } = newVulnerabilities[1];
      const cell = findLocationCell(id);
      expect(cell.text()).not.toContain(project.nameWithNamespace);
      expect(findLocationTextWrapper(cell).props()).toEqual(
        expect.objectContaining({
          text: locationText(location),
          position: 'middle',
        }),
      );
    });

    it('should make the file path linkable', () => {
      const { id, location } = newVulnerabilities[1];
      const cell = findLocationCell(id);
      expect(cell.find('a').attributes('href')).toBe(`${location.blobPath}#L${location.startLine}`);
    });

    it('should not make the file path linkable if blobPath is missing', () => {
      const { id } = newVulnerabilities[0];
      const cell = findLocationCell(id);
      expect(cell.find('a').exists()).toBe(false);
    });

    it('should not display the vulnerability group/project locations for code with no line data', () => {
      const { id, project, location } = newVulnerabilities[2];
      const cell = findLocationCell(id);
      expect(cell.text()).not.toContain(project.nameWithNamespace);
      expect(findLocationTextWrapper(cell).props()).toEqual(
        expect.objectContaining({
          text: location.file,
          position: 'middle',
        }),
      );
    });
  });

  describe('when has an issue associated', () => {
    let newVulnerabilities;

    beforeEach(() => {
      newVulnerabilities = generateVulnerabilities();
      newVulnerabilities[0].issueLinks = {
        nodes: [
          {
            issue: {
              title: 'my-title',
              iid: 114,
              state: 'opened',
              webUrl: 'http://localhost/issues/~/114',
            },
          },
        ],
      };
      createWrapper({ props: { vulnerabilities: newVulnerabilities } });
    });

    it('should emit "vulnerability-clicked" with the vulnerability as a payload when a vulnerability-link is clicked', async () => {
      const clickedEventName = 'vulnerability-clicked';
      const vulnerability = newVulnerabilities[1];
      const link = findTitleCell(vulnerability.id).find('a');

      expect(wrapper.emitted(clickedEventName)).toBe(undefined);

      await link.trigger('click');
      const emittedEvents = wrapper.emitted(clickedEventName);

      expect(emittedEvents).toHaveLength(1);
      expect(emittedEvents[0][0]).toBe(vulnerability);
    });
  });

  describe('when has comments', () => {
    let newVulnerabilities;

    beforeEach(() => {
      newVulnerabilities = generateVulnerabilities();
      newVulnerabilities[0].userNotesCount = 1;
      createWrapper({ props: { vulnerabilities: newVulnerabilities } });
    });

    it('should render the comments badge on the first vulnerability', () => {
      expect(findRowVulnerabilityCommentIcon(0).exists()).toBe(true);
    });

    it('should not render the comments badge on the second vulnerability', () => {
      expect(findRowVulnerabilityCommentIcon(1).exists()).toBe(false);
    });
  });

  describe('should correctly render the scanner name', () => {
    it('should always render the scanner name regardless of vendor', () => {
      const newVulnerabilities = generateVulnerabilities();
      newVulnerabilities[0].scanner = { vendor: 'GitLab', name: 'GitLab Scanner' };
      newVulnerabilities[1].scanner = { vendor: 'Third Party', name: 'Third Party Scanner' };
      newVulnerabilities[2].scanner = { vendor: '', name: 'No Vendor Scanner' };

      createWrapper({
        props: {
          vulnerabilities: newVulnerabilities,
          shouldShowReportType: true,
        },
      });

      const scannerNames = findDataCells('vulnerability-scanner-name');
      expect(scannerNames.at(0).text()).toBe('GitLab Scanner');
      expect(scannerNames.at(1).text()).toBe('Third Party Scanner');
      expect(scannerNames.at(2).text()).toBe('No Vendor Scanner');
    });
  });

  describe('loading prop', () => {
    it.each`
      phrase        | isLoading
      ${'show'}     | ${true}
      ${'not show'} | ${false}
    `('should $phrase the loading state', ({ isLoading }) => {
      createWrapper({ props: { isLoading, vulnerabilities } });

      expect(findVulnerabilityListStatus().exists()).toEqual(!isLoading);
      expect(findSkeletonLoading().exists()).toBe(isLoading);
    });
  });

  describe('with no vulnerabilities', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('should show the empty state', () => {
      expect(findVulnerabilityListStatus().exists()).toBe(false);
      expect(findFiltersProducedNoResults().exists()).toBe(true);
      expect(findDashboardHasNoVulnerabilities().exists()).toBe(false);
    });
  });

  describe('sorting', () => {
    it('passes the sort prop to the table', () => {
      const sort = { sortBy: 'a', sortDesc: true };
      createWrapper({ props: { sort, vulnerabilities } });

      expect(findTable().props()).toMatchObject(sort);
    });

    it('emits sort data in expected format', () => {
      createWrapper({ props: { vulnerabilities } });

      const sort = { sortBy: 'state', sortDesc: true };
      findTable().vm.$emit('sort-changed', sort);

      expect(wrapper.emitted('update:sort')[0][0]).toEqual(sort);
    });
  });

  describe('row click', () => {
    const findRowCheckbox = (index) => findRow(index).findComponent(GlFormCheckbox);

    beforeEach(() => {
      createWrapper({ props: { vulnerabilities } });
    });

    it('will select and deselect vulnerabilities', async () => {
      const rowCount = vulnerabilities.length;
      const rowsToClick = [0, 1, 2];
      const clickRows = () => rowsToClick.forEach((row) => findRow(row).trigger('click'));
      const expectRowCheckboxesToBe = (condition) => {
        for (let i = 0; i < rowCount; i += 1)
          expect(findRowCheckbox(i).props('checked')).toBe(condition(i));
      };

      clickRows();
      await nextTick();
      expectRowCheckboxesToBe((i) => rowsToClick.includes(i));

      clickRows();
      await nextTick();
      expectRowCheckboxesToBe(() => false);
    });
  });

  describe('select all checkbox', () => {
    it('will toggle between selecting all and deselecting all vulnerabilities', async () => {
      const getChecked = () => findAllRowCheckboxes().filter((x) => x.element.checked === true);

      createWrapper({ props: { vulnerabilities } });
      // Sanity check to ensure that everything starts off unchecked.
      expect(getChecked()).toHaveLength(0);

      await findCheckAllCheckbox().setChecked(true);
      // First click should select all rows.
      expect(getChecked()).toHaveLength(vulnerabilities.length);

      await findCheckAllCheckbox().setChecked(false);
      // Second click should un-select all rows.
      expect(getChecked()).toHaveLength(0);
    });

    it('will toggle the indeterminate state when some but not all vulnerabilities are selected', async () => {
      const expectIndeterminateState = (state) =>
        expect(findCheckAllCheckbox().props('indeterminate')).toBe(state);

      createWrapper({
        props: { vulnerabilities },
        stubs: { GlFormCheckbox: stubComponent(GlFormCheckbox, { props: ['indeterminate'] }) },
      });

      // We start off with no items selected, so no indeterminate state.
      expectIndeterminateState(false);

      await findRow(1).trigger('click');
      // When we go from 0 to 1 item selected, indeterminate state should be true.
      expectIndeterminateState(true);

      await findRow(1).trigger('click');
      // When we go from 1 to 0 items selected, indeterminate state should be false.
      expectIndeterminateState(false);

      // Check all items.
      findCheckAllCheckbox().trigger('click');
      // When all the items are selected, indeterminate state should be false.
      expectIndeterminateState(false);

      await findRow(1).trigger('click');
      // When we uncheck an item when all items are selected, indeterminate state should be true.
      expectIndeterminateState(true);
    });
  });

  describe('fields prop', () => {
    it('shows the expected columns in the table', () => {
      const { STATUS, SEVERITY } = FIELDS;
      const fields = [STATUS, SEVERITY];
      createWrapper({
        props: { fields, vulnerabilities },
        provide: { canAdminVulnerability: false },
      });

      // Check that there are only 2 columns.
      expect(findRow().element.cells).toHaveLength(2);
      expect(findVulnerabilityListStatus().exists()).toBe(true);
      expect(findCell('severity').exists()).toBe(true);
    });
  });

  describe('pageSize prop', () => {
    it('shows the same number of skeleton loaders as the pageSize prop', () => {
      const pageSize = 17;
      createWrapper({ props: { pageSize, isLoading: true } });

      expect(findSkeletonLoading()).toHaveLength(pageSize);
    });
  });

  describe('operational vulnerabilities', () => {
    beforeEach(() => {
      createWrapper({
        props: {
          fields: FIELD_PRESETS.OPERATIONAL,
          vulnerabilities: [clusterImageScanningVulnerability],
        },
      });
    });

    it('shows the cluster column', () => {
      expect(findClusterCell(clusterImageScanningVulnerability.id).exists()).toBe(true);
    });
  });

  describe('container registry vulnerabilities', () => {
    it('shows the image and tag column', () => {
      createWrapper({
        props: {
          fields: FIELD_PRESETS.CONTAINER_REGISTRY,
          vulnerabilities: [containerScanningForRegistryVulnerability],
        },
      });

      expect(findImageAndTagCell(containerScanningForRegistryVulnerability.id).exists()).toBe(true);
      expect(findImageAndTagCell(containerScanningForRegistryVulnerability.id).props('text')).toBe(
        containerScanningForRegistryVulnerability.location.image,
      );
    });

    it('shows the image and tag popover link', () => {
      createWrapper({
        props: {
          fields: FIELD_PRESETS.CONTAINER_REGISTRY,
          vulnerabilities: [containerScanningForRegistryVulnerability],
        },
      });

      findImageAndTagCell(containerScanningForRegistryVulnerability.id).trigger('hover');

      expect(
        findImageAndTagCellPopover(containerScanningForRegistryVulnerability.id).exists(),
      ).toBe(true);
      expect(findImageAndTagCellPopover(containerScanningForRegistryVulnerability.id).text()).toBe(
        `Image: ${containerScanningForRegistryVulnerability.location.image}`,
      );
      expect(
        findImageAndTagCellPopover(containerScanningForRegistryVulnerability.id)
          .findComponent(GlLink)
          .attributes('href'),
      ).toBe(containerScanningForRegistryVulnerability.location.containerRepositoryUrl);
    });

    it('shows the empty image and tag column', () => {
      createWrapper({
        props: {
          fields: FIELD_PRESETS.CONTAINER_REGISTRY,
          vulnerabilities: [{ ...containerScanningForRegistryVulnerability, location: {} }],
        },
      });

      expect(findImageAndTagCell(containerScanningForRegistryVulnerability.id).exists()).toBe(
        false,
      );
    });
  });

  describe('badges', () => {
    const findComponentBadgeInRow = (component) => {
      return (index = 0) => findRow(index).findComponent(component);
    };
    let newVulnerabilities;

    describe('archival badge', () => {
      const findArchivalBadgeInRow = findComponentBadgeInRow(ArchivalBadge);

      beforeEach(() => {
        newVulnerabilities = generateVulnerabilities();
        newVulnerabilities[0].archivalInformation = {
          aboutToBeArchived: true,
          expectedToBeArchivedOn: '2026-03-01',
        };
        createWrapper({ props: { vulnerabilities: newVulnerabilities } });
      });

      it('should render when the vulnerability is about to expire', () => {
        expect(findArchivalBadgeInRow(0).exists()).toBe(true);
      });

      it('should not render when the vulnerability is not about to expire', () => {
        expect(findArchivalBadgeInRow(1).exists()).toBe(false);
      });
    });

    describe('resolution badge', () => {
      const findResolutionBadgeInRow = findComponentBadgeInRow(ResolutionBadge);

      beforeEach(() => {
        newVulnerabilities = generateVulnerabilities();
        newVulnerabilities[0].resolvedOnDefaultBranch = true;
        createWrapper({ props: { vulnerabilities: newVulnerabilities } });
      });

      it('should render when the vulnerability has resolved on the default branch', () => {
        expect(findResolutionBadgeInRow(0).exists()).toBe(true);
      });

      it('should not render when the vulnerability has not resolved on the default branch', () => {
        expect(findResolutionBadgeInRow(1).exists()).toBe(false);
      });
    });

    describe('issue badge', () => {
      const findIssuesBadgeInRow = findComponentBadgeInRow(IssuesBadge);

      beforeEach(() => {
        createWrapper({
          props: { vulnerabilities: generateVulnerabilities() },
        });
      });

      it('should render when the vulnerability has an issue', () => {
        expect(findIssuesBadgeInRow(0).exists()).toBe(true);
      });

      it('should not render when the vulnerability does not have an issue', () => {
        expect(findIssuesBadgeInRow(1).exists()).toBe(false);
      });

      describe.each`
        dashboardType | hasJiraVulnerabilitiesIntegrationEnabled | issues
        ${'project'}  | ${false}                                 | ${vulnerabilities[0].issueLinks.nodes}
        ${'project'}  | ${true}                                  | ${vulnerabilities[0].externalIssueLinks.nodes}
        ${'pipeline'} | ${false}                                 | ${findings[0].issueLinks.nodes}
        ${'pipeline'} | ${true}                                  | ${findings[0].vulnerability.externalIssueLinks.nodes}
      `(
        'when "dashboardType" is "$dashboardType" and "hasJiraVulnerabilitiesIntegrationEnabled" is "$hasJiraVulnerabilitiesIntegrationEnabled"',
        ({ dashboardType, hasJiraVulnerabilitiesIntegrationEnabled, issues }) => {
          beforeEach(() => {
            const mockVulnerabilities = dashboardType === 'project' ? vulnerabilities : findings;
            createWrapper({
              props: { vulnerabilities: mockVulnerabilities },
              stubs: {
                SelectionSummary: true,
              },
              provide: { hasJiraVulnerabilitiesIntegrationEnabled, dashboardType },
            });
          });

          it(`should render the badge as ${
            hasJiraVulnerabilitiesIntegrationEnabled ? 'Jira' : 'Gitlab'
          } issues`, () => {
            expect(findIssuesBadgeInRow(0).props('isJira')).toBe(
              hasJiraVulnerabilitiesIntegrationEnabled,
            );
            expect(findIssuesBadgeInRow(0).props('issues')).toMatchObject(issues);
          });
        },
      );
    });

    describe('merge request badge', () => {
      const findMergeRequestBadgeInRow = findComponentBadgeInRow(MergeRequestBadge);

      beforeEach(() => {
        newVulnerabilities = generateVulnerabilities();
        createWrapper({ props: { vulnerabilities: newVulnerabilities } });
      });

      it('should render when the vulnerability has a merge request', () => {
        expect(findMergeRequestBadgeInRow(0).exists()).toBe(true);
      });

      it('should not render when the vulnerability does not have a merge request', () => {
        expect(findMergeRequestBadgeInRow(1).exists()).toBe(false);
      });
    });

    describe('false positive badge', () => {
      const findFalsePositiveBadgeInRow = findComponentBadgeInRow(FalsePositiveBadge);

      beforeEach(() => {
        newVulnerabilities = generateVulnerabilities();
        newVulnerabilities[0].falsePositive = true;
        createWrapper({
          props: { vulnerabilities: newVulnerabilities },
          provide: {
            canViewFalsePositive: true,
          },
        });
      });

      it('should render when the vulnerability has a false positive', () => {
        expect(findFalsePositiveBadgeInRow(0).exists()).toBe(true);
      });

      it('should not render when the vulnerability does not have a false positive', () => {
        expect(findFalsePositiveBadgeInRow(1).exists()).toBe(false);
      });

      describe('AI possible false positive badge', () => {
        const findAiPossibleFpBadgeInRow = findComponentBadgeInRow(AiPossibleFpBadge);

        describe('when aiExperimentSastFpDetection feature flag is enabled', () => {
          beforeEach(() => {
            newVulnerabilities = generateVulnerabilities();
            newVulnerabilities[0].latestFlag = {
              confidenceScore: 0.5,
              description: 'This appears to be a false positive because...',
            };
            createWrapper({
              props: { vulnerabilities: newVulnerabilities },
              provide: {
                glFeatures: { aiExperimentSastFpDetection: true },
                canAdminVulnerability: true,
              },
            });
          });

          it('should render AI possible FP badge when vulnerability has latestFlag', () => {
            expect(findAiPossibleFpBadgeInRow(0).exists()).toBe(true);
          });

          it('should not render standard false positive badge when AI FP badge is shown', () => {
            expect(findFalsePositiveBadgeInRow(0).exists()).toBe(false);
          });

          it('should not render AI possible FP badge for vulnerabilities without latestFlag', () => {
            expect(findAiPossibleFpBadgeInRow(1).exists()).toBe(false);
          });
        });

        describe('when aiExperimentSastFpDetection feature flag is disabled', () => {
          beforeEach(() => {
            newVulnerabilities = generateVulnerabilities();
            newVulnerabilities[0].latestFlag = {
              confidenceScore: 0.7,
              description: 'This appears to be a false positive because...',
            };
            newVulnerabilities[0].falsePositive = true;
            createWrapper({
              props: { vulnerabilities: newVulnerabilities },
              provide: {
                glFeatures: { aiExperimentSastFpDetection: false },
                canAdminVulnerability: true,
              },
            });
          });

          it('should not render AI possible FP badge even when vulnerability has latestFlag', () => {
            expect(findAiPossibleFpBadgeInRow(0).exists()).toBe(false);
          });

          it('should render standard false positive badge when feature flag is disabled', () => {
            expect(findFalsePositiveBadgeInRow(0).exists()).toBe(true);
          });
        });
      });
    });

    describe('solution badge', () => {
      const findSolutionBadgeInRow = findComponentBadgeInRow(SolutionBadge);

      beforeEach(() => {
        newVulnerabilities = generateVulnerabilities();
        newVulnerabilities[0].hasRemediations = true;
        newVulnerabilities[1].hasRemediations = false;
        createWrapper({ props: { vulnerabilities: newVulnerabilities } });
      });

      it('should display the solution badge', () => {
        expect(findSolutionBadgeInRow(0).exists()).toBe(true);
      });

      it('should not display the solution badge', () => {
        expect(findSolutionBadgeInRow(1).exists()).toBe(false);
      });
    });

    describe('AI vulnerability resolution badge', () => {
      const findAiResolutionBadgeInRow = findComponentBadgeInRow(AiResolutionBadge);
      const createWrapperWithVulnerabilities = ({
        resolveVulnerabilityWithAi,
        aiResolutionAvailable,
        aiResolutionEnabled,
        agenticSastVrUi = false,
      }) => {
        newVulnerabilities = generateVulnerabilities();

        newVulnerabilities[0].aiResolutionAvailable = aiResolutionAvailable;
        newVulnerabilities[0].aiResolutionEnabled = aiResolutionEnabled;

        createWrapper({
          props: { vulnerabilities: newVulnerabilities },
          provide: {
            glFeatures: { agenticSastVrUi },
            glAbilities: { resolveVulnerabilityWithAi },
          },
        });
      };

      it.each`
        resolveVulnerabilityWithAi | aiResolutionAvailable | aiResolutionEnabled | shouldDisplayBadge
        ${true}                    | ${true}               | ${true}             | ${true}
        ${true}                    | ${true}               | ${false}            | ${false}
        ${true}                    | ${false}              | ${true}             | ${false}
        ${true}                    | ${false}              | ${false}            | ${false}
        ${false}                   | ${true}               | ${true}             | ${false}
        ${false}                   | ${true}               | ${false}            | ${false}
        ${false}                   | ${false}              | ${true}             | ${false}
        ${false}                   | ${false}              | ${false}            | ${false}
      `(
        'displays the badge "$shouldDisplayBadge" if resolveVulnerabilityWithAi=$resolveVulnerabilityWithAi, aiResolutionAvailable=$aiResolutionAvailable, aiResolutionEnabled=$aiResolutionEnabled (works same when agentic_sast_vr_ui feature flag is disabled)',
        ({
          resolveVulnerabilityWithAi,
          aiResolutionAvailable,
          aiResolutionEnabled,
          shouldDisplayBadge,
        }) => {
          createWrapperWithVulnerabilities({
            resolveVulnerabilityWithAi,
            aiResolutionAvailable,
            aiResolutionEnabled,
          });
          expect(findAiResolutionBadgeInRow(0).exists()).toBe(shouldDisplayBadge);
        },
      );

      describe('when agentic_sast_vr_ui feature flag is enabled', () => {
        it('should not display AI vulnerability resolution badge', () => {
          newVulnerabilities = generateVulnerabilities();

          newVulnerabilities[0].aiResolutionAvailable = true;
          newVulnerabilities[0].aiResolutionEnabled = true;

          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: {
              glFeatures: { agenticSastVrUi: true },
            },
          });

          expect(findAiResolutionBadgeInRow(0).exists()).toBe(false);
        });
      });
    });

    describe('AI fix in progress badge', () => {
      const findAiFixInProgressBadgeInRow = findComponentBadgeInRow(AiFixInProgressBadge);

      describe('when agentic_sast_vr_ui feature flag is enabled', () => {
        it('displays AI fix in progress badge when AI fix is in progress', () => {
          newVulnerabilities = generateVulnerabilities();
          newVulnerabilities[0].aiWorkflows = {
            nodes: [
              {
                workflowName: 'RESOLVE_SAST_VULNERABILITY',
                workflow: {
                  id: 'workflow-1',
                  humanStatus: 'Running',
                  status: 'RUNNING',
                  createdAt: '2024-01-15T10:30:00Z',
                },
              },
            ],
          };

          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: {
              glFeatures: { agenticSastVrUi: true },
            },
          });

          expect(findAiFixInProgressBadgeInRow(0).exists()).toBe(true);
        });

        it('displays AI fix in progress badge when AI workflow status is CREATED', () => {
          newVulnerabilities = generateVulnerabilities();
          newVulnerabilities[0].aiWorkflows = {
            nodes: [
              {
                workflowName: 'RESOLVE_SAST_VULNERABILITY',
                workflow: {
                  id: 'workflow-1',
                  humanStatus: 'Created',
                  status: 'CREATED',
                  createdAt: '2024-01-15T10:30:00Z',
                },
              },
            ],
          };

          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: {
              glFeatures: { agenticSastVrUi: true },
            },
          });

          expect(findAiFixInProgressBadgeInRow(0).exists()).toBe(true);
        });

        it('does not display AI fix in progress badge when AI fix is not in progress', () => {
          newVulnerabilities = generateVulnerabilities();
          newVulnerabilities[0].aiWorkflows = { nodes: [] };

          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: {
              glFeatures: { agenticSastVrUi: true },
            },
          });

          expect(findAiFixInProgressBadgeInRow(0).exists()).toBe(false);
        });

        it('does not display AI fix in progress badge when workflow is completed', () => {
          newVulnerabilities = generateVulnerabilities();
          newVulnerabilities[0].aiWorkflows = {
            nodes: [
              {
                workflowName: 'RESOLVE_SAST_VULNERABILITY',
                workflow: {
                  id: 'workflow-1',
                  humanStatus: 'Completed',
                  status: 'COMPLETED',
                  createdAt: '2024-01-15T10:30:00Z',
                },
              },
            ],
          };

          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: {
              glFeatures: { agenticSastVrUi: true },
            },
          });

          expect(findAiFixInProgressBadgeInRow(0).exists()).toBe(false);
        });
      });

      describe('when agentic_sast_vr_ui feature flag is disabled', () => {
        it('does not display AI fix in progress badge even when AI fix is in progress', () => {
          newVulnerabilities = generateVulnerabilities();
          newVulnerabilities[0].aiWorkflows = {
            nodes: [
              {
                workflowName: 'RESOLVE_SAST_VULNERABILITY',
                workflow: {
                  id: 'workflow-1',
                  humanStatus: 'Running',
                  status: 'RUNNING',
                  createdAt: '2024-01-15T10:30:00Z',
                },
              },
            ],
          };

          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: {
              glFeatures: { agenticSastVrUi: false },
            },
          });

          expect(findAiFixInProgressBadgeInRow(0).exists()).toBe(false);
        });
      });
    });

    describe('AI fixed badge', () => {
      const findAiFixedBadgeInRow = findComponentBadgeInRow(AiFixedBadge);

      describe('when agentic_sast_vr_ui feature flag is enabled', () => {
        it.each`
          mergeRequest                                                    | shouldDisplayBadge | description
          ${null}                                                         | ${false}           | ${'no merge request'}
          ${{ id: 'mr-1', webUrl: 'test.com', author: { human: true } }}  | ${false}           | ${'merge request with human author'}
          ${{ id: 'mr-1', webUrl: 'test.com', author: { human: false } }} | ${true}            | ${'merge request with AI author'}
          ${{ id: 'mr-1', webUrl: 'test.com', author: null }}             | ${false}           | ${'merge request with no author'}
          ${{ id: 'mr-1', webUrl: 'test.com' }}                           | ${false}           | ${'merge request with undefined author'}
        `(
          'displays AI fixed badge "$shouldDisplayBadge" when vulnerability has $description',
          ({ mergeRequest, shouldDisplayBadge }) => {
            newVulnerabilities = generateVulnerabilities();
            newVulnerabilities[0].mergeRequest = mergeRequest;

            createWrapper({
              props: { vulnerabilities: newVulnerabilities },
              provide: {
                glFeatures: { agenticSastVrUi: true },
              },
            });

            expect(findAiFixedBadgeInRow(0).exists()).toBe(shouldDisplayBadge);
          },
        );
      });

      describe('when agentic_sast_vr_ui feature flag is disabled', () => {
        it('does not display AI fixed badge even when merge request has AI author', () => {
          newVulnerabilities = generateVulnerabilities();
          newVulnerabilities[0].mergeRequest = {
            id: 'mr-1',
            webUrl: 'test.com',
            author: { human: false },
          };

          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: {
              glFeatures: { agenticSastVrUi: false },
            },
          });

          expect(findAiFixedBadgeInRow(0).exists()).toBe(false);
        });
      });
    });

    describe('policy violation badge', () => {
      const findPolicyViolationBadgeInRow = findComponentBadgeInRow(PolicyViolationBadge);

      beforeEach(() => {
        newVulnerabilities = generateVulnerabilities();
        newVulnerabilities[0].policyViolations = 1;
        newVulnerabilities[1].policyViolations = 0;
      });

      describe('with the securityPolicyApprovalWarnMode feature flag on', () => {
        beforeEach(() => {
          createWrapper({
            props: { vulnerabilities: newVulnerabilities },
            provide: { glFeatures: { securityPolicyApprovalWarnMode: true } },
          });
        });

        it('displays the policy violation badge for a vulnerability with the "policyViolations" property', () => {
          expect(findPolicyViolationBadgeInRow(0).exists()).toBe(true);
        });

        it('does not display the policy violation badge for a vulnerability without the "policyViolations" property', () => {
          expect(findPolicyViolationBadgeInRow(1).exists()).toBe(false);
        });
      });

      describe('with the securityPolicyApprovalWarnMode feature flag off', () => {
        beforeEach(() => {
          createWrapper({ props: { vulnerabilities: newVulnerabilities } });
        });

        it('does not display the policy violation badge for a vulnerability with the "policyViolations" property', () => {
          expect(findPolicyViolationBadgeInRow(0).exists()).toBe(false);
        });

        it('does not display the policy violation badge for a vulnerability without the "policyViolations" property', () => {
          expect(findPolicyViolationBadgeInRow(1).exists()).toBe(false);
        });
      });
    });
  });

  describe('validity checks', () => {
    const createSecretDetectionVulnerability = (tokenStatus = 'ACTIVE') => ({
      ...generateVulnerabilities()[0],
      id: 'secret-detection-vuln',
      reportType: 'SECRET_DETECTION',
      findingTokenStatus: {
        status: tokenStatus,
      },
    });

    describe('when project has not opted-in to validity checks', () => {
      beforeEach(() => {
        createWrapper({
          props: { vulnerabilities: [createSecretDetectionVulnerability()] },
          provide: { validityChecksEnabled: false },
        });
      });

      it('should not render validity check information', () => {
        expect(findValidityCheck('secret-detection-vuln').exists()).toBe(false);
      });
    });

    describe('when project has opted-in to validity checks', () => {
      it.each`
        tokenStatus   | expectedText
        ${'ACTIVE'}   | ${'Active secret'}
        ${'INACTIVE'} | ${'Inactive secret'}
        ${'UNKNOWN'}  | ${'Possibly active secret'}
      `(
        'with $tokenStatus token status should display "$expectedText" text',
        ({ tokenStatus, expectedText }) => {
          createWrapper({
            props: { vulnerabilities: [createSecretDetectionVulnerability(tokenStatus)] },
            provide: { validityChecksEnabled: true },
          });
          expect(findValidityCheck('secret-detection-vuln').text()).toContain(expectedText);
        },
      );
    });

    describe('when vulnerability is not secret detection', () => {
      beforeEach(() => {
        const nonSecretDetectionVuln = {
          ...createSecretDetectionVulnerability(),
          reportType: 'SAST',
        };

        createWrapper({
          props: { vulnerabilities: [nonSecretDetectionVuln] },
          provide: { validityChecksEnabled: true },
        });
      });

      it('should not render validity check information', () => {
        expect(findValidityCheck('secret-detection-vuln').exists()).toBe(false);
      });
    });

    describe('when validityChecksSecurityFindingStatus feature flag is disabled', () => {
      beforeEach(() => {
        createWrapper({
          props: { vulnerabilities: findings },
          stubs: {
            SelectionSummary: true,
          },
          provide: {
            glFeatures: { validityChecksSecurityFindingStatus: false },
            dashboardType: 'pipeline',
          },
        });
      });

      it('should not render validity check information on pipeline dashboard', () => {
        expect(findValidityCheck('secret-detection-vuln').exists()).toBe(false);
      });
    });
  });
});
