import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import RelatedIssuableInput from '~/related_issues/components/related_issuable_input.vue';
import * as Sentry from '~/sentry/sentry_browser_wrapper';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import AttachExistingIssue from 'ee/security_dashboard/components/shared/vulnerability_report/attach_existing_issue.vue';
import createMockApollo from 'helpers/mock_apollo_helper';
import createVulnerabilityIssueLinkMutation from 'ee/security_dashboard/graphql/mutations/vulnerability_issue_link_create.mutation.graphql';
import waitForPromises from 'helpers/wait_for_promises';

jest.mock('~/sentry/sentry_browser_wrapper');

Vue.use(VueApollo);

describe('Attach Existing Issue component', () => {
  let wrapper;

  const findForm = () => wrapper.find('form');
  const findRelatedIssuableInput = () => wrapper.findComponent(RelatedIssuableInput);
  const findCancelButton = () => wrapper.findByTestId('cancel-add-to-existing-button');
  const findSubmitButton = () => wrapper.find('[type="submit"]');

  const createComponent = ({
    selectedVulnerabilities = [{ id: 'id_0' }, { id: 'id_1' }],
    apolloProvider,
    vulnerabilitiesQuery,
    vulnerabilitiesCountsQuery,
  } = {}) => {
    wrapper = shallowMountExtended(AttachExistingIssue, {
      apolloProvider,
      propsData: {
        selectedVulnerabilities,
      },
      provide: {
        vulnerabilitiesQuery,
        vulnerabilitiesCountsQuery,
      },
    });
  };

  beforeEach(createComponent);

  it('renders correctly', () => {
    expect(findRelatedIssuableInput().exists()).toBe(true);
    expect(findCancelButton().exists()).toBe(true);
    expect(findSubmitButton().exists()).toBe(true);
    expect(findSubmitButton().attributes('disabled')).toBeUndefined();
    expect(findSubmitButton().classes('js-no-auto-disable')).toBe(true);
  });

  it('clicking cancel emits "cancel"', () => {
    findCancelButton().vm.$emit('click');
    expect(wrapper.emitted('cancel')).toHaveLength(1);
  });

  describe('when "addIssuableFormInput" event is emitted', () => {
    const emitFormInput = (untouchedRawReferences, touchedReference) => {
      findRelatedIssuableInput().vm.$emit('addIssuableFormInput', {
        untouchedRawReferences,
        touchedReference,
      });
      return nextTick();
    };

    it('updates references', async () => {
      await emitFormInput(['#1'], '');
      expect(findRelatedIssuableInput().props('references')).toEqual(['#1']);
    });

    it('removes duplicate references', async () => {
      await emitFormInput(['#1'], '');
      await emitFormInput(['#1'], '');
      expect(findRelatedIssuableInput().props('references')).toEqual(['#1']);
    });

    it('updates value', async () => {
      await emitFormInput([], '#1');
      expect(findRelatedIssuableInput().props('inputValue')).toBe('#1');
    });

    it('adds issue path separator if starts with a number', async () => {
      await emitFormInput([], '1');
      expect(findRelatedIssuableInput().props('inputValue')).toBe('#1');
    });
  });

  describe('when "pendingIssuableRemoveRequest" event is emitted', () => {
    it('removes pending related issue', async () => {
      await findRelatedIssuableInput().vm.$emit('addIssuableFormInput', {
        untouchedRawReferences: ['#1'],
        touchedReference: '',
      });

      expect(findRelatedIssuableInput().props('references')).toHaveLength(1);
      await findRelatedIssuableInput().vm.$emit('pendingIssuableRemoveRequest', 0);
      expect(findRelatedIssuableInput().props('references')).toHaveLength(0);
    });
  });

  describe('form submit', () => {
    const requestHandler = jest.fn().mockResolvedValue({
      data: {
        vulnerabilityIssueLinkCreate: { errors: [] },
      },
    });
    let apolloProvider;

    beforeEach(() => {
      apolloProvider = createMockApollo([[createVulnerabilityIssueLinkMutation, requestHandler]]);
      createComponent({ apolloProvider });
    });

    const submitForm = async (untouchedRawReferences) => {
      await findRelatedIssuableInput().vm.$emit('addIssuableFormInput', {
        untouchedRawReferences,
        touchedReference: '',
      });

      return findForm().trigger('submit');
    };

    it('does not create issue links when no issues are selected', async () => {
      await submitForm();
      await waitForPromises();
      expect(requestHandler).not.toHaveBeenCalled();
    });

    describe('successful API call', () => {
      it('calls the mutation with expected variables', async () => {
        await submitForm(['#1', '#2']);

        await waitForPromises();
        expect(requestHandler).toHaveBeenCalledWith({
          issueId: 'gid://gitlab/Issue/1',
          vulnerabilityIds: ['id_0', 'id_1'],
        });
        expect(requestHandler).toHaveBeenCalledWith({
          issueId: 'gid://gitlab/Issue/2',
          vulnerabilityIds: ['id_0', 'id_1'],
        });
        expect(wrapper.emitted('vulnerabilities-updated')).toEqual([
          [['id_0', 'id_1']],
          [['id_0', 'id_1']],
        ]);
        expect(findRelatedIssuableInput().props()).toMatchObject({
          inputValue: '',
          references: [],
        });
      });

      it('emits "clear-rejected" event and "vulnerabilities-updated" event', async () => {
        await submitForm(['#1', '#2']);

        expect(wrapper.emitted('clear-rejected')).toHaveLength(1);
        await waitForPromises();
        expect(wrapper.emitted('vulnerabilities-updated')).toEqual([
          [['id_0', 'id_1']],
          [['id_0', 'id_1']],
        ]);
      });

      it('sets loading state for submit button', async () => {
        await submitForm(['#1', '#2']);

        expect(findSubmitButton().props('loading')).toBe(true);
        await waitForPromises();
        expect(findSubmitButton().props('loading')).toBe(false);
      });
    });

    describe('failed API call', () => {
      const failedRequestHandler = jest.fn().mockResolvedValue({
        data: {
          vulnerabilityIssueLinkCreate: { errors: ['Error message'] },
        },
      });
      beforeEach(() => {
        apolloProvider = createMockApollo([
          [createVulnerabilityIssueLinkMutation, failedRequestHandler],
        ]);
        createComponent({ apolloProvider });
      });

      it('sends an error to Sentry', async () => {
        expect(Sentry.captureException).not.toHaveBeenCalled();

        await submitForm(['#1']);
        await waitForPromises();

        expect(Sentry.captureException.mock.calls).toMatchObject([[['Error message']]]);
        expect(wrapper.emitted('update-rejected')).toMatchObject([
          [[{ id: 'id_0' }, { id: 'id_1' }]],
        ]);
      });
    });
  });
});
