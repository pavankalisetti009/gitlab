import { GlLink, GlAlert, GlCollapsibleListbox, GlSprintf } from '@gitlab/ui';
import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import SelectionSummary from 'ee/security_dashboard/components/shared/vulnerability_report/selection_summary.vue';
import BulkChangeStatus from 'ee/security_dashboard/components/shared/vulnerability_report/bulk_change_status.vue';

Vue.use(VueApollo);

const mockVulnerabilities = {
  single: [{ id: 'gid://gitlab/Vulnerability/54' }],
  multiple: [
    { id: 'gid://gitlab/Vulnerability/54' },
    { id: 'gid://gitlab/Vulnerability/56' },
    { id: 'gid://gitlab/Vulnerability/58' },
  ],
  rejected: [{ id: 'gid://gitlab/Vulnerability/54' }, { id: 'gid://gitlab/Vulnerability/56' }],
};

describe('Selection Summary component', () => {
  let wrapper;

  const findGlAlert = () => wrapper.findComponent(GlAlert);
  const findSelectedVulnerabilities = () => wrapper.findByTestId('selected-vulnerabilities');
  const findActionListbox = () => wrapper.findComponent(GlCollapsibleListbox);
  const findBulkChangeStatus = () => wrapper.findComponent(BulkChangeStatus);

  const selectStatusAction = async () => {
    findActionListbox().vm.$emit('select', 'status');
    await nextTick();
  };

  const createComponent = ({
    selectedVulnerabilities = [],
    enhancedVulnerabilityBulkUpdates = true,
  } = {}) => {
    wrapper = shallowMountExtended(SelectionSummary, {
      stubs: {
        GlAlert,
        GlSprintf,
        GlLink,
      },
      propsData: {
        selectedVulnerabilities,
      },
      provide: {
        glFeatures: {
          enhancedVulnerabilityBulkUpdates,
        },
      },
    });
  };

  describe('with 1 vulnerability selected', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.single });
    });

    it('displays correct selection count', () => {
      expect(findSelectedVulnerabilities().text()).toBe('1 Selected');
    });

    it('shows action listbox with correct options', () => {
      expect(findActionListbox().exists()).toBe(true);
      expect(findActionListbox().props('items')).toEqual([
        { value: 'status', text: 'Change status' },
      ]);
    });

    it('hides bulk change status component initially', () => {
      expect(findBulkChangeStatus().exists()).toBe(false);
    });
  });

  describe('with multiple vulnerabilities selected', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.multiple });
    });

    it('displays correct selection count', () => {
      expect(findSelectedVulnerabilities().text()).toBe('3 Selected');
    });
  });

  describe('bulk status changes', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.single });
    });

    it('shows bulk change status component after selecting status action', async () => {
      await selectStatusAction();
      expect(findBulkChangeStatus().exists()).toBe(true);
      expect(findBulkChangeStatus().props()).toEqual({
        selectedVulnerabilities: mockVulnerabilities.single,
      });
    });

    it('emits vulnerabilities-updated event correctly', async () => {
      await selectStatusAction();
      const updatedVulnerabilities = [1];
      findBulkChangeStatus().vm.$emit('vulnerabilities-updated', updatedVulnerabilities);
      expect(wrapper.emitted('vulnerabilities-updated')).toEqual([[updatedVulnerabilities]]);
    });
  });

  describe('rejected vulnerabilities handling', () => {
    beforeEach(() => {
      createComponent({ selectedVulnerabilities: mockVulnerabilities.multiple });
      selectStatusAction();
    });

    it('displays alert with rejected vulnerability IDs', async () => {
      findBulkChangeStatus().vm.$emit('update-rejected', mockVulnerabilities.rejected);
      await nextTick();
      expect(findGlAlert().text()).toMatchInterpolatedText(
        'Failed updating vulnerabilities with the following IDs: 54, 56',
      );
    });

    it('clears alert and emits cancel event when cancelled', async () => {
      findBulkChangeStatus().vm.$emit('update-rejected', mockVulnerabilities.rejected);
      findBulkChangeStatus().vm.$emit('cancel');
      await nextTick();

      expect(findGlAlert().exists()).toBe(false);
      expect(wrapper.emitted('cancel-selection')).toHaveLength(1);
    });

    it(`clears alert when 'clear-rejected' event is emitted`, async () => {
      findBulkChangeStatus().vm.$emit('update-rejected', mockVulnerabilities.rejected);
      await nextTick();
      expect(findGlAlert().exists()).toBe(true);
      findBulkChangeStatus().vm.$emit('clear-rejected');
      await nextTick();
      expect(findGlAlert().exists()).toBe(false);
    });
  });

  describe('with enhancedVulnerabilityBulkUpdates disabled', () => {
    beforeEach(() => {
      createComponent({
        selectedVulnerabilities: mockVulnerabilities.single,
        enhancedVulnerabilityBulkUpdates: false,
      });
    });

    it('renders bulk change status directly without action listbox', () => {
      expect(findActionListbox().exists()).toBe(false);
      expect(findBulkChangeStatus().exists()).toBe(true);
    });
  });
});
