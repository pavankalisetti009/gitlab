import { GlFilteredSearch } from '@gitlab/ui';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import FilteredSearch from 'ee/security_dashboard/components/shared/filtered_search/vulnerability_report_filtered_search.vue';
import StatusToken from 'ee/security_dashboard/components/shared/filtered_search/tokens/status_token.vue';
import ActivityToken from 'ee/security_dashboard/components/shared/filtered_search/tokens/activity_token.vue';
import {
  STATUS_TOKEN_DEFINITION,
  ACTIVITY_TOKEN_DEFINITION,
  SEVERITY_TOKEN_DEFINITION,
  TOOL_VENDOR_TOKEN_DEFINITION,
  IMAGE_TOKEN_DEFINITION,
  PROJECT_TOKEN_DEFINITION,
  IDENTIFIER_TOKEN_DEFINITION,
  SCANNER_TOKEN_DEFINITION,
  REPORT_TYPE_VENDOR_TOKEN_DEFINITION,
  REACHABILITY_TOKEN_DEFINITION,
  VALIDITY_CHECK_TOKEN_DEFINITION,
} from 'ee/security_dashboard/components/shared/filtered_search/tokens/constants';
import { FILTERS } from 'ee/security_dashboard/components/shared/vulnerability_report/constants';
import eventHub from 'ee/security_dashboard/components/shared/filtered_search/event_hub';

describe('Vulnerability Report Filtered Search component', () => {
  let wrapper;

  const findFilteredSearchComponent = () => wrapper.findComponent(GlFilteredSearch);

  const createWrapper = ({
    query = {},
    availableFilters = [],
    toolFilterType = 'scanner',
    glFeatures = {},
    glAbilities = {},
  } = {}) => {
    wrapper = shallowMountExtended(FilteredSearch, {
      propsData: {
        availableFilters,
      },
      provide: {
        scanners: [],
        toolFilterType,
        projectFullPath: 'security-reports/example',
        glAbilities: {
          accessAdvancedVulnerabilityManagement: true,
          ...glAbilities,
        },
        glFeatures: {
          validityCheckEsFilter: true,
          ...glFeatures,
        },
      },
      mocks: {
        $route: {
          query,
        },
      },
    });
  };

  describe('with empty query parameters', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('should mount the component with the correct config', () => {
      const filteredSearch = findFilteredSearchComponent();

      expect(filteredSearch.props('placeholder')).toEqual('Search or filter vulnerabilities...');
      expect(filteredSearch.props('termsAsTokens')).toBe(false);
      expect(filteredSearch.props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.DEFAULT_VALUES,
            operator: '||',
          },
        },
        {
          type: 'activity',
          value: {
            data: ActivityToken.DEFAULT_VALUES,
            operator: '||',
          },
        },
      ]);
    });

    it.each`
      name                                               | vulnerabilityReportTypeScannerFilter | availableFilters                                                  | availableTokens
      ${'status and activity'}                           | ${true}                              | ${[FILTERS.STATUS, FILTERS.ACTIVITY]}                             | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION]}
      ${'status, activity, and severity'}                | ${true}                              | ${[FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.SEVERITY]}           | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION, SEVERITY_TOKEN_DEFINITION]}
      ${'status, activity, and tool with vendor'}        | ${false}                             | ${[FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.TOOL_VENDOR]}        | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION, TOOL_VENDOR_TOKEN_DEFINITION]}
      ${'status, activity, and report type with vendor'} | ${true}                              | ${[FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.REPORT_TYPE_VENDOR]} | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION, REPORT_TYPE_VENDOR_TOKEN_DEFINITION]}
      ${'status, activity, and scanner'}                 | ${true}                              | ${[FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.SCANNER]}            | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION, SCANNER_TOKEN_DEFINITION]}
      ${'status, activity, and image'}                   | ${false}                             | ${[FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.IMAGE]}              | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION, IMAGE_TOKEN_DEFINITION]}
      ${'status, activity, and identifier'}              | ${false}                             | ${[FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.IDENTIFIER]}         | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION, IDENTIFIER_TOKEN_DEFINITION]}
      ${'status, activity, project'}                     | ${false}                             | ${[FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.PROJECT]}            | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION, PROJECT_TOKEN_DEFINITION]}
      ${'status and reachability'}                       | ${false}                             | ${[FILTERS.STATUS, FILTERS.REACHABILITY]}                         | ${[STATUS_TOKEN_DEFINITION, REACHABILITY_TOKEN_DEFINITION]}
      ${'status and validity check'}                     | ${false}                             | ${[FILTERS.STATUS, FILTERS.VALIDITY_CHECK]}                       | ${[STATUS_TOKEN_DEFINITION, VALIDITY_CHECK_TOKEN_DEFINITION]}
    `(
      `passes the expected available tokens for filters '$name'`,
      ({ availableFilters, availableTokens, vulnerabilityReportTypeScannerFilter }) => {
        createWrapper({
          availableFilters,
          vulnerabilityReportTypeScannerFilter,
        });

        expect(findFilteredSearchComponent().props('availableTokens')).toEqual(availableTokens);
      },
    );

    it('should propagate when event hub emits a `filters-changed` event', () => {
      const eventObj = { state: ['DISMISSED'] };
      eventHub.$emit('filters-changed', eventObj);
      expect(wrapper.emitted('filters-changed')).toEqual([[eventObj]]);
    });

    it('should persist filters when called multiple times', () => {
      eventHub.$emit('filters-changed', { state: ['DISMISSED'] });
      eventHub.$emit('filters-changed', { severity: ['LOW'] });

      expect(wrapper.emitted('filters-changed')).toEqual([
        [{ state: ['DISMISSED'] }],
        [{ state: ['DISMISSED'], severity: ['LOW'] }],
      ]);
    });

    it('should emit empty filters on clear', () => {
      eventHub.$emit('filters-changed', { state: ['DISMISSED'] });
      findFilteredSearchComponent().vm.$emit('clear');
      expect(wrapper.emitted('filters-changed')).toEqual([[{ state: ['DISMISSED'] }], [{}]]);
    });
  });

  describe('reachability token', () => {
    it('should not be included when access advanced vulnerability management is disabled', () => {
      createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.REACHABILITY],
        glAbilities: { accessAdvancedVulnerabilityManagement: false },
      });

      expect(findFilteredSearchComponent().props('availableTokens')).toEqual([
        STATUS_TOKEN_DEFINITION,
      ]);
    });
  });

  describe('validity check token', () => {
    it('should not be included when access advanced vulnerability management is disabled', () => {
      createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.VALIDITY_CHECK],
        glAbilities: { accessAdvancedVulnerabilityManagement: false },
      });

      expect(findFilteredSearchComponent().props('availableTokens')).toEqual([
        STATUS_TOKEN_DEFINITION,
      ]);
    });

    describe('when FF validityCheckEsFilter is disabled', () => {
      it('should not be included in the available tokens', () => {
        createWrapper({
          availableFilters: [FILTERS.STATUS, FILTERS.VALIDITY_CHECK],
          glAbilities: { accessAdvancedVulnerabilityManagement: true },
          glFeatures: { validityCheckEsFilter: false },
        });

        expect(findFilteredSearchComponent().props('availableTokens')).toEqual([
          STATUS_TOKEN_DEFINITION,
        ]);
      });

      it('should not be included in the value if the query exists', () => {
        createWrapper({
          availableFilters: [FILTERS.STATUS, FILTERS.VALIDITY_CHECK],
          glAbilities: { accessAdvancedVulnerabilityManagement: true },
          glFeatures: { validityCheckEsFilter: false },
          query: { validityCheck: 'UNKNOWN' },
        });

        const value = findFilteredSearchComponent().props('value');

        expect(value).not.toContainEqual(
          expect.objectContaining({
            type: 'validityCheck',
          }),
        );
      });
    });
  });

  describe('with non-empty query parameters', () => {
    beforeEach(() => {
      createWrapper({
        availableFilters: [
          FILTERS.STATUS,
          FILTERS.ACTIVITY,
          FILTERS.PROJECT,
          FILTERS.IDENTIFIER,
          FILTERS.REACHABILITY,
          FILTERS.VALIDITY_CHECK,
        ],
        query: {
          severity: 'MEDIUM,LOW',
          scanner: 'gitlab-api-fuzzing',
          identifier: 'cve-test',
          reachability: 'IN_USE',
          validityCheck: 'UNKNOWN',
        },
      });
    });

    it('should pass route parameters to the tokens', () => {
      expect(findFilteredSearchComponent().props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.DEFAULT_VALUES,
            operator: '||',
          },
        },
        {
          type: 'activity',
          value: {
            data: ActivityToken.DEFAULT_VALUES,
            operator: '||',
          },
        },
        {
          type: 'severity',
          value: {
            data: ['MEDIUM', 'LOW'],
            operator: '||',
          },
        },
        {
          type: 'scanner',
          value: {
            data: ['gitlab-api-fuzzing'],
            operator: '||',
          },
        },
        {
          type: 'identifier',
          value: {
            data: ['cve-test'],
            operator: '=',
          },
        },
        {
          type: 'reachability',
          value: {
            data: ['IN_USE'],
            operator: '=',
          },
        },
        {
          type: 'validityCheck',
          value: {
            data: ['UNKNOWN'],
            operator: '=',
          },
        },
      ]);
    });
  });
});
