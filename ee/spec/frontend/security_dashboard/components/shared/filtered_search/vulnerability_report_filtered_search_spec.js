import { nextTick } from 'vue';
import { GlFilteredSearch } from '@gitlab/ui';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import FilteredSearch from 'ee/security_dashboard/components/shared/filtered_search/vulnerability_report_filtered_search.vue';
import StatusToken from 'ee/security_dashboard/components/shared/filtered_search/tokens/status_token.vue';
import ActivityToken from 'ee/security_dashboard/components/shared/filtered_search/tokens/activity_token.vue';
import {
  STATUS_TOKEN_DEFINITION,
  SEVERITY_TOKEN_DEFINITION,
  PROJECT_TOKEN_DEFINITION,
  IMAGE_TOKEN_DEFINITION,
  CLUSTER_TOKEN_DEFINITION,
  SCANNER_TOKEN_DEFINITION,
  ACTIVITY_TOKEN_DEFINITION,
  IDENTIFIER_TOKEN_DEFINITION,
  REPORT_TYPE_VENDOR_TOKEN_DEFINITION,
  REACHABILITY_TOKEN_DEFINITION,
  VALIDITY_CHECK_TOKEN_DEFINITION,
  TRACKED_REF_TOKEN_DEFINITION,
} from 'ee/security_dashboard/components/shared/filtered_search/tokens/constants';
import { FILTERS } from 'ee/security_dashboard/components/shared/vulnerability_report/constants';

describe('Vulnerability Report Filtered Search component', () => {
  let wrapper;

  const findFilteredSearchComponent = () => wrapper.findComponent(GlFilteredSearch);
  const mockRouter = { push: jest.fn() };

  const createWrapper = ({
    query = {},
    availableFilters = [FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.PROJECT, FILTERS.CLUSTER],
    toolFilterType = 'scanner',
    projectFullPath = 'test/path',
    glAbilities = {},
    glFeatures = {},
    provide = {},
  } = {}) => {
    wrapper = shallowMountExtended(FilteredSearch, {
      propsData: {
        availableFilters,
      },
      provide: {
        scanners: [],
        toolFilterType,
        projectFullPath,
        defaultBranchContext: null,
        glAbilities: {
          accessAdvancedVulnerabilityManagement: true,
          ...glAbilities,
        },
        glFeatures: {
          vulnerabilitiesAcrossContexts: true,
          ...glFeatures,
        },
        ...provide,
      },
      mocks: {
        $route: {
          query,
        },
        $router: mockRouter,
      },
    });
  };

  // When using this function you need to provide all token values each time.
  // Because it sets the value with `input` event, it does take into account the previous
  // `value` the filtered search had.
  const updateValueAndEmit = async (eventName, ...args) => {
    const component = findFilteredSearchComponent().vm;

    component.$emit(
      'input',
      args.map(([type, tokenValue]) => {
        return { type, value: { data: tokenValue, operator: '||' } };
      }),
    );

    component.$emit(eventName);

    // the component uses nextTick to wait for updated value, so need this here as well
    await nextTick();
  };

  describe('with empty query parameters', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('should mount the component with the correct config', () => {
      const filteredSearch = findFilteredSearchComponent();

      expect(filteredSearch.props('placeholder')).toEqual('Search or filter vulnerabilities...');
      expect(filteredSearch.props('termsAsTokens')).toBe(false);
      expect(filteredSearch.props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.defaultValues(),
            operator: '||',
          },
        },
        {
          type: 'activity',
          value: {
            data: ActivityToken.defaultValues(),
            operator: '||',
          },
        },
      ]);
    });

    it('emits "filters-changed" event', () => {
      expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({
        state: ['DETECTED', 'CONFIRMED'],
        dismissalReason: [],
        hasResolution: false,
      });
    });

    it.each`
      name                                | availableFilters                                         | availableTokens
      ${'state'}                          | ${[FILTERS.STATUS]}                                      | ${[STATUS_TOKEN_DEFINITION]}
      ${'state and severity'}             | ${[FILTERS.STATUS, FILTERS.SEVERITY]}                    | ${[STATUS_TOKEN_DEFINITION, SEVERITY_TOKEN_DEFINITION]}
      ${'state and project'}              | ${[FILTERS.STATUS, FILTERS.PROJECT]}                     | ${[STATUS_TOKEN_DEFINITION, PROJECT_TOKEN_DEFINITION]}
      ${'state, image, project'}          | ${[FILTERS.STATUS, FILTERS.IMAGE, FILTERS.PROJECT]}      | ${[STATUS_TOKEN_DEFINITION, IMAGE_TOKEN_DEFINITION, PROJECT_TOKEN_DEFINITION]}
      ${'state and cluster'}              | ${[FILTERS.STATUS, FILTERS.CLUSTER]}                     | ${[STATUS_TOKEN_DEFINITION, CLUSTER_TOKEN_DEFINITION]}
      ${'state and activity'}             | ${[FILTERS.STATUS, FILTERS.ACTIVITY]}                    | ${[STATUS_TOKEN_DEFINITION, ACTIVITY_TOKEN_DEFINITION]}
      ${'state, scanner, identifier'}     | ${[FILTERS.STATUS, FILTERS.SCANNER, FILTERS.IDENTIFIER]} | ${[STATUS_TOKEN_DEFINITION, SCANNER_TOKEN_DEFINITION, IDENTIFIER_TOKEN_DEFINITION]}
      ${'state and report type (simple)'} | ${[FILTERS.STATUS, FILTERS.REPORT_TYPE_SIMPLE]}          | ${[STATUS_TOKEN_DEFINITION, REPORT_TYPE_VENDOR_TOKEN_DEFINITION]}
      ${'state and report type (vendor)'} | ${[FILTERS.STATUS, FILTERS.REPORT_TYPE_VENDOR]}          | ${[STATUS_TOKEN_DEFINITION, REPORT_TYPE_VENDOR_TOKEN_DEFINITION]}
      ${'state and reachability'}         | ${[FILTERS.STATUS, FILTERS.REACHABILITY]}                | ${[STATUS_TOKEN_DEFINITION, REACHABILITY_TOKEN_DEFINITION]}
      ${'state and validity check'}       | ${[FILTERS.STATUS, FILTERS.VALIDITY_CHECK]}              | ${[STATUS_TOKEN_DEFINITION, VALIDITY_CHECK_TOKEN_DEFINITION]}
    `(
      `passes the expected available tokens for filters '$name'`,
      ({ availableFilters, availableTokens }) => {
        createWrapper({ availableFilters });

        expect(findFilteredSearchComponent().props('availableTokens')).toEqual(availableTokens);
      },
    );

    it('passes the expected available tokens for tracked ref filter when defaultBranchContext is provided', () => {
      createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.TRACKED_REF],
        provide: {
          defaultBranchContext: { id: 'gid://gitlab/TrackedRef/1', name: 'main' },
        },
      });

      expect(findFilteredSearchComponent().props('availableTokens')).toEqual([
        STATUS_TOKEN_DEFINITION,
        TRACKED_REF_TOKEN_DEFINITION,
      ]);
    });
  });

  describe('instance level', () => {
    const availableFilters = [FILTERS.IDENTIFIER];

    beforeEach(() => {
      createWrapper({
        availableFilters,
        provide: {
          dashboardType: 'instance',
        },
      });
    });

    it('does not show the identifier filter', () => {
      expect(findFilteredSearchComponent().props('availableTokens')).not.toContain(
        IDENTIFIER_TOKEN_DEFINITION,
      );
    });
  });

  describe('with access vulnerability management turned off', () => {
    const availableFilters = [FILTERS.REACHABILITY, FILTERS.VALIDITY_CHECK];

    it('should not show the advanced filters when accessAdvancedVulnerabilityManagement is off', () => {
      createWrapper({
        availableFilters,
        glAbilities: {
          accessAdvancedVulnerabilityManagement: false,
        },
      });

      expect(findFilteredSearchComponent().props('availableTokens')).not.toContain(
        REACHABILITY_TOKEN_DEFINITION,
      );

      expect(findFilteredSearchComponent().props('availableTokens')).not.toContain(
        VALIDITY_CHECK_TOKEN_DEFINITION,
      );
    });

    it('should not show the advanced filters for instance level dashboard even though accessAdvancedVulnerabilityManagement is on', () => {
      createWrapper({
        availableFilters,
        projectFullPath: '', // Simulate instance level dashboard
        glAbilities: {
          accessAdvancedVulnerabilityManagement: true,
        },
      });

      expect(findFilteredSearchComponent().props('availableTokens')).not.toContain(
        REACHABILITY_TOKEN_DEFINITION,
      );

      expect(findFilteredSearchComponent().props('availableTokens')).not.toContain(
        VALIDITY_CHECK_TOKEN_DEFINITION,
      );
    });
  });

  describe('with non-empty query parameters', () => {
    beforeEach(() => {
      createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.SEVERITY, FILTERS.PROJECT, FILTERS.ACTIVITY],
        query: { severity: 'MEDIUM,LOW', projectId: '5,10' },
      });
    });

    it('should pass route parameters to the tokens', () => {
      expect(findFilteredSearchComponent().props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.defaultValues(),
            operator: '||',
          },
        },
        {
          type: 'severity',
          value: {
            data: ['MEDIUM', 'LOW'],
            operator: '||',
          },
        },
        {
          type: 'projectId',
          value: {
            data: ['5', '10'],
            operator: '||',
          },
        },
        {
          type: 'activity',
          value: {
            data: ActivityToken.defaultValues(),
            operator: '||',
          },
        },
      ]);
    });

    it('emits "filters-changed" event', () => {
      expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({
        state: ['DETECTED', 'CONFIRMED'],
        dismissalReason: [],
        hasResolution: false,
        projectId: ['5', '10'],
        severity: ['MEDIUM', 'LOW'],
      });
    });

    describe('when token defines parseQueryParams', () => {
      it.each`
        queryParam            | expectedData
        ${'1~main,2~develop'} | ${[{ id: 'gid://gitlab/Security::ProjectTrackedContext/1', name: 'main' }, { id: 'gid://gitlab/Security::ProjectTrackedContext/2', name: 'develop' }]}
        ${'ALL'}              | ${['ALL']}
      `('parses "$queryParam" into token data', ({ queryParam, expectedData }) => {
        createWrapper({
          availableFilters: [FILTERS.STATUS, FILTERS.TRACKED_REF],
          query: { trackedRefs: queryParam },
          provide: {
            defaultBranchContext: { id: 'gid://gitlab/TrackedRef/1', name: 'main' },
          },
        });

        const tokenValues = findFilteredSearchComponent().props('value');
        const trackedRefToken = tokenValues.find((t) => t.type === 'trackedRefs');

        expect(trackedRefToken.value.data).toEqual(expectedData);
      });
    });
  });

  describe('with incorrect available-filters', () => {
    beforeEach(() => {
      createWrapper({
        availableFilters: ['does-not-exist'],
      });
    });

    it('does not throw an error', () => {
      expect(wrapper.exists()).toBe(true);
    });
  });

  describe('route and filters logic', () => {
    beforeEach(() => {
      createWrapper();
    });

    describe('update token', () => {
      it('should update query and emit "filters-changed"', async () => {
        // Change initial default of activity: STILL DETECTED and state: DETECTED + CONFIRMED
        // To activity: STILL DETECTED and state: DETECTED
        await updateValueAndEmit(
          'token-complete',
          ['activity', ['STILL_DETECTED']],
          ['state', ['DETECTED']],
        );

        expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({
          state: ['DETECTED'],
          dismissalReason: [],
          hasResolution: false,
        });
        expect(mockRouter.push).toHaveBeenCalledWith({
          query: { state: 'DETECTED' },
        });
      });

      it('should call the tokens transformQueryParams when the function is defined', async () => {
        await updateValueAndEmit('token-complete', [
          'cluster',
          [{ value: 'test-agent', gid: 'gid://1' }],
        ]);

        expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({
          clusterAgentId: ['gid://1'],
        });
        expect(mockRouter.push).toHaveBeenCalledWith({
          query: { state: 'ALL', activity: 'ALL', cluster: 'test-agent' },
        });
      });

      it('should call the tokens transformFilters when the function is defined', async () => {
        await updateValueAndEmit('token-complete', ['state', ['FALSE_POSITIVE']]);

        expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({
          state: [],
          dismissalReason: ['FALSE_POSITIVE'],
        });
      });

      it('should clear query if value is equal to default values', async () => {
        createWrapper({ query: { state: ['DETECTED'] } });
        // Set default again
        await updateValueAndEmit(
          'token-complete',
          ['activity', ['STILL_DETECTED']],
          ['state', ['DETECTED', 'CONFIRMED']],
        );

        expect(mockRouter.push).toHaveBeenCalledWith({
          query: {},
        });
      });
    });

    describe('remove token', () => {
      it('should emit correct "filters-changed"', async () => {
        // Set value different from default
        await updateValueAndEmit(
          'token-complete',
          ['activity', ['STILL_DETECTED']],
          ['severity', ['MEDIUM', 'LOW']],
        );

        expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({
          severity: ['MEDIUM', 'LOW'],
          hasResolution: false,
        });

        // This removes severity token
        await updateValueAndEmit('token-destroy', ['activity', ['STILL_DETECTED']]);
        await nextTick();

        expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({
          hasResolution: false,
        });
      });

      it('should add ALL to the query parameter for tokens with default values', async () => {
        // This removes state default value
        await updateValueAndEmit('token-destroy', ['activity', ['STILL_DETECTED']]);

        expect(mockRouter.push).toHaveBeenCalledWith({
          query: { state: 'ALL' },
        });
      });
    });

    describe('clear tokens', () => {
      beforeEach(async () => {
        await updateValueAndEmit('clear', []);
      });

      it('should emit empty object in "filters-changed"', () => {
        expect(wrapper.emitted('filters-changed').at(-1)[0]).toEqual({});
      });

      it('should add ALL to query for state and activity', () => {
        expect(mockRouter.push).toHaveBeenCalledWith({ query: { state: 'ALL', activity: 'ALL' } });
      });
    });

    it('does not update router if there are no changes', async () => {
      await updateValueAndEmit(
        'token-complete',
        ['state', ['DETECTED', 'CONFIRMED']],
        ['activity', ['STILL_DETECTED']],
      );
      expect(mockRouter.push).not.toHaveBeenCalled();
    });

    describe('limited available filters', () => {
      beforeEach(() => {
        createWrapper({
          availableFilters: [FILTERS.SEVERITY],
          query: {
            severity: 'MEDIUM',
          },
        });
      });

      describe('clear tokens', () => {
        beforeEach(async () => {
          await updateValueAndEmit('clear', []);
        });

        it('does not add cleared query params like state: ALL', () => {
          expect(mockRouter.push).toHaveBeenCalledWith({ query: {} });
        });
      });
    });
  });

  describe('when FF vulnerabilitiesAcrossContexts is disabled', () => {
    it('should not show tracked ref token when feature flag is disabled', () => {
      createWrapper({
        availableFilters: [FILTERS.TRACKED_REF],
        provide: {
          defaultBranchContext: { id: 'gid://gitlab/TrackedRef/1', name: 'main' },
        },
        glFeatures: {
          vulnerabilitiesAcrossContexts: false,
        },
      });

      expect(findFilteredSearchComponent().props('availableTokens')).not.toContain(
        TRACKED_REF_TOKEN_DEFINITION,
      );
    });

    it('should not show tracked ref token when defaultBranchContext is null', () => {
      createWrapper({
        availableFilters: [FILTERS.TRACKED_REF],
        glFeatures: {
          vulnerabilitiesAcrossContexts: true,
        },
      });

      expect(findFilteredSearchComponent().props('availableTokens')).not.toContain(
        TRACKED_REF_TOKEN_DEFINITION,
      );
    });
  });
});
