import {
  NO_LONGER_DETECTED_RULE_TYPE,
  DEFAULT_VULNERABILITY_MANAGEMENT_POLICY,
  AUTO_RESOLVE,
  AUTO_DISMISS,
  OVERRIDE,
  VULNERABILITY_DETECTED_TYPE,
} from 'ee/security_orchestration/components/policy_editor/vulnerability_management/constants';
import { policyToYaml } from 'ee/security_orchestration/components/policy_editor/utils';
import { POLICY_TYPE_COMPONENT_OPTIONS } from 'ee/security_orchestration/components/constants';
import {
  createPolicyObject,
  getSelectedActionType,
  buildDefaultNoLongerDetectedRule,
  buildAction,
  validatePolicy,
  validatePolicyRuleActionCombination,
} from 'ee/security_orchestration/components/policy_editor/vulnerability_management/utils';
import {
  customYaml,
  customYamlObject,
} from 'ee_jest/security_orchestration/mocks/mock_vulnerability_management_policy_data';
import { invalidYaml } from 'ee_jest/security_orchestration/mocks/mock_pipeline_execution_policy_data';
import { fromYaml } from 'ee/security_orchestration/components/utils';
import {
  VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTIONS_VALUES,
  VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTIONS_AND_RULES,
  VULNERABILITY_MANAGEMENT_POLICY_AUTO_DISMISS_ACTION,
  VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTION_RULES_COMBINATION,
} from 'ee_jest/security_orchestration/components/policy_editor/vulnerability_management/mocks';

const ruleId = 'rule_0';
jest.mock('lodash/uniqueId', () => jest.fn().mockReturnValue(ruleId));

describe('fromYaml', () => {
  it.each`
    title                                                                     | input                                                    | output
    ${'returns the policy object for a supported manifest'}                   | ${{ manifest: DEFAULT_VULNERABILITY_MANAGEMENT_POLICY }} | ${fromYaml({ manifest: DEFAULT_VULNERABILITY_MANAGEMENT_POLICY, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter })}
    ${'returns the policy object for a policy with an unsupported attribute'} | ${{ manifest: customYaml }}                              | ${{ type: 'vulnerability_management_policy', ...customYamlObject }}
    ${'returns empty object for a policy with an invalid yaml'}               | ${{ manifest: invalidYaml }}                             | ${{}}
  `('$title', ({ input, output }) => {
    expect(
      fromYaml({
        ...input,
        type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter,
      }),
    ).toStrictEqual(output);
  });
});

describe('validatePolicyRuleActionCombination', () => {
  it.each`
    title                                                                                | input                                                                                                                             | output
    ${'returns generic message for invalid action types'}                                | ${{ actions: 'invalid', rules: [] }}                                                                                              | ${'Actions and rules must be an array.'}
    ${'returns generic message for invalid rules types'}                                 | ${{ actions: [], rules: null }}                                                                                                   | ${'Actions and rules must be an array.'}
    ${'returns error when policy contains both detected and no longer detected rules'}   | ${{ actions: [{ type: AUTO_DISMISS }], rules: [{ type: VULNERABILITY_DETECTED_TYPE }, { type: NO_LONGER_DETECTED_RULE_TYPE }] }}  | ${'A vulnerability management policy can contain only rules of same type.'}
    ${'allows policy with only detected rules'}                                          | ${{ actions: [{ type: AUTO_DISMISS }], rules: [{ type: VULNERABILITY_DETECTED_TYPE }, { type: VULNERABILITY_DETECTED_TYPE }] }}   | ${''}
    ${'allows policy with only no longer detected rules'}                                | ${{ actions: [{ type: AUTO_RESOLVE }], rules: [{ type: NO_LONGER_DETECTED_RULE_TYPE }, { type: NO_LONGER_DETECTED_RULE_TYPE }] }} | ${''}
    ${'returns error when detected rule is combined with auto resolve action'}           | ${{ actions: [{ type: AUTO_RESOLVE }], rules: [{ type: VULNERABILITY_DETECTED_TYPE }] }}                                          | ${'You can use auto-resolve actions only with no longer detected rules.'}
    ${'returns error when no longer detected rule is combined with auto dismiss action'} | ${{ actions: [{ type: AUTO_DISMISS }], rules: [{ type: NO_LONGER_DETECTED_RULE_TYPE }] }}                                         | ${'You can use auto-dismiss actions only with detected rules.'}
  `('$title', ({ input, output }) => {
    expect(
      validatePolicyRuleActionCombination({ actions: input.actions, rules: input.rules }),
    ).toBe(output);
  });
});

describe('validatePolicy', () => {
  it.each`
    title                                                                                         | input                                                                                                                                                          | output                            | autoDismissVulnerabilityPolicies
    ${'returns empty object when there are no errors'}                                            | ${fromYaml({ manifest: DEFAULT_VULNERABILITY_MANAGEMENT_POLICY, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter })}                   | ${{}}                             | ${false}
    ${'returns error objects when there are actions and rules violations'}                        | ${fromYaml({ manifest: VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTIONS_AND_RULES, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter })} | ${{ actions: true, rules: true }} | ${false}
    ${'returns error objects when there are actions for auto dismiss and disabled feature flag'}  | ${fromYaml({ manifest: VULNERABILITY_MANAGEMENT_POLICY_AUTO_DISMISS_ACTION, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter })}       | ${{ actions: true, rules: true }} | ${false}
    ${'returns empty objects when there are actions for auto dismiss and enabled feature flag'}   | ${fromYaml({ manifest: VULNERABILITY_MANAGEMENT_POLICY_AUTO_DISMISS_ACTION, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter })}       | ${{}}                             | ${true}
    ${'returns empty objects when there are invalid rules combination and disabled feature flag'} | ${fromYaml({ manifest: VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTION_RULES_COMBINATION })}                                                                    | ${{}}                             | ${false}
    ${'returns error object when there are invalid rules combination and enabled feature flag'}   | ${fromYaml({ manifest: VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTION_RULES_COMBINATION })}                                                                    | ${{ actions: true, rules: true }} | ${true}
  `('$title', ({ input, output, autoDismissVulnerabilityPolicies }) => {
    gon.features = { autoDismissVulnerabilityPolicies };
    expect(validatePolicy(input)).toStrictEqual(output);
  });
});

describe('createPolicyObject', () => {
  it.each`
    title                                                                              | input                                                        | output
    ${'returns the policy object and no errors for a supported manifest'}              | ${DEFAULT_VULNERABILITY_MANAGEMENT_POLICY}                   | ${{ policy: fromYaml({ manifest: DEFAULT_VULNERABILITY_MANAGEMENT_POLICY, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter }), parsingError: {} }}
    ${'returns the error policy object and the error for an unsupported manifest'}     | ${VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTIONS_AND_RULES} | ${{ policy: fromYaml({ manifest: VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTIONS_AND_RULES, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter }), parsingError: { actions: true, rules: true } }}
    ${'returns the error policy object and the error for an unsupported action types'} | ${VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTIONS_VALUES}    | ${{ policy: fromYaml({ manifest: VULNERABILITY_MANAGEMENT_POLICY_INVALID_ACTIONS_VALUES, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter }), parsingError: { actions: true } }}
  `('$title', ({ input, output }) => {
    expect(createPolicyObject(input)).toStrictEqual(output);
  });
});

describe('policyToYaml', () => {
  it('returns policy object as yaml', () => {
    expect(
      policyToYaml(
        customYamlObject,
        POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter,
      ),
    ).toBe(
      `vulnerability_management_policy:
  - ${customYaml}`,
    );
  });
});

describe('buildDefaultNoLongerDetectedRule', () => {
  it('builds a no longer detected rule', () => {
    expect(buildDefaultNoLongerDetectedRule()).toEqual({
      id: ruleId,
      type: NO_LONGER_DETECTED_RULE_TYPE,
      scanners: [],
      severity_levels: [],
    });
  });
});

describe('buildAction', () => {
  it('builds a basic action for non-override types', () => {
    expect(buildAction(AUTO_RESOLVE)).toEqual({ type: AUTO_RESOLVE });
    expect(buildAction(AUTO_DISMISS)).toEqual({ type: AUTO_DISMISS });
  });

  it('builds an override action with customize property', () => {
    expect(buildAction(OVERRIDE)).toEqual({
      type: OVERRIDE,
      customize: '',
    });
  });
});

describe('getSelectedActionType', () => {
  it.each`
    actions                                                | expected
    ${undefined}                                           | ${AUTO_RESOLVE}
    ${null}                                                | ${AUTO_RESOLVE}
    ${{}}                                                  | ${AUTO_RESOLVE}
    ${''}                                                  | ${AUTO_RESOLVE}
    ${[]}                                                  | ${AUTO_RESOLVE}
    ${[{ type: AUTO_RESOLVE }, { type: AUTO_DISMISS }]}    | ${AUTO_RESOLVE}
    ${[{ type: AUTO_DISMISS }, { type: AUTO_RESOLVE }]}    | ${AUTO_DISMISS}
    ${[{}, { type: AUTO_DISMISS }]}                        | ${AUTO_RESOLVE}
    ${[{ invalid: AUTO_DISMISS }, { type: AUTO_DISMISS }]} | ${AUTO_RESOLVE}
  `('selects action type from action array', ({ actions, expected }) => {
    expect(getSelectedActionType(actions)).toEqual(expected);
  });
});
