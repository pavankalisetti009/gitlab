import { nextTick } from 'vue';
import { GlAlert, GlSprintf, GlFormRadioGroup } from '@gitlab/ui';
import waitForPromises from 'helpers/wait_for_promises';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import { createMockDirective, getBinding } from 'helpers/vue_mock_directive';
import { DEFAULT_ASSIGNED_POLICY_PROJECT } from 'ee/security_orchestration/constants';
import EditorComponent from 'ee/security_orchestration/components/policy_editor/vulnerability_management/editor_component.vue';
import EditorLayout from 'ee/security_orchestration/components/policy_editor/editor_layout.vue';
import RuleSection from 'ee/security_orchestration/components/policy_editor/vulnerability_management/rule/rule_section.vue';
import ActionSection from 'ee/security_orchestration/components/policy_editor/vulnerability_management/action/action_section.vue';
import {
  AUTO_RESOLVE,
  AUTO_DISMISS,
  OVERRIDE,
  DEFAULT_VULNERABILITY_MANAGEMENT_POLICY,
  NO_LONGER_DETECTED_RULE_TYPE,
  VULNERABILITY_DETECTED_TYPE,
} from 'ee/security_orchestration/components/policy_editor/vulnerability_management/constants';

import { SECURITY_POLICY_ACTIONS } from 'ee/security_orchestration/components/policy_editor/constants';
import { ASSIGNED_POLICY_PROJECT } from 'ee_jest/security_orchestration/mocks/mock_data';
import {
  mockVulnerabilityManagementManifest,
  mockVulnerabilityManagementInvalidRulesManifest,
  mockVulnerabilityManagementObject,
  mockVulnerabilityManagementInvalidObject,
  mockVulnerabilityManagementManifestUpdated,
} from 'ee_jest/security_orchestration/mocks/mock_vulnerability_management_policy_data';
import {
  policyBodyToYaml,
  removeIdsFromPolicy,
} from 'ee/security_orchestration/components/policy_editor/utils';
import { fromYaml } from 'ee/security_orchestration/components/utils';
import { POLICY_TYPE_COMPONENT_OPTIONS } from 'ee/security_orchestration/components/constants';

describe('EditorComponent', () => {
  let wrapper;
  const defaultProjectPath = 'path/to/project';
  const defaultRule = {
    type: 'no_longer_detected',
    scanners: [],
    severity_levels: [],
  };

  const factory = ({ propsData = {}, provide = {} } = {}) => {
    wrapper = shallowMountExtended(EditorComponent, {
      directives: {
        GlTooltip: createMockDirective('gl-tooltip'),
      },
      propsData: {
        assignedPolicyProject: DEFAULT_ASSIGNED_POLICY_PROJECT,
        selectedPolicyType: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter,
        isCreating: false,
        isDeleting: false,
        isEditing: false,
        ...propsData,
      },
      provide: {
        namespacePath: defaultProjectPath,
        ...provide,
      },
      stubs: {
        GlSprintf,
      },
    });
  };

  const factoryWithExistingPolicy = ({ policy = {}, provide = {} } = {}) => {
    return factory({
      propsData: {
        assignedPolicyProject: ASSIGNED_POLICY_PROJECT,
        existingPolicy: { ...mockVulnerabilityManagementObject, ...policy },
        isEditing: true,
      },
      provide,
    });
  };

  const findPolicyEditorLayout = () => wrapper.findComponent(EditorLayout);
  const findRuleSection = () => wrapper.findComponent(RuleSection);
  const findLimitAlert = () => wrapper.findComponent(GlAlert);
  const findAllRuleSections = () => wrapper.findAllComponents(RuleSection);
  const findAddRuleButton = () => wrapper.findByTestId('add-rule');
  const findTooltip = () =>
    getBinding(wrapper.findByTestId('add-rule-wrapper').element, 'gl-tooltip');
  const findActionSection = () => wrapper.findComponent(ActionSection);
  const findDisabledAction = () => wrapper.findByTestId('disabled-action');
  const findDisabledRule = () => wrapper.findByTestId('disabled-rule');
  const findActionTypeSelector = () => wrapper.findComponent(GlFormRadioGroup);

  describe('rule mode', () => {
    const errorAction =
      'The current YAML syntax is invalid so you cannot edit the actions in rule mode. To resolve the issue, switch to YAML mode and fix the syntax.';

    const errorRules =
      'The current YAML syntax is invalid so you cannot edit the rules in rule mode. To resolve the issue, switch to YAML mode and fix the syntax.';

    it('renders the editor', () => {
      factory();
      expect(findPolicyEditorLayout().exists()).toBe(true);
      expect(findActionSection().exists()).toBe(true);
      expect(findDisabledAction().props()).toEqual({ disabled: false, error: errorAction });
      expect(findDisabledRule().props()).toEqual({ disabled: false, error: errorRules });
      expect(findActionTypeSelector().exists()).toBe(false);
    });

    it('disables the corresponding section if there is a validation error', () => {
      factoryWithExistingPolicy({ policy: mockVulnerabilityManagementInvalidObject });
      expect(findActionSection().exists()).toBe(true);
      expect(findDisabledAction().props()).toEqual({ disabled: true, error: errorAction });
      expect(findDisabledRule().props()).toEqual({ disabled: true, error: errorRules });
    });

    it('renders the default policy editor layout', () => {
      factory();
      expect(findPolicyEditorLayout().props()).toMatchObject({
        yamlEditorValue: DEFAULT_VULNERABILITY_MANAGEMENT_POLICY,
        isEditing: false,
        isRemovingPolicy: false,
        isUpdatingPolicy: false,
      });
    });

    it('updates the general policy properties', async () => {
      factory();
      const name = 'New name';
      const editorLayout = findPolicyEditorLayout();
      expect(editorLayout.props('policy').name).toBe('');
      expect(editorLayout.props('yamlEditorValue')).toContain("name: ''");
      await editorLayout.vm.$emit('update-property', 'name', name);
      expect(editorLayout.props('policy').name).toBe(name);
      expect(editorLayout.props('yamlEditorValue')).toContain(`name: ${name}`);
    });

    describe('modifying a policy', () => {
      it.each`
        status                           | action                            | event              | factoryFn                    | yamlEditorValue
        ${'creating a new policy'}       | ${undefined}                      | ${'save-policy'}   | ${factory}                   | ${policyBodyToYaml(fromYaml({ manifest: DEFAULT_VULNERABILITY_MANAGEMENT_POLICY, type: POLICY_TYPE_COMPONENT_OPTIONS.vulnerabilityManagement.urlParameter }))}
        ${'updating an existing policy'} | ${undefined}                      | ${'save-policy'}   | ${factoryWithExistingPolicy} | ${mockVulnerabilityManagementManifest}
        ${'deleting an existing policy'} | ${SECURITY_POLICY_ACTIONS.REMOVE} | ${'remove-policy'} | ${factoryWithExistingPolicy} | ${mockVulnerabilityManagementManifest}
      `('emits "save" when $status', async ({ action, event, factoryFn, yamlEditorValue }) => {
        factoryFn();
        findPolicyEditorLayout().vm.$emit(event);
        await waitForPromises();
        expect(wrapper.emitted('save')).toEqual([[{ action, policy: yamlEditorValue }]]);
      });
    });

    describe('rule section', () => {
      describe('default', () => {
        it('passes the correct props', () => {
          factory();
          const ruleSection = findRuleSection();
          expect(ruleSection.props('index')).toBe(0);
          expect(ruleSection.props('rule')).toEqual({
            ...defaultRule,
            id: ruleSection.props('rule').id,
          });
        });

        it('adds a rule when clicking button', async () => {
          factory();
          await findAddRuleButton().vm.$emit('click');
          expect(findAllRuleSections()).toHaveLength(2);
        });

        it('shows correct label for add rule button', () => {
          factory();
          expect(findAddRuleButton().text()).toBe('Add new rule');
          expect(findAddRuleButton().props('disabled')).toBe(false);
          expect(findTooltip().value.disabled).toBe(true);
        });

        it('disables add button when the limit of 5 rules has been reached', () => {
          factory();
          const limit = 5;
          const { id, ...rule } = mockVulnerabilityManagementObject.rules[0];
          factoryWithExistingPolicy({ policy: { rules: [rule, rule, rule, rule, rule] } });
          expect(findAllRuleSections()).toHaveLength(limit);
          expect(findAddRuleButton().props('disabled')).toBe(true);
          expect(findTooltip().value).toMatchObject({
            disabled: false,
            title: 'You can add a maximum of 5 rules.',
          });
        });

        it('removes rule when "remove" event is emitted', async () => {
          factory();
          findAddRuleButton().vm.$emit('click');
          findRuleSection().vm.$emit('remove');
          await nextTick();
          expect(findAllRuleSections()).toHaveLength(1);
        });

        it('updates policy rule when "changed" event is emitted', async () => {
          factory();
          const ruleSection = findRuleSection();
          const adaptedRule = {
            ...defaultRule,
            severity_levels: ['high'],
            id: ruleSection.props('rule').id,
          };

          ruleSection.vm.$emit('changed', adaptedRule);
          await nextTick();

          expect(ruleSection.props('rule')).toEqual(adaptedRule);
          expect(findPolicyEditorLayout().props('yamlEditorValue')).toBe(
            mockVulnerabilityManagementManifestUpdated,
          );
        });

        it('adds rules of selected types when action is changed', async () => {
          factory({ provide: { glFeatures: { autoDismissVulnerabilityPolicies: true } } });
          await findAddRuleButton().vm.$emit('click');

          expect(findAllRuleSections()).toHaveLength(2);
          expect(findAllRuleSections().at(0).props('rule').type).toBe(NO_LONGER_DETECTED_RULE_TYPE);
          expect(findAllRuleSections().at(1).props('rule').type).toBe(NO_LONGER_DETECTED_RULE_TYPE);

          await findActionTypeSelector().vm.$emit('change', AUTO_DISMISS);
          await findAddRuleButton().vm.$emit('click');

          expect(findAllRuleSections().at(0).props('rule').type).toBe(VULNERABILITY_DETECTED_TYPE);
          expect(findAllRuleSections().at(1).props('rule').type).toBe(VULNERABILITY_DETECTED_TYPE);

          await findActionTypeSelector().vm.$emit('change', OVERRIDE);
          await findAddRuleButton().vm.$emit('click');

          expect(findAllRuleSections()).toHaveLength(2);
          expect(findAllRuleSections().at(0).props('rule').type).toBe(VULNERABILITY_DETECTED_TYPE);
          expect(findAllRuleSections().at(1).props('rule').type).toBe(VULNERABILITY_DETECTED_TYPE);
        });
      });

      describe('auto-resolve', () => {
        it('shows auto-resolve limit message', () => {
          factory();
          expect(findLimitAlert().text()).toMatchInterpolatedText(
            'In each pipeline, a maximum of 1000 vulnerabilities that are no longer detected will be set to status Resolved until all have been auto-resolved.',
          );
        });
      });

      describe('auto-dismiss', () => {
        it('shows error message when there is invalid combination of rules', async () => {
          gon.features = { autoDismissVulnerabilityPolicies: true };
          factory({ provide: { glFeatures: { autoDismissVulnerabilityPolicies: true } } });
          await findPolicyEditorLayout().vm.$emit(
            'update-yaml',
            mockVulnerabilityManagementInvalidRulesManifest,
          );

          expect(findDisabledRule().props('disabled')).toBe(true);
          expect(findDisabledRule().props('error')).toBe(
            'A vulnerability management policy can contain only rules of same type.',
          );
        });
      });
    });

    describe('action section', () => {
      describe('default', () => {
        it('selects different action types', async () => {
          factory({
            provide: {
              glFeatures: {
                autoDismissVulnerabilityPolicies: true,
                securityPoliciesSeverityCustomize: true,
              },
            },
          });
          expect(findActionTypeSelector().exists()).toBe(true);
          expect(findActionTypeSelector().attributes('checked')).toBe(AUTO_RESOLVE);

          const actionSection = findActionSection();
          const ruleSection = findRuleSection();

          expect(actionSection.props('actions')).toEqual([
            {
              type: AUTO_RESOLVE,
              id: actionSection.props('actions')[0].id,
            },
          ]);

          expect(ruleSection.props('rule')).toEqual({
            ...defaultRule,
            id: ruleSection.props('rule').id,
          });

          await findActionTypeSelector().vm.$emit('change', AUTO_DISMISS);

          const updatedActionSection = findActionSection();
          const updatedRuleSection = findRuleSection();

          expect(updatedActionSection.props('actions')).toEqual([
            {
              type: AUTO_DISMISS,
              id: updatedActionSection.props('actions')[0].id,
            },
          ]);

          expect(updatedRuleSection.props('rule')).toEqual({
            type: VULNERABILITY_DETECTED_TYPE,
            criteria: [{ type: '', value: '' }],
            id: updatedRuleSection.props('rule').id,
          });
        });

        it('preserves state when switched between action types', async () => {
          factory();
          const rule = {
            type: VULNERABILITY_DETECTED_TYPE,
            criteria: [{ type: 'test', value: 'test' }],
          };
          factoryWithExistingPolicy({
            policy: {
              ...mockVulnerabilityManagementObject,
              actions: [{ type: AUTO_DISMISS }],
              rules: [rule],
            },
            provide: {
              glFeatures: { autoDismissVulnerabilityPolicies: true },
            },
          });

          expect(findRuleSection().props('rule')).toMatchObject(rule);

          await findActionTypeSelector().vm.$emit('change', AUTO_RESOLVE);

          expect(findRuleSection().props('rule')).toMatchObject({
            type: NO_LONGER_DETECTED_RULE_TYPE,
          });

          await findActionTypeSelector().vm.$emit('change', AUTO_DISMISS);

          expect(findRuleSection().props('rule')).toMatchObject(rule);

          await findActionTypeSelector().vm.$emit('change', OVERRIDE);

          const ruleSection = findRuleSection();
          const overrideRule = {
            ...ruleSection.props('rule'),
            identifier_type: 'cwe_id',
            identifiers: ['CWE-123'],
          };
          ruleSection.vm.$emit('changed', overrideRule);
          await nextTick();

          await findActionTypeSelector().vm.$emit('change', AUTO_RESOLVE);
          expect(findRuleSection().props('rule').type).toBe(NO_LONGER_DETECTED_RULE_TYPE);
        });
      });

      describe('auto-resolve', () => {
        it('passes correct props', () => {
          factory();
          const actionSection = findActionSection();

          expect(actionSection.props('actions')).toEqual([
            { type: 'auto_resolve', id: actionSection.props('actions')[0].id },
          ]);
        });
      });

      describe('auto-dismiss', () => {
        beforeEach(() => {
          factory({
            provide: {
              glFeatures: { autoDismissVulnerabilityPolicies: true },
            },
          });
        });

        it('does not render limit warning for auto-dismiss actions', async () => {
          await findActionTypeSelector().vm.$emit('change', AUTO_DISMISS);
          expect(findLimitAlert().exists()).toBe(false);
        });

        it('renders existing auto dismiss', () => {
          factoryWithExistingPolicy({
            policy: { ...mockVulnerabilityManagementObject, actions: [{ type: AUTO_DISMISS }] },
            provide: {
              glFeatures: { autoDismissVulnerabilityPolicies: true },
            },
          });

          expect(findActionTypeSelector().attributes('checked')).toBe(AUTO_DISMISS);
          expect(findActionSection().props('actions')[0].type).toBe(AUTO_DISMISS);
        });
      });

      describe('override', () => {
        beforeEach(() => {
          factory({
            provide: {
              glFeatures: {
                autoDismissVulnerabilityPolicies: true,
                securityPoliciesSeverityCustomize: true,
              },
            },
          });
        });

        it('includes option when feature flag is enabled', () => {
          expect(findActionTypeSelector().exists()).toBe(true);
        });

        it('does not render limit warning', async () => {
          await findActionTypeSelector().vm.$emit('change', OVERRIDE);
          expect(findLimitAlert().exists()).toBe(false);
        });

        it('displays the action', async () => {
          await findActionTypeSelector().vm.$emit('change', OVERRIDE);

          const actionSection = findActionSection();

          expect(actionSection.props('actions')).toEqual([
            {
              type: OVERRIDE,
              customize: '',
              id: actionSection.props('actions')[0].id,
            },
          ]);
        });

        it('renders existing override policy', () => {
          factoryWithExistingPolicy({
            policy: {
              ...mockVulnerabilityManagementObject,
              actions: [{ type: OVERRIDE, customize: 'set_to', severity: 'high' }],
              rules: [{ type: 'no_longer_detected', scanners: [], severity_levels: [] }],
            },
            provide: {
              glFeatures: {
                autoDismissVulnerabilityPolicies: true,
                securityPoliciesSeverityCustomize: true,
              },
            },
          });

          expect(findActionTypeSelector().attributes('checked')).toBe(OVERRIDE);
          expect(findActionSection().props('actions')[0]).toMatchObject({
            type: OVERRIDE,
            customize: 'set_to',
            severity: 'high',
          });
        });
      });
    });
  });

  describe('yaml mode', () => {
    it('updates the policy', async () => {
      factory();
      await findPolicyEditorLayout().vm.$emit('update-yaml', mockVulnerabilityManagementManifest);
      expect(findPolicyEditorLayout().props('policy')).toMatchObject(
        removeIdsFromPolicy(mockVulnerabilityManagementObject),
      );
      expect(findPolicyEditorLayout().props('yamlEditorValue')).toBe(
        mockVulnerabilityManagementManifest,
      );
    });
  });

  describe('new yaml format with type as a wrapper', () => {
    beforeEach(() => {
      factory();
    });

    it('renders default yaml in new format', () => {
      expect(findPolicyEditorLayout().props('yamlEditorValue')).toBe(
        DEFAULT_VULNERABILITY_MANAGEMENT_POLICY,
      );
    });

    it('converts new policy format to old policy format when saved', async () => {
      findPolicyEditorLayout().vm.$emit('save-policy');
      await waitForPromises();

      expect(wrapper.emitted('save')).toEqual([
        [
          {
            action: undefined,
            policy: `name: ''
description: ''
enabled: true
rules:
  - type: ${NO_LONGER_DETECTED_RULE_TYPE}
    scanners: []
    severity_levels: []
actions:
  - type: auto_resolve
type: vulnerability_management_policy
`,
          },
        ],
      ]);
    });
  });
});
