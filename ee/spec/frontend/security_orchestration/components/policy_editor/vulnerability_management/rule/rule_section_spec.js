import { GlSprintf } from '@gitlab/ui';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import RuleSection from 'ee/security_orchestration/components/policy_editor/vulnerability_management/rule/rule_section.vue';
import NoLongerDetectedRule from 'ee/security_orchestration/components/policy_editor/vulnerability_management/rule/no_longer_detected_rule.vue';
import VulnerabilityFoundRule from 'ee/security_orchestration/components/policy_editor/vulnerability_management/rule/vulnerability_found_rule.vue';
import { mockVulnerabilityManagementObject } from 'ee_jest/security_orchestration/mocks/mock_vulnerability_management_policy_data';
import { buildDefaultVulnerabilityFoundRule } from 'ee/security_orchestration/components/policy_editor/vulnerability_management/utils';

describe('RuleSection', () => {
  let wrapper;

  const defaultRule = mockVulnerabilityManagementObject.rules[0];

  const factory = ({ rule = defaultRule, index = 0, provide = {} } = {}) => {
    wrapper = shallowMountExtended(RuleSection, {
      propsData: {
        index,
        rule,
      },
      stubs: {
        GlSprintf,
      },
      provide,
    });
  };

  const findNoLongerDetectedRule = () => wrapper.findComponent(NoLongerDetectedRule);
  const findVulnerabilityFoundRule = () => wrapper.findComponent(VulnerabilityFoundRule);

  describe('default state', () => {
    beforeEach(() => {
      factory();
    });
    it('renders on longer detected rule', () => {
      expect(findNoLongerDetectedRule().exists()).toBe(true);
      expect(findVulnerabilityFoundRule().exists()).toBe(false);
    });

    it('passes correct props to child component', () => {
      expect(findNoLongerDetectedRule().props('rule')).toEqual(defaultRule);
      expect(findNoLongerDetectedRule().props('isFirstRule')).toBe(true);
    });

    it('updates existing rule', () => {
      findNoLongerDetectedRule().vm.$emit('changed', defaultRule);
      expect(wrapper.emitted('changed')).toEqual([[defaultRule]]);
    });
  });

  describe('vulnerability found rule', () => {
    const rule = buildDefaultVulnerabilityFoundRule();

    it('does not render vulnerability found rule when feature flag is off', () => {
      factory({ rule });

      expect(findNoLongerDetectedRule().exists()).toBe(true);
      expect(findVulnerabilityFoundRule().exists()).toBe(false);
    });

    it('renders vulnerability found rule when feature flag is on', () => {
      factory({ rule, provide: { glFeatures: { autoDismissVulnerabilityPolicies: true } } });

      expect(findNoLongerDetectedRule().exists()).toBe(false);
      expect(findVulnerabilityFoundRule().exists()).toBe(true);
    });

    it('passes correct props to child component', () => {
      factory({ rule, provide: { glFeatures: { autoDismissVulnerabilityPolicies: true } } });

      expect(findVulnerabilityFoundRule().props('rule')).toEqual(rule);
      expect(findVulnerabilityFoundRule().props('isFirstRule')).toBe(true);
    });

    it('emit changed event for vulnerability found rule', () => {
      factory({ rule, provide: { glFeatures: { autoDismissVulnerabilityPolicies: true } } });

      findVulnerabilityFoundRule().vm.$emit('changed', rule);
      expect(wrapper.emitted('changed')).toEqual([[rule]]);
    });
  });
});
