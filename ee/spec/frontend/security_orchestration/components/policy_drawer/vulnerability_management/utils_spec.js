import { SEVERITY_LEVELS_KEYS, REPORT_TYPES_DEFAULT_KEYS } from 'ee/security_dashboard/constants';
import {
  humanizeRules,
  humanizeDismissalReason,
  humanizeCriteria,
} from 'ee/security_orchestration/components/policy_drawer/vulnerability_management/utils';
import {
  NOT_APPLICABLE,
  ACCEPTABLE_RISK,
  FALSE_POSITIVE,
  MITIGATING_CONTROL,
  USED_IN_TESTS,
} from 'ee/security_orchestration/components/policy_editor/vulnerability_management/constants';

describe('humanize not detected rules', () => {
  it('returns empty array if no rules are passed in', () => {
    expect(humanizeRules()).toMatchObject([]);
  });

  it('lists scanners and severity levels when not all scanners and severity levels are selected', () => {
    const rules = [
      {
        type: 'no_longer_detected',
        severity_levels: ['high', 'medium'],
        scanners: ['sast', 'dependency_scanning', 'container_scanning'],
      },
      {
        type: 'no_longer_detected',
        severity_levels: ['low'],
        scanners: ['dast'],
      },
    ];

    expect(humanizeRules(rules)).toMatchObject([
      'SAST, Dependency Scanning, and Container Scanning of High and Medium severity levels',
      'DAST of Low severity level',
    ]);
  });

  it('contains "All scanners" and "all severity levels" when `scanners` and `severity_levels` are an empty array', () => {
    const rules = [
      {
        type: 'no_longer_detected',
        severity_levels: [],
        scanners: [],
      },
    ];
    expect(humanizeRules(rules)).toMatchObject(['All scanners of all severity levels']);
  });

  it('contains "All scanners" and "all severity levels" when `scanners` and `severity_levels` contain all possible values', () => {
    const rules = [
      {
        type: 'no_longer_detected',
        severity_levels: SEVERITY_LEVELS_KEYS,
        scanners: REPORT_TYPES_DEFAULT_KEYS,
      },
    ];
    expect(humanizeRules(rules)).toMatchObject(['All scanners of all severity levels']);
  });
});

describe('humanize detected rules', () => {
  it('returns empty array if no rules are passed in', () => {
    expect(humanizeRules()).toMatchObject([]);
  });

  it('lists rules with criteria for detected rules', () => {
    const rules = [
      {
        type: 'detected',
        criteria: [
          { type: 'directory', value: 'test' },
          { type: 'file_path', value: 'path' },
          { type: 'identifier', value: 'identifier' },
        ],
      },
      {
        type: 'detected',
        criteria: [{ type: 'identifier', value: 'identifier' }],
      },
    ];

    expect(humanizeRules(rules)).toEqual([
      {
        header: 'Rule 1',
        list: [
          'Directory: %{boldStart}test%{boldEnd}',
          'File Path: %{boldStart}path%{boldEnd}',
          'Identifier: %{boldStart}identifier%{boldEnd}',
        ],
      },
      { header: 'Rule 2', list: ['Identifier: %{boldStart}identifier%{boldEnd}'] },
    ]);
  });

  it('renders rules without criteria', () => {
    const rules = [{ type: 'detected' }, { type: 'detected' }];

    expect(humanizeRules(rules)).toEqual([
      { list: [], header: 'Rule 1' },
      { list: [], header: 'Rule 2' },
    ]);
  });
});

describe('humanizeCriteria', () => {
  it.each`
    criteria                                                                  | expected
    ${undefined}                                                              | ${[]}
    ${null}                                                                   | ${['Criteria were not saved in correct format.']}
    ${{}}                                                                     | ${['Criteria were not saved in correct format.']}
    ${true}                                                                   | ${['Criteria were not saved in correct format.']}
    ${[]}                                                                     | ${[]}
    ${[{ invalid: 'type' }]}                                                  | ${['Invalid criteria format']}
    ${[{ type: 'type', value: 'value' }]}                                     | ${['Type: %{boldStart}value%{boldEnd}']}
    ${[{ type: 'type', value: 'value' }, { type1: 'type', value1: 'value' }]} | ${['Type: %{boldStart}value%{boldEnd}', 'Invalid criteria format']}
  `('humanize criteria', ({ criteria, expected }) => {
    expect(humanizeCriteria(criteria)).toEqual(expected);
  });
});

describe('humanize dismissal reason', () => {
  it.each`
    reason                | expected
    ${''}                 | ${''}
    ${undefined}          | ${''}
    ${null}               | ${''}
    ${NOT_APPLICABLE}     | ${''}
    ${ACCEPTABLE_RISK}    | ${'Acceptable risk'}
    ${FALSE_POSITIVE}     | ${'False positive'}
    ${MITIGATING_CONTROL} | ${'Mitigating control'}
    ${USED_IN_TESTS}      | ${'Used in tests'}
  `('humanizes dismissal reasons for detected rules', ({ reason, expected }) => {
    expect(humanizeDismissalReason(reason)).toBe(expected);
  });
});
