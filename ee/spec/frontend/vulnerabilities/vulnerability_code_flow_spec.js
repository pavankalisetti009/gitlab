import Vue from 'vue';
import { GlAlert, GlLoadingIcon } from '@gitlab/ui';
import VueApollo from 'vue-apollo';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import VulnerabilityCodeFlow from 'ee/vulnerabilities/components/vulnerability_code_flow.vue';
import createMockApollo from 'helpers/mock_apollo_helper';
import blobInfoQuery from 'shared_queries/repository/blob_info.query.graphql';
import waitForPromises from 'helpers/wait_for_promises';
import { s__ } from '~/locale';
import { TEST_ALL_BLOBS_INFO_GRAPHQL_SUCCESS_RESPONSE } from './mock_data';

Vue.use(VueApollo);

describe('Vulnerability Code Flow', () => {
  let wrapper;

  const vulnerability = {
    id: 123,
    description: 'vulnerability description',
    descriptionHtml: 'vulnerability description <code>sample</code>',
    details: {
      name: 'code_flows',
      type: 'code_flows',
      items: [
        [
          {
            nodeType: 'source',
            fileLocation: {
              fileName: 'src/url/test.java',
              lineStart: 129,
            },
          },
          {
            nodeType: 'propagation',
            fileLocation: { fileName: 'src/url/test.java', lineStart: 74 },
          },
          {
            nodeType: 'sink',
            fileLocation: {
              lineEnd: 77,
              fileName: 'src/url/test.java',
              lineStart: 76,
            },
          },
        ],
      ],
    },
    rawTextBlobs: {
      'src/url/test.java': '{\n  "newArray": [],\n }',
    },
  };

  const codeFlowProps = {
    projectFullPath: 'path/to/project',
    branchRef: 'main',
  };

  const getMutationResponse = jest
    .fn()
    .mockResolvedValue(TEST_ALL_BLOBS_INFO_GRAPHQL_SUCCESS_RESPONSE);

  const createWrapper = ({ mutationResponse = getMutationResponse } = {}) => {
    const propsData = {
      branchRef: codeFlowProps.branchRef,
      details: vulnerability.details,
    };

    wrapper = shallowMountExtended(VulnerabilityCodeFlow, {
      apolloProvider: createMockApollo([[blobInfoQuery, mutationResponse]]),
      provide: { projectFullPath: codeFlowProps.projectFullPath },
      propsData,
    });
  };

  const findGlLoadingIcon = () => wrapper.findComponent(GlLoadingIcon);
  const findGlAlert = () => wrapper.findComponent(GlAlert);
  const getById = (id) => wrapper.findByTestId(id);

  describe('default behavior', () => {
    it('shows the properties that should always be shown', () => {
      createWrapper();
      expect(findGlLoadingIcon().exists()).toBe(true);
      expect(findGlAlert().exists()).toBe(false);
    });
  });

  describe('loading and error states', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('displays loading icon while loading', () => {
      expect(findGlLoadingIcon().exists()).toBe(true);
    });

    it('fetches the blob info', async () => {
      await waitForPromises();
      expect(getMutationResponse).toHaveBeenCalledTimes(1);
      expect(getMutationResponse).toHaveBeenCalledWith({
        projectPath: codeFlowProps.projectFullPath,
        filePath: [vulnerability.details.items[0][0].fileLocation.fileName],
        ref: codeFlowProps.branchRef,
        refType: null,
        shouldFetchRawText: true,
      });
    });

    it('shows error alert on query error', async () => {
      const errorResponse = jest.fn().mockRejectedValue({});
      createWrapper({ mutationResponse: errorResponse });
      await waitForPromises();

      expect(findGlAlert().exists()).toBe(true);
      expect(findGlLoadingIcon().exists()).toBe(false);
      expect(getById('loading-error').text()).toBe(
        s__('Vulnerability|Something went wrong while trying to get the source file.'),
      );
    });
  });
});
