# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::SbomScan, feature_category: :software_composition_analysis do
  let_it_be(:project) { create(:project) }
  let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:job) { create(:ci_build, pipeline: pipeline) }

  let(:sbom_file) do
    fixture_file_upload('ee/spec/fixtures/security/vulnerability_scanning/sbom_scans/sbom.json', 'application/json')
  end

  let(:result_file) do
    fixture_file_upload('ee/spec/fixtures/security/vulnerability_scanning/sbom_scans/sbom_scan_result.json',
      'application/json')
  end

  subject(:sbom_scan) { create(:sbom_scan, project: project, build: job, sbom_digest: "foo") }

  describe 'associations' do
    it { is_expected.to belong_to(:project) }
    it { is_expected.to belong_to(:build).class_name('Ci::Build') }
    it { is_expected.to belong_to(:result).class_name('Security::VulnerabilityScanning::SbomScanResult').optional }
  end

  describe 'validations' do
    it { is_expected.to validate_presence_of(:project) }
    it { is_expected.to validate_presence_of(:build) }
    it { is_expected.to validate_length_of(:sbom_file_final_path).is_at_most(1024) }
    it { is_expected.to validate_length_of(:error_message).is_at_most(1024) }

    context 'when status is running' do
      before do
        sbom_scan.status = 1
      end

      it 'requires sbom_file', :aggregate_failures do
        expect(sbom_scan).not_to be_valid
        expect(sbom_scan.errors[:sbom_file]).to include("can't be blank")
      end

      it 'does not require result_file' do
        sbom_scan.sbom_file = sbom_file
        expect(sbom_scan).to be_valid
      end
    end

    context 'when status is failed' do
      before do
        sbom_scan.status = -1
      end

      it 'does not require sbom_file nor result_file' do
        sbom_scan.sbom_file = sbom_scan.result_file = nil
        expect(sbom_scan).to be_valid
      end
    end

    context 'when no result' do
      subject(:sbom_scan) { create(:sbom_scan, :finished, project: project, build: job, result: nil) }

      it { is_expected.to be_valid }
    end

    context 'when no result_file' do
      subject(:sbom_scan) { create(:sbom_scan, :finished, project: project, build: job, result_file: nil) }

      it { is_expected.to be_valid }
    end
  end

  describe '.expired' do
    let!(:expired_scan) { create(:sbom_scan, :expired, project: project, build: job) }
    let!(:recent_scan) { create(:sbom_scan, project: project, build: job) }

    subject(:scans) { described_class.expired }

    it { is_expected.to contain_exactly(expired_scan) }
  end

  describe '.for_build' do
    let(:other_job) { create(:ci_build, pipeline: pipeline) }
    let(:other_sbom_scan) { create(:sbom_scan, project: project, build: other_job) }

    it 'only returns scans belonging to the given job', :aggregate_failures do
      scoped_sbom_scans = described_class.for_build(job)

      expect(described_class.all).to contain_exactly(sbom_scan, other_sbom_scan)
      expect(scoped_sbom_scans).to contain_exactly(sbom_scan)
    end
  end

  describe '.for_project_and_sbom_digest' do
    let_it_be(:project) { create(:project) }
    let(:sbom_digest) { 'sha256v1-abc123def456' }

    subject(:for_project_and_sbom_digest) { described_class.for_project_and_sbom_digest(project, sbom_digest) }

    context 'when same project and digest' do
      let!(:sbom_scan) { create(:sbom_scan, project: project, sbom_digest: sbom_digest) }

      specify do
        expect(for_project_and_sbom_digest.first.id).to eq(sbom_scan.id)
      end
    end

    context 'when different project' do
      let!(:sbom_scan) { create(:sbom_scan, project: create(:project), sbom_digest: sbom_digest) }

      it { is_expected.to be_empty }
    end

    context 'when different digest' do
      let!(:sbom_scan) { create(:sbom_scan, project: project, sbom_digest: 'different-digest') }

      it { is_expected.to be_empty }
    end

    context 'when digest is nil' do
      let(:sbom_digest) { nil }
      let!(:sbom_scan) { create(:sbom_scan, project: project) }

      it { is_expected.to be_empty }
    end
  end

  describe '.most_recently_finished' do
    subject(:most_recently_finished) { described_class.most_recently_finished }

    context 'when there are no finished scans' do
      let!(:created_scan) { create(:sbom_scan, project: project, build: job) }
      let!(:running_scan) { create(:sbom_scan, :running, project: project, build: job) }
      let!(:failed_scan) { create(:sbom_scan, :failed, project: project, build: job) }

      it { is_expected.to be_empty }
    end

    context 'when there is one finished scan' do
      let!(:finished_scan) { create(:sbom_scan, :finished, project: project, build: job) }
      let!(:running_scan) { create(:sbom_scan, :running, project: project, build: job) }

      it { is_expected.to contain_exactly(finished_scan) }
    end

    context 'when there are multiple finished scans' do
      let!(:scan1) { create(:sbom_scan, :finished, project: project, build: job, created_at: 3.days.ago) }
      let!(:scan2) { create(:sbom_scan, :finished, project: project, build: job, created_at: 2.days.ago) }
      let!(:scan3) { create(:sbom_scan, :finished, project: project, build: job, created_at: 1.day.ago) }

      it 'returns only the most recently created finished scan' do
        expect(most_recently_finished).to contain_exactly(scan3)
      end
    end

    context 'when finished scans have the same created_at timestamp' do
      let(:timestamp) { DateTime.now }
      let!(:scan1) { create(:sbom_scan, :finished, project: project, build: job, created_at: timestamp) }
      let!(:scan2) { create(:sbom_scan, :finished, project: project, build: job, created_at: timestamp) }

      it 'returns only one scan' do
        expect(most_recently_finished.count).to eq(1)
        expect(most_recently_finished.first).to be_in([scan1, scan2])
      end
    end
  end

  describe 'sbom_digest attribute' do
    context 'when creating a scan with sbom_digest' do
      let(:digest) { 'sha256v1-abc123def456' }
      let(:sbom_scan_with_digest) { create(:sbom_scan, project: project, build: job, sbom_digest: digest) }

      it 'stores the sbom_digest' do
        expect(sbom_scan_with_digest.sbom_digest).to eq(digest)
      end
    end

    context 'when querying by sbom_digest' do
      let(:digest) { 'sha256v1-abc123def456' }
      let!(:scan_with_digest) { create(:sbom_scan, :finished, project: project, build: job, sbom_digest: digest) }
      let!(:scan_without_digest) { create(:sbom_scan, :finished, project: project, build: job) }

      it 'finds scans with matching digest' do
        scans = described_class.where(sbom_digest: digest)
        expect(scans).to contain_exactly(scan_with_digest)
      end
    end

    context 'when multiple scans share the same digest' do
      let(:digest) { 'sha256v1-shared-digest' }
      let!(:scan1) { create(:sbom_scan, :finished, project: project, build: job, sbom_digest: digest) }
      let!(:scan2) { create(:sbom_scan, :finished, project: project, build: job, sbom_digest: digest) }

      it 'allows multiple scans with the same digest' do
        scans = described_class.where(sbom_digest: digest)
        expect(scans).to contain_exactly(scan1, scan2)
      end
    end
  end

  describe 'result association' do
    context 'when scan has a result' do
      let(:sbom_scan_result) do
        Security::VulnerabilityScanning::SbomScanResult.create!(
          project: project,
          result_file: result_file
        )
      end

      let(:sbom_scan_with_result) do
        create(:sbom_scan, :finished, project: project, build: job, result: sbom_scan_result)
      end

      it 'associates with the result' do
        expect(sbom_scan_with_result.result).to eq(sbom_scan_result)
      end
    end

    context 'when multiple scans share the same result' do
      let(:shared_result) do
        Security::VulnerabilityScanning::SbomScanResult.create!(
          project: project,
          result_file: result_file
        )
      end

      let!(:scan1) { create(:sbom_scan, :finished, project: project, build: job, result: shared_result) }
      let!(:scan2) { create(:sbom_scan, :finished, project: project, build: job, result: shared_result) }

      it 'allows multiple scans to reference the same result', :aggregate_failures do
        expect(scan1.result).to eq(shared_result)
        expect(scan2.result).to eq(shared_result)
      end
    end
  end

  describe 'state machine' do
    around do |example|
      freeze_time { example.run }
    end

    describe 'initial state' do
      it 'has created as initial status' do
        expect(sbom_scan.status_name).to eq(:created)
      end
    end

    context 'when in created state' do
      subject(:sbom_scan) { create(:sbom_scan, :with_sbom_file, project: project, build: job) }

      it 'can transition to running' do
        expect { sbom_scan.start! }.to change { sbom_scan.status_name }.from(:created).to(:running)
      end

      it 'can transition to failed' do
        expect { sbom_scan.failed! }.to change { sbom_scan.status_name }.from(:created).to(:failed)
      end

      it 'cannot transition to finished directly' do
        expect { sbom_scan.finish! }.to raise_error(StateMachines::InvalidTransition)
      end
    end

    context 'when in running state' do
      subject(:sbom_scan) { create(:sbom_scan, :running, :with_sbom_file, project: project, build: job) }

      it 'can transition to finished' do
        sbom_scan.result = create(:sbom_scan_result)
        expect { sbom_scan.finish! }.to change { sbom_scan.status_name }.from(:running).to(:finished)
      end

      it 'can transition to failed' do
        expect { sbom_scan.failed! }.to change { sbom_scan.status_name }.from(:running).to(:failed)
      end

      it 'can transition to created' do
        expect { sbom_scan.reset_state! }.to change { sbom_scan.status_name }.from(:running).to(:created)
      end

      it 'cannot transition to running again' do
        expect { sbom_scan.start! }.to raise_error(StateMachines::InvalidTransition)
      end
    end

    context 'when in finished state' do
      subject(:sbom_scan) { create(:sbom_scan, :finished, project: project, build: job) }

      it 'cannot transition to any other state', :aggregate_failures do
        expect { sbom_scan.start! }.to raise_error(StateMachines::InvalidTransition)
        expect { sbom_scan.finish! }.to raise_error(StateMachines::InvalidTransition)
        expect { sbom_scan.failed! }.to raise_error(StateMachines::InvalidTransition)
      end
    end

    context 'when in failed state' do
      subject(:sbom_scan) { create(:sbom_scan, :failed, project: project, build: job) }

      it 'cannot transition to any other state', :aggregate_failures do
        expect { sbom_scan.start! }.to raise_error(StateMachines::InvalidTransition)
        expect { sbom_scan.finish! }.to raise_error(StateMachines::InvalidTransition)
        expect { sbom_scan.failed! }.to raise_error(StateMachines::InvalidTransition)
      end
    end
  end

  describe 'file uploaders' do
    it 'mounts sbom_file uploader' do
      expect(sbom_scan.sbom_file).to be_a(Security::VulnerabilityScanning::SbomScanUploader)
    end

    it 'mounts result_file uploader' do
      expect(sbom_scan.result_file).to be_a(Security::VulnerabilityScanning::SbomScanUploader)
    end
  end

  describe '#fail_with_error_message!' do
    subject(:fail_with_error_message!) { sbom_scan.fail_with_error_message!(message) }

    let(:message) { 'Some error message' }

    it 'sets error_message attribute' do
      fail_with_error_message!
      expect(sbom_scan.error_message).to eq('Some error message')
    end

    it 'marks the scan as failed' do
      fail_with_error_message!
      sbom_scan.reload
      expect(sbom_scan.failed?).to be_truthy
    end

    context 'when message is nil' do
      let(:message) { nil }

      it 'sets error_message to nil' do
        fail_with_error_message!
        expect(sbom_scan.error_message).to be_nil
      end
    end

    context 'when message is over 1024 characters' do
      let(:message) { 'a' * 1025 }

      it 'truncates the message to 1024 characters' do
        fail_with_error_message!
        expect(sbom_scan.error_message.length).to eq(1024)
        expect(sbom_scan.error_message).to end_with('...')
      end
    end
  end

  describe '#delete_files_from_storage' do
    let(:sbom_scan) { create(:sbom_scan, :finished, project: project, build: job) }

    subject(:delete_files) { sbom_scan.delete_files_from_storage }

    context 'when both files are successfully removed' do
      it 'successfully deletes files from storage and returns true', :aggregate_failures do
        sbom_file_path = sbom_scan.sbom_file.file.path
        result_file_path = sbom_scan.result_file.file.path

        expect(File.exist?(sbom_file_path)).to be_truthy
        expect(File.exist?(result_file_path)).to be_truthy

        expect(delete_files).to be true

        expect(File.exist?(sbom_file_path)).to be_falsey
        expect(File.exist?(result_file_path)).to be_falsey
      end
    end

    context 'when scan results come from SbomScanResult association' do
      let(:sbom_scan_result) { create(:sbom_scan_result, :with_result_file, project: project) }
      let(:sbom_scan) { create(:sbom_scan, :finished, project: project, build: job) }

      it 'does not remove the scan result association' do
        expect { delete_files }.not_to change { sbom_scan_result.reload.persisted? }.from(true)
      end

      it 'does not remove the file' do
        expect { delete_files }.not_to change { File.exist?(sbom_scan_result.result_file.path) }.from(true)
      end
    end

    context 'when file removal fails' do
      let(:error) { StandardError.new('Failed to remove sbom_file') }

      before do
        allow(sbom_scan.sbom_file).to receive(:remove!).and_raise(error)
      end

      it 'returns false and tracks error', :aggregate_failures do
        expect(Gitlab::ErrorTracking).to receive(:track_exception).with(error)
        expect(delete_files).to be false
      end
    end
  end

  describe '#result_file' do
    let(:sbom_scan) do
      create(:sbom_scan, :running, project: project, build: job, result: result, result_file: result_file)
    end

    let(:result_file) do
      fixture_file_upload('ee/spec/fixtures/security/vulnerability_scanning/sbom_scans/sbom_scan_result.json',
        'application/json')
    end

    let(:result) { create(:sbom_scan_result, :with_result_file) }

    subject { sbom_scan.result_file }

    context 'when sbom_scan using old attribute' do
      let(:result) { nil }

      specify do
        file = sbom_scan.result_file
        expect(file.class).to be(Security::VulnerabilityScanning::SbomScanUploader)
        expect(file.path).not_to be_empty
        expect(file.path).to end_with("sbom_scan_result.json")
      end
    end

    context 'when sbom_scan using new attribute' do
      let(:result_file) { nil }

      specify do
        file = sbom_scan.result_file
        expect(file.class).to be(Security::VulnerabilityScanning::SbomScanResultUploader)
        expect(file.path).not_to be_empty
        expect(file.path).to end_with("sbom_scan_result.json")
      end
    end

    context 'when both attributes are nil' do
      let(:result_file) { nil }
      let(:result) { nil }

      specify do
        file = sbom_scan.result_file
        expect(file.class).to be(Security::VulnerabilityScanning::SbomScanUploader)
        expect(file.path).to be_nil
      end
    end
  end
end
