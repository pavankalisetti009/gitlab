# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::SbomScanResult,
  feature_category: :software_composition_analysis do
  let_it_be(:project) { create(:project) }

  let(:result_file) do
    fixture_file_upload('ee/spec/fixtures/security/vulnerability_scanning/sbom_scans/sbom_scan_result.json',
      'application/json')
  end

  subject(:sbom_scan_result) do
    described_class.create!(project: project, result_file: result_file)
  end

  describe 'associations' do
    it { is_expected.to belong_to(:project) }
  end

  describe 'file uploader' do
    it 'mounts result_file uploader' do
      expect(sbom_scan_result.result_file).to be_a(Security::VulnerabilityScanning::SbomScanResultUploader)
    end

    it 'stores the result file' do
      sbom_scan_result.store_result_file!
      expect(sbom_scan_result.result_file.file).to be_present
    end
  end

  describe '#delete_files_from_storage' do
    subject(:delete_files) { sbom_scan_result.delete_files_from_storage }

    before do
      sbom_scan_result.store_result_file!
    end

    context 'when file is successfully removed' do
      it 'successfully deletes file from storage and returns true', :aggregate_failures do
        result_file_path = sbom_scan_result.result_file.file.path

        expect(File.exist?(result_file_path)).to be_truthy
        expect(delete_files).to be true
        expect(File.exist?(result_file_path)).to be_falsey
      end
    end

    context 'when file removal fails' do
      let(:error) { StandardError.new('Failed to remove result_file') }

      before do
        allow(sbom_scan_result.result_file).to receive(:remove!).and_raise(error)
      end

      it 'returns false and tracks error', :aggregate_failures do
        expect(Gitlab::ErrorTracking).to receive(:track_exception).with(error)
        expect(delete_files).to be false
      end
    end
  end

  describe 'shared results across multiple scans' do
    let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
    let_it_be(:job1) { create(:ci_build, pipeline: pipeline) }
    let_it_be(:job2) { create(:ci_build, pipeline: pipeline) }

    let(:shared_result) do
      described_class.create!(project: project, result_file: result_file)
    end

    let!(:scan1) do
      Security::VulnerabilityScanning::SbomScan.create!(
        project: project,
        build: job1,
        result: shared_result,
        status: 2
      )
    end

    let!(:scan2) do
      Security::VulnerabilityScanning::SbomScan.create!(
        project: project,
        build: job2,
        result: shared_result,
        status: 2
      )
    end

    it 'can be referenced by multiple scans', :aggregate_failures do
      expect(scan1.result).to eq(shared_result)
      expect(scan2.result).to eq(shared_result)
    end

    it 'persists when one scan is deleted' do
      scan1.destroy!

      expect(described_class.find(shared_result.id)).to eq(shared_result)
      expect(scan2.reload.result).to eq(shared_result)
    end
  end

  describe 'result file storage' do
    context 'with local storage' do
      before do
        stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanResultUploader, enabled: false)
      end

      it 'stores file locally' do
        sbom_scan_result.store_result_file!

        expect(sbom_scan_result.result_file_store).to eq(ObjectStorage::Store::LOCAL)
        expect(sbom_scan_result.result_file).to be_file_storage
      end
    end

    context 'with remote storage' do
      before do
        stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanResultUploader, enabled: true)
      end

      it 'stores file remotely' do
        sbom_scan_result.store_result_file!

        expect(sbom_scan_result.result_file_store).to eq(ObjectStorage::Store::REMOTE)
        expect(sbom_scan_result.result_file).not_to be_file_storage
      end
    end
  end

  describe 'without_scans scope' do
    let!(:result1) { create(:sbom_scan_result) }
    let!(:result2) { create(:sbom_scan_result) }
    let!(:sbom_scan1) { create(:sbom_scan, result: result1) }

    it 'returns those results that do not have an sbom_scan associated with them' do
      expect(described_class.without_scans([result1.id, result2.id])).to contain_exactly(result2)
      sbom_scan1.delete
      expect(described_class.without_scans([result1.id, result2.id])).to contain_exactly(result1, result2)
    end

    it 'returns nil for nonexistent results' do
      expect(described_class.without_scans([123, 456])).to eq([])
    end
  end
end
