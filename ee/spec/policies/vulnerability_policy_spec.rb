# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityPolicy, feature_category: :vulnerability_management do
  describe '#rules' do
    let(:project) { create(:project) }
    let(:user) { create(:user) }
    let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

    subject { described_class.new(user, vulnerability) }

    context 'when the security_dashboard feature is enabled' do
      before do
        stub_licensed_features(security_dashboard: true)
      end

      context "when the current user is not a project member" do
        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_note) }
        it { is_expected.to be_disallowed(:explain_vulnerability) }
        it { is_expected.to be_disallowed(:resolve_vulnerability) }
      end

      context "when the current user has developer access to the vulnerability's project" do
        before do
          project.add_developer(user)
        end

        it { is_expected.to be_allowed(:read_security_resource) }
        it { is_expected.to be_allowed(:read_vulnerability) }
        it { is_expected.to be_allowed(:create_external_issue_link) }
        it { is_expected.to be_allowed(:create_note) }
      end

      context "when the current user has admin_vulnerability via a custom role" do
        let_it_be(:user) { create(:user) }
        let_it_be(:project) { create(:project, :in_group) }
        let_it_be(:role) { create(:member_role, :guest, :admin_vulnerability, namespace: project.group) }
        let_it_be(:membership) { create(:group_member, :guest, user: user, source: project.group, member_role: role) }
        let_it_be(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

        subject { described_class.new(user, vulnerability) }

        before do
          stub_licensed_features(
            custom_roles: true,
            jira_vulnerabilities_integration: true,
            security_dashboard: true
          )
        end

        it { is_expected.to be_allowed(:admin_vulnerability) }
        it { is_expected.to be_allowed(:create_external_issue_link) }
      end

      context 'when the security_dashboard feature is disabled' do
        before do
          stub_licensed_features(security_dashboard: false)
          project.add_developer(user)
        end

        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_external_issue_link) }
        it { is_expected.to be_disallowed(:create_note) }
      end

      context 'when the user is project member but does not have proper access' do
        before do
          project.add_guest(user)
        end

        it do
          is_expected.to be_disallowed(:create_note)
        end
      end
    end

    describe 'explain_vulnerability_allowed_for_user' do
      context 'when dap_external_trigger_usage_billing FF is enabled' do
        context 'when user is present' do
          using RSpec::Parameterized::TableSyntax

          where(:can_access_duo_external_trigger, :expected) do
            true  | true
            false | false
          end

          with_them do
            before do
              stub_licensed_features(security_dashboard: true)
              stub_feature_flags(dap_external_trigger_usage_billing: true)
              project.add_developer(user)

              allow(::Gitlab::Llm::FeatureAuthorizer).to receive(:can_access_duo_external_trigger?)
                .with(user: user, container: project)
                .and_return(can_access_duo_external_trigger)
            end

            it do
              is_expected.to public_send("be_#{expected ? 'allowed' : 'disallowed'}",
                :explain_vulnerability_with_ai)
            end
          end

          context 'when verifying FeatureAuthorizer.can_access_duo_external_trigger? parameters' do
            subject(:policy) { described_class.new(user, vulnerability) }

            before do
              stub_licensed_features(security_dashboard: true)
              stub_feature_flags(dap_external_trigger_usage_billing: true)
              project.add_developer(user)
              allow(::Gitlab::Llm::FeatureAuthorizer).to receive(:can_access_duo_external_trigger?).and_return(true)
            end

            it 'calls can_access_duo_external_trigger? with correct parameters for both conditions' do
              expect(::Gitlab::Llm::FeatureAuthorizer)
              .to receive(:can_access_duo_external_trigger?)
              .at_least(:twice)
              .with(
                user: user,
                container: project
              ).and_return(true)

              policy.allowed?(:explain_vulnerability_with_ai)
            end
          end
        end

        context 'when user is nil' do
          let(:user) { nil }

          before do
            stub_feature_flags(dap_external_trigger_usage_billing: true)
          end

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end
      end

      context 'when dap_external_trigger_usage_billing feature flag is disabled' do
        before do
          stub_feature_flags(dap_external_trigger_usage_billing: false)
          stub_licensed_features(security_dashboard: true)
        end

        context 'when user is present' do
          using RSpec::Parameterized::TableSyntax

          where(:chat_authorizer_allowed, :can_read_security, :cloud_connector_allowed, :expected) do
            true  | true  | true  | true
            true  | false | true  | false
            true  | true  | false | false
            false | true  | true  | false
          end

          with_them do
            before do
              allow(user).to receive(:can?).and_call_original
              allow(user).to receive(:can?).with("read_vulnerability", vulnerability).and_return(true)
              allow(user).to receive(:can?).with(:access_duo_classic_chat).and_return(true)
              allow(user).to receive(:can?).with(:access_duo_features, vulnerability.project).and_return(true)

              if can_read_security
                project.add_developer(user)
              else
                project.add_guest(user)
              end

              # Set up cloud connector authorization
              allow(user).to receive(:allowed_to_use?).with(:explain_vulnerability).and_return(cloud_connector_allowed)

              # Stub ChatAuthorizer for the else branch
              response = instance_double(Gitlab::Llm::Utils::Authorizer::Response, allowed?: chat_authorizer_allowed)
              allow(::Gitlab::Llm::Chain::Utils::ChatAuthorizer)
                .to receive(:resource)
                .with(resource: vulnerability, user: user)
                .and_return(response)
            end

            it do
              is_expected.to public_send("be_#{expected ? 'allowed' : 'disallowed'}",
                :explain_vulnerability_with_ai)
            end
          end

          context 'when user is nil' do
            let(:user) { nil }

            it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
          end
        end
      end
    end

    describe 'resolve_vulnerability_with_ai' do
      let(:authorizer) { instance_double(::Gitlab::Llm::FeatureAuthorizer) }

      before do
        stub_licensed_features(security_dashboard: true)
        project.add_developer(user)
        allow(::Gitlab::Llm::FeatureAuthorizer).to receive(:new).and_return(authorizer)
      end

      context 'when feature is authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(true)
        end

        it { is_expected.to be_allowed(:resolve_vulnerability_with_ai) }

        context 'when user cannot read_security_resource' do
          before do
            project.add_guest(user)
          end

          it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
        end
      end

      context 'when feature is not authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(false)
        end

        it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
      end
    end
  end
end
