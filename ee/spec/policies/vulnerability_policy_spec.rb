# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityPolicy, feature_category: :vulnerability_management do
  describe '#rules' do
    let(:project) { create(:project) }
    let(:user) { create(:user) }
    let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

    subject { described_class.new(user, vulnerability) }

    context 'when the security_dashboard feature is enabled' do
      before do
        stub_licensed_features(security_dashboard: true)
      end

      context "when the current user is not a project member" do
        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_note) }
        it { is_expected.to be_disallowed(:explain_vulnerability) }
        it { is_expected.to be_disallowed(:resolve_vulnerability) }
      end

      context "when the current user has developer access to the vulnerability's project" do
        before do
          project.add_developer(user)
        end

        it { is_expected.to be_allowed(:read_security_resource) }
        it { is_expected.to be_allowed(:read_vulnerability) }
        it { is_expected.to be_allowed(:create_external_issue_link) }
        it { is_expected.to be_allowed(:create_note) }
      end

      context "when the current user has admin_vulnerability via a custom role" do
        let_it_be(:user) { create(:user) }
        let_it_be(:project) { create(:project, :in_group) }
        let_it_be(:role) { create(:member_role, :guest, :admin_vulnerability, namespace: project.group) }
        let_it_be(:membership) { create(:group_member, :guest, user: user, source: project.group, member_role: role) }
        let_it_be(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

        subject { described_class.new(user, vulnerability) }

        before do
          stub_licensed_features(
            custom_roles: true,
            jira_vulnerabilities_integration: true,
            security_dashboard: true
          )
        end

        it { is_expected.to be_allowed(:admin_vulnerability) }
        it { is_expected.to be_allowed(:create_external_issue_link) }
      end

      context 'when the security_dashboard feature is disabled' do
        before do
          stub_licensed_features(security_dashboard: false)
          project.add_developer(user)
        end

        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_external_issue_link) }
        it { is_expected.to be_disallowed(:create_note) }
      end

      context 'when the user is project member but does not have proper access' do
        before do
          project.add_guest(user)
        end

        it do
          is_expected.to be_disallowed(:create_note)
        end
      end
    end

    describe 'explain_vulnerability_with_ai' do
      let(:authorized) { true }
      let(:cloud_connector_free_access) { true }
      let(:cloud_connector_user_access) { false }

      before do
        stub_licensed_features(security_dashboard: true, ai_features: true)
        project.add_developer(user)
        allow(::Gitlab::Llm::Chain::Utils::ChatAuthorizer).to receive_message_chain(:resource,
          :allowed?).and_return(authorized)
        allow(::Gitlab::Llm::StageCheck).to receive(:available?).with(project, :explain_vulnerability).and_return(true)
        allow(user).to receive(:can?).with(:admin_all_resources).and_call_original
        allow(user).to receive(:can?).with("read_vulnerability", vulnerability).and_return(true)
        allow(user).to receive(:can?).with(:access_duo_chat).and_return(true)
        allow(user).to receive(:can?).with(:access_duo_features, vulnerability.project).and_return(true)
        allow(::CloudConnector::AvailableServices).to receive_message_chain(:find_by_name,
          :free_access?).and_return(cloud_connector_free_access)
        allow(::CloudConnector::AvailableServices).to receive_message_chain(:find_by_name,
          :allowed_for?).and_return(cloud_connector_user_access)
      end

      context 'when feature is authorized' do
        let(:authorized) { true }

        it { is_expected.to be_allowed(:explain_vulnerability_with_ai) }

        context 'when user cannot read_security_resource' do
          before do
            project.add_guest(user)
          end

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end

        context 'without finding' do
          let(:vulnerability) { build(:vulnerability, project: project) }

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end

        context 'when the vulnerability finding is not of a supported type' do
          let(:vulnerability) { create(:vulnerability, :with_finding, project: project, report_type: 'dast') }

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end

        context 'when the vulnerability finding is of a supported type' do
          let(:vulnerability) { create(:vulnerability, :with_finding, project: project, report_type: 'sast') }

          it { is_expected.to be_allowed(:explain_vulnerability_with_ai) }
        end

        context 'when the feature is not authorized for the stage check' do
          before do
            allow(::Gitlab::Llm::StageCheck).to receive(:available?).with(project,
              :explain_vulnerability).and_return(false)
          end

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end

        context 'when feature is not licensed' do
          before do
            stub_licensed_features(ai_features: false)
          end

          it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
        end
      end

      context 'when feature is not authorized' do
        let(:authorized) { false }

        it { is_expected.to be_disallowed(:explain_vulnerability_with_ai) }
      end

      describe 'cloud connector' do
        using RSpec::Parameterized::TableSyntax
        where(:free_access, :user_access, :allowed) do
          true  | true  | true
          true  | false | true
          false | true  | true
          false | false | false
        end

        with_them do
          let(:cloud_connector_free_access) { free_access }
          let(:cloud_connector_user_access) { user_access }
          let(:policy) { :explain_vulnerability_with_ai }

          it { is_expected.to(allowed ? be_allowed(policy) : be_disallowed(policy)) }
        end
      end

      context 'when on .org or .com', :saas do
        using RSpec::Parameterized::TableSyntax
        where(:group_with_ai_membership, :free_access, :user_access, :allowed) do
          true  | true   | true  | true
          true  | false  | true  | true
          false | false  | true  | true
          false | false  | false | false
          true  | true   | false | true
          false | true   | false | false
        end

        with_them do
          before do
            allow(user).to receive(:any_group_with_ga_ai_available?).and_return(group_with_ai_membership)
          end

          let(:cloud_connector_free_access) { free_access }
          let(:cloud_connector_user_access) { user_access }
          let(:policy) { :explain_vulnerability_with_ai }

          it { is_expected.to(allowed ? be_allowed(policy) : be_disallowed(policy)) }
        end
      end
    end

    describe 'resolve_vulnerability_with_ai' do
      let(:authorizer) { instance_double(::Gitlab::Llm::FeatureAuthorizer) }
      let(:cloud_connector_free_access) { true }
      let(:cloud_connector_user_access) { false }

      before do
        stub_feature_flags(vulnerability_resolution_ga: false)
        stub_licensed_features(security_dashboard: true, ai_features: true)
        project.add_developer(user)
        allow(::CloudConnector::AvailableServices).to receive_message_chain(:find_by_name,
          :free_access?).and_return(cloud_connector_free_access)
        allow(::CloudConnector::AvailableServices).to receive_message_chain(:find_by_name,
          :allowed_for?).and_return(cloud_connector_user_access)
        allow(::Gitlab::Llm::FeatureAuthorizer).to receive(:new).and_return(authorizer)
      end

      context 'when feature is authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(true)
        end

        it { is_expected.to be_allowed(:resolve_vulnerability_with_ai) }

        context 'when user cannot read_security_resource' do
          before do
            project.add_guest(user)
          end

          it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
        end

        context 'without finding' do
          let(:vulnerability) { build(:vulnerability, project: project) }

          it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
        end

        context 'when the vulnerability finding is not of a supported type' do
          let(:vulnerability) { create(:vulnerability, :with_finding, project: project, report_type: 'dast') }

          it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
        end

        context 'when the vulnerability finding is of a supported type' do
          let(:vulnerability) { create(:vulnerability, :with_finding, project: project, report_type: 'sast') }

          it { is_expected.to be_allowed(:resolve_vulnerability_with_ai) }
        end

        context 'when feature is not licensed' do
          before do
            stub_licensed_features(ai_features: false)
          end

          it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
        end

        describe 'cloud connector' do
          using RSpec::Parameterized::TableSyntax
          where(:free_access, :user_access, :allowed) do
            true  | true  | true
            true  | false | true
            false | true  | true
            false | false | false
          end

          with_them do
            let(:cloud_connector_free_access) { free_access }
            let(:cloud_connector_user_access) { user_access }
            let(:policy) { :resolve_vulnerability_with_ai }

            it { is_expected.to(allowed ? be_allowed(policy) : be_disallowed(policy)) }
          end
        end

        context 'when on .org or .com', :saas do
          using RSpec::Parameterized::TableSyntax
          where(:group_with_ai_membership, :free_access, :user_access, :allowed) do
            true  | true   | true  | true
            true  | false  | true  | true
            false | false  | true  | true
            false | false  | false | false
            true  | true   | false | true
            false | true   | false | false
          end

          with_them do
            before do
              allow(user).to receive(:any_group_with_ga_ai_available?).and_return(group_with_ai_membership)
            end

            let(:cloud_connector_free_access) { free_access }
            let(:cloud_connector_user_access) { user_access }
            let(:policy) { :resolve_vulnerability_with_ai }

            it { is_expected.to(allowed ? be_allowed(policy) : be_disallowed(policy)) }
          end
        end
      end

      context 'when feature is not authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(false)
        end

        it { is_expected.to be_disallowed(:resolve_vulnerability_with_ai) }
      end
    end
  end
end
