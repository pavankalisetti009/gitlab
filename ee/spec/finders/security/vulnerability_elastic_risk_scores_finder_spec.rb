# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityElasticRiskScoresFinder, :elastic_delete_by_query, feature_category: :vulnerability_management do
  let_it_be(:group) { create(:group) }
  let_it_be_with_reload(:project_1) { create(:project, namespace: group) }
  let_it_be_with_reload(:project_2) { create(:project, namespace: group) }
  let_it_be_with_reload(:project_3) { create(:project, namespace: group) }

  let_it_be(:low_vulnerability) do
    create(:vulnerability, :with_finding_risk_score, :detected, severity: :low, project: project_1)
  end

  let_it_be(:medium_vulnerability) do
    create(:vulnerability, :with_finding_risk_score, :detected, severity: :medium, project: project_2)
  end

  let_it_be(:high_vulnerability) do
    create(:vulnerability, :with_finding_risk_score, :confirmed, severity: :high, project: project_1)
  end

  let_it_be(:critical_vulnerability) do
    create(:vulnerability, :with_finding_risk_score, :confirmed, severity: :critical, project: project_2)
  end

  let_it_be(:inactive_vulnerability_1) do
    create(:vulnerability, :with_finding_risk_score, :resolved, severity: :low, project: project_1)
  end

  let_it_be(:inactive_vulnerability_2) do
    create(:vulnerability, :with_finding_risk_score, :dismissed, severity: :low, project: project_2)
  end

  let_it_be(:active_vulnerabilities) do
    [low_vulnerability, medium_vulnerability, high_vulnerability, critical_vulnerability]
  end

  let_it_be(:inactive_vulnerabilities) { [inactive_vulnerability_1, inactive_vulnerability_2] }
  let_it_be(:vulnerabilities) { active_vulnerabilities + inactive_vulnerabilities }

  let(:params) { {} }

  subject(:execute) { described_class.new(vulnerable, params).execute }

  before do
    stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)
  end

  describe '#execute' do
    before do
      Elastic::ProcessBookkeepingService.track!(*vulnerabilities)
      ensure_elasticsearch_index!
    end

    context "when the vulnerable is a group" do
      let(:vulnerable) { group }

      it "calculates risk score for all the active vulnerabilities in the group" do
        travel_to(60.days.from_now) do
          risk_score = [1.0, total_risk_score(active_vulnerabilities)].min

          response = execute
          expect(response[:total_risk_score]).to be_within(0.005).of(risk_score)
        end
      end

      context "when grouping by projects" do
        let(:params) { { group_by: :project } }

        before do
          project_1.project_setting.update!(has_vulnerabilities: true)
          project_2.project_setting.update!(has_vulnerabilities: true)
          project_3.project_setting.update!(has_vulnerabilities: false)
        end

        it "calculates risk score for each project", :aggregate_failures do
          travel_to(60.days.from_now) do
            response = execute

            expect(response[:risk_score_by_project][project_1.id]).to be_within(0.005).of(
              [1.0, total_risk_score(project_1.vulnerabilities.active)].min)

            expect(response[:risk_score_by_project][project_2.id]).to be_within(0.005).of(
              [1.0, total_risk_score(project_2.vulnerabilities.active)].min)
          end
        end

        it "returns total count of projects with active vulnerabilties in the group" do
          response = execute
          expect(response[:total_project_count]).to eq(2)
        end

        describe "project limit" do
          before do
            stub_const("#{described_class}::REQUIRED_PROJECTS_SIZE", 1)
          end

          it "limits project buckets to REQUIRED_PROJECTS_SIZE count", :aggregate_failures do
            response = execute
            expect(response[:risk_score_by_project]&.size).to eq(1)
            expect(response[:total_project_count]).to eq(2)
          end
        end

        context "when group_vulnerability_risk_scores_by_project is disabled" do
          before do
            stub_feature_flags(group_vulnerability_risk_scores_by_project: false)
          end

          it "does not group by project", :aggregate_failures do
            expect(::Search::Elastic::VulnerabilityQueryBuilder).to receive(:build).with(
              query: nil,
              options: a_hash_including(group_risk_score_by: nil)
            ).and_call_original

            response = execute
            expect(response[:risk_score_by_project]).to be_nil
            expect(response[:total_project_count]).to be_nil
          end
        end
      end
    end

    context "when the vulnerable is a project" do
      let(:vulnerable) { project_1 }

      it "calculates risk score for all the active vulnerabilities in the project" do
        vulns = vulnerable.vulnerabilities.active
        travel_to(60.days.from_now) do
          risk_score = [1.0, total_risk_score(vulns)].min

          response = execute
          expect(response[:total_risk_score]).to be_within(0.005).of(risk_score)
        end
      end
    end

    context "when there are no active vulnerabilities" do
      let_it_be(:vulnerable) { create(:project, namespace: group) }
      let_it_be(:inactive_vuln) do
        create(:vulnerability, :with_finding_risk_score, :dismissed, severity: :low, project: vulnerable)
      end

      it "returns risk score as 0.0" do
        travel_to(60.days.from_now) do
          response = execute
          expect(response[:total_risk_score]).to eq(0)
        end
      end
    end
  end

  private

  def total_risk_score(vulnerabilities)
    risk_scores_sum = vulnerabilities.sum do |vulnerability|
      Vulnerabilities::RiskScore.from_finding(vulnerability.findings.first).score
    end
    created_at_sum = vulnerabilities.sum { |vuln| vuln.created_at.to_f * 1000 }
    vulnerabilities_count = vulnerabilities.size

    Vulnerabilities::AggregateRiskScore.score(
      risk_scores_sum: risk_scores_sum,
      created_at_sum: created_at_sum,
      active_vulnerabilities_count: vulnerabilities_count
    )
  end
end
