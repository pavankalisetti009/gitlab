# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::SbomScanUploader, feature_category: :software_composition_analysis do
  let(:sbom_scan) { create(:sbom_scan) }
  let(:uploader) { described_class.new(sbom_scan, :sbom_file) }
  let(:file) do
    fixture_file_upload('ee/spec/fixtures/security/vulnerability_scanning/sbom_scans/sbom.json', 'application/json')
  end

  subject { uploader }

  describe '.generate_final_store_path' do
    let(:project_id) { 123 }
    let(:build_id) { 456 }
    let(:current_time) { Time.zone.parse('2024-06-15 14:30:00 UTC') }
    let(:uuid) { 'test-uuid-1234' }
    let(:expected_file_path) do
      hashed_path = Gitlab::HashedPath.new(
        current_time.strftime('%Y_%m_%d'),
        build_id,
        Digest::SHA2.hexdigest(uuid),
        root_hash: project_id
      ).to_s

      File.join('sbom_scans', hashed_path, 'sbom.json')
    end

    before do
      allow(Time).to receive(:current).and_return(current_time)
      allow(SecureRandom).to receive(:uuid).and_return(uuid)
    end

    subject(:generated_path) { described_class.generate_final_store_path(project_id, build_id) }

    it 'generates the expected file path' do
      expect(generated_path).to eq(expected_file_path)
    end
  end

  describe '.hashed_path' do
    let(:project_id) { 123 }
    let(:build_id) { 456 }
    let(:model_identifier) { 789 }
    let(:current_time) { Time.zone.parse('2024-06-15 14:30:00 UTC') }
    let(:created_at) { Time.zone.parse('2024-06-10 10:00:00 UTC') }

    before do
      allow(Time).to receive(:current).and_return(current_time)
    end

    subject(:hashed_path) do
      described_class.hashed_path(project_id, build_id, model_identifier, created_at: created_at)
    end

    context 'when created_at is provided' do
      it 'uses the provided created_at timestamp' do
        expected_path = Gitlab::HashedPath.new(
          created_at.strftime('%Y_%m_%d'),
          build_id,
          model_identifier,
          root_hash: project_id
        ).to_s

        expect(hashed_path).to eq(expected_path)
      end
    end

    context 'when created_at is not provided' do
      let(:created_at) { nil }

      it 'uses Time.current' do
        expected_path = Gitlab::HashedPath.new(
          current_time.strftime('%Y_%m_%d'),
          build_id,
          model_identifier,
          root_hash: project_id
        ).to_s

        expect(hashed_path).to eq(expected_path)
      end
    end
  end

  describe '#dynamic_segment' do
    let(:sbom_scan) { create(:sbom_scan) }
    let(:uploader) { described_class.new(sbom_scan, :result_file) }
    let(:created_at) { Time.zone.parse('2024-06-10 10:00:00 UTC') }

    before do
      sbom_scan.update!(created_at: created_at)
    end

    it 'uses the model created_at timestamp for path generation' do
      expected_path = File.join(
        'sbom_scans',
        described_class.hashed_path(
          sbom_scan.project_id,
          sbom_scan.build_id,
          sbom_scan.id,
          created_at: created_at
        )
      )

      expect(uploader.send(:dynamic_segment)).to eq(expected_path)
    end

    it 'generates consistent paths regardless of current time' do
      path_on_day_1 = nil
      path_on_day_2 = nil

      travel_to(Time.zone.parse('2024-06-10 14:00:00 UTC')) do
        path_on_day_1 = uploader.send(:dynamic_segment)
      end

      travel_to(Time.zone.parse('2024-06-12 14:00:00 UTC')) do
        path_on_day_2 = uploader.send(:dynamic_segment)
      end

      expect(path_on_day_1).to eq(path_on_day_2)
    end
  end

  context 'when object store is REMOTE' do
    before do
      stub_uploads_object_storage
    end

    include_context 'with storage', described_class::Store::REMOTE

    describe '.default_store' do
      it 'returns remote store' do
        expect(described_class.default_store).to eq(ObjectStorage::Store::REMOTE)
      end
    end

    it_behaves_like "builds correct paths",
      store_dir: %r{\Asbom_scans/\h{2}/\h{2}/\h{64}/\d{4}_\d{1,2}_\d{1,2}/\d+/\d+\z},
      cache_dir: %r{uploads/-/system/tmp/cache\z},
      work_dir: %r{uploads/-/system/tmp/work\z}
  end

  context 'when file is stored in valid local_path' do
    include_context 'with storage', described_class::Store::LOCAL

    describe '.default_store' do
      it 'returns local store' do
        expect(described_class.default_store).to eq(ObjectStorage::Store::LOCAL)
      end
    end

    it_behaves_like "builds correct paths",
      store_dir: %r{\Auploads/-/system/sbom_scans/\h{2}/\h{2}/\h{64}/\d{4}_\d{1,2}_\d{1,2}/\d+/\d+\z},
      cache_dir: %r{uploads/-/system/tmp/cache\z},
      work_dir: %r{uploads/-/system/tmp/work\z}
  end
end
