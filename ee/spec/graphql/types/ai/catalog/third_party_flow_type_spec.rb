# frozen_string_literal: true

require 'spec_helper'

RSpec.describe GitlabSchema.types['AiCatalogThirdPartyFlowVersion'], feature_category: :system_access do
  let_it_be(:current_user) { create(:user) }
  let_it_be(:project) { create(:project, maintainers: [current_user]) }
  let_it_be(:item) { create(:ai_catalog_item, :third_party_flow, project: project, public: true) }

  specify { expect(described_class.graphql_name).to eq('AiCatalogThirdPartyFlowVersion') }
  specify { expect(described_class.interfaces).to include(::Types::Ai::Catalog::VersionInterface) }

  describe '#definition' do
    let(:query) do
      %(
      query {
        aiCatalogItem(id: "#{item.to_global_id}") {
          latestVersion {
            ... on AiCatalogThirdPartyFlowVersion {
             definition
            }
          }
        }
      }
      )
    end

    let(:returned_definition) { subject.dig('data', 'aiCatalogItem', 'latestVersion', 'definition') }

    subject { GitlabSchema.execute(query, context: { current_user: }).as_json }

    context 'when yaml_definition is present' do
      before do
        item.latest_version.definition['yaml_definition'] = 'test'
        item.latest_version.save!
      end

      it 'returns the yaml_definition' do
        expect(returned_definition).to match('test')
      end
    end

    context 'when yaml_definition is not present' do
      let(:data) { graphql_data_at(:ai_catalog_item) }

      before do
        item.latest_version.definition.delete('yaml_definition')
        item.latest_version.definition['image'] = 'some_new_image:22'
        item.latest_version.save!
      end

      it 'returns the definition generated by converting the definition to YAML' do
        expect(YAML.load(returned_definition)).to match(a_hash_including('image' => 'some_new_image:22'))
      end
    end
  end
end
