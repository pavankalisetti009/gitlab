# frozen_string_literal: true

require 'spec_helper'
RSpec.describe GitlabSchema.types['Vulnerability'], feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:user) { create(:user) }
  let_it_be_with_reload(:vulnerability) { create(:vulnerability, :with_remediation, project: project) }
  let(:vulnerabilities) { graphql_response.dig('data', 'project', 'vulnerabilities', 'nodes') }
  let(:query) do
    %(
      query {
        project(fullPath: "#{project.full_path}") {
          vulnerabilities {
            nodes {
              #{query_field}
            }
          }
        }
      }
    )
  end

  let_it_be(:fields) do
    %i[
      userPermissions
      id
      uuid
      title
      description
      descriptionHtml
      solution
      user_notes_count
      state
      severity
      severity_overrides
      latest_security_report_finding
      cve_enrichment
      report_type
      resolved_on_default_branch
      vulnerability_path
      name
      web_url
      location
      scanner
      primary_identifier
      identifiers
      project
      issueLinks
      detected_at
      confirmed_at
      resolved_at
      dismissed_at
      updated_at
      notes
      external_issue_links
      links
      dependencies
      has_remediations
      false_positive
      state_comment
      merge_request
      merge_requests
      discussions
      confirmed_by
      resolved_by
      dismissed_by
      details
      commenters
      state_transitions
      dismissal_reason
      present_on_default_branch
      cvss
      aiResolutionAvailable
      aiResolutionEnabled
      representationInformation
      reachability
      archivalInformation
      findingTokenStatus
      initialDetectedPipeline
      latestDetectedPipeline
      flags
      latestFlag
      policyViolations
    ]
  end

  RSpec.shared_examples "N+1 queries" do |single_query_count|
    it 'avoids N+1 database queries', :request_store do
      stub_env('GITALY_DISABLE_REQUEST_LIMITS', 'true')
      GitlabSchema.execute(query, context: { current_user: user })

      control_count = ActiveRecord::QueryRecorder.new { GitlabSchema.execute(query, context: { current_user: user }) }.count
      expect(control_count <= single_query_count).to be_truthy

      create_three_vulnerabilities = create_list(:vulnerability, 3, :with_finding, :with_state_transition, :with_remediation, project: project)
      create_three_vulnerabilities.each do |v|
        occurrence = create(:sbom_occurrence, reachability: :in_use)
        create(:sbom_occurrences_vulnerability, vulnerability: v, occurrence: occurrence)

        create(:vulnerabilities_external_issue_link, vulnerability: v, author: user)
        create(:finding_link, finding: v.finding)
        create(:policy_dismissal, :preserved, project: project, security_findings_uuids: [v.finding.uuid])
      end

      expect { GitlabSchema.execute(query, context: { current_user: user }) }.not_to exceed_query_limit(single_query_count)
    end
  end

  before do
    stub_licensed_features(security_dashboard: true, sast_fp_reduction: true, dependency_scanning: true)

    project.add_developer(user)
  end

  subject(:graphql_response) { GitlabSchema.execute(query, context: { current_user: user }).as_json }

  it { expect(described_class.interfaces).to include(Types::TodoableInterface) }
  it { expect(described_class).to have_graphql_fields(fields) }
  it { expect(described_class).to require_graphql_authorizations(:read_vulnerability) }

  describe 'vulnerability_path' do
    let(:query_field) { 'vulnerabilityPath' }

    it "is the path to the vulnerability's detail page" do
      expect(vulnerabilities.first['vulnerabilityPath']).to match(%r{^/#{project.full_path}/-/security/vulnerabilities/[0-9]+})
    end
  end

  describe 'stateComment' do
    let(:query_field) { 'stateComment' }
    let(:state_comment) { subject.dig(*%w[data project vulnerabilities nodes]).first["stateComment"] }

    let_it_be(:state_transition) { create(:vulnerability_state_transition, :from_detected, :to_dismissed, vulnerability: vulnerability) }

    it 'returns the comment for the latest state transition' do
      expect(state_comment).to eq(state_transition.comment)
    end

    context 'N+1 queries' do
      single_query_count = 14

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'web_url' do
    let(:query_field) { 'webUrl' }

    it "is the URL to the vulnerability's detail page" do
      vulnerabilities = subject.dig('data', 'project', 'vulnerabilities', 'nodes')

      expect(vulnerabilities.first['webUrl']).to match(%r{^http://localhost/#{project.full_path}/-/security/vulnerabilities/[0-9]+})
    end
  end

  describe 'has_remediations', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/534855' do
    let(:query_field) { 'hasRemediations' }

    context 'N+1 queries' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'false_positive' do
    let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_findings, project: project) }
    let(:query_field) { 'falsePositive' }

    context 'when the vulnerability has a false-positive flag' do
      before do
        create(:vulnerabilities_flag, finding: vulnerability_with_finding.finding)
      end

      it 'returns true for false positive field', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/338073' do
        expect(vulnerabilities.first['falsePositive']).to be(true)
      end
    end

    context 'when the license is missing' do
      before do
        stub_licensed_features(security_dashboard: true, sast_fp_reduction: false)
      end

      it 'returns nil' do
        expect(vulnerabilities.first['falsePositive']).to be_nil
      end
    end

    context 'when the vulnerability does not have any false positive flag' do
      it 'returns false for false-positive field' do
        expect(vulnerabilities.first['falsePositive']).to be(false)
      end
    end
  end

  describe '#description' do
    let_it_be_with_reload(:vulnerability_with_finding) { create(:vulnerability, :with_findings, project: project) }
    let(:query_field) { 'description' }

    context 'when the vulnerability description field is populated' do
      it 'returns the description for the vulnerability' do
        expect(vulnerabilities.first['description']).to eq(vulnerability_with_finding.description)
      end
    end

    context 'when the vulnerability description field is empty' do
      before do
        vulnerability_with_finding.description = nil
        vulnerability_with_finding.save!
      end

      it 'returns the description for the vulnerability finding' do
        expect(vulnerabilities.first['description']).to eq(vulnerability_with_finding.finding.description)
      end
    end
  end

  describe '#descriptionHtml' do
    let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_findings, project: project) }
    let(:query_field) { 'descriptionHtml' }

    context 'when the vulnerability descriptionHtml field is populated' do
      it 'returns the description for the vulnerability' do
        expect(vulnerabilities.first['descriptionHtml']).to eq(vulnerability_with_finding.description_html)
      end
    end

    context 'when the vulnerability descriptionHtml field is empty' do
      before do
        vulnerability_with_finding.description_html = nil
        vulnerability_with_finding.save!
      end

      it 'returns the descriptionHtml for the vulnerability finding' do
        expect(vulnerabilities.first['descriptionHtml']).to eq(vulnerability_with_finding.description_html)
      end
    end
  end

  describe "#primary_identifier" do
    let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }
    let(:query_field) { 'primaryIdentifier { externalId }' }

    it "returns the primary identifier" do
      expect(vulnerabilities.first['primaryIdentifier']['externalId']).to eq(vulnerability.finding.primary_identifier.external_id)
    end

    context "N+1 issues", quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/546298' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe '#identifiers' do
    let(:project) { create(:project) }
    let(:query_field) { 'identifiers { externalId }' }
    let(:identifiers) { vulnerabilities.flat_map { |v| v['identifiers'] } }

    context 'when the vulnerability is missing identifiers' do
      before do
        vulnerability = create(:vulnerability, :with_finding, project: project)
        vulnerability.findings.update_all(vulnerability_id: nil)
      end

      it 'defaults to an empty array' do
        expect(identifiers).to eq []
      end
    end
  end

  describe 'dismissal_reason' do
    let(:query_field) { 'dismissalReason' }
    let_it_be(:state_transition) { create(:vulnerability_state_transition, :from_detected, :to_dismissed, :used_in_tests, vulnerability: vulnerability) }

    context 'when vulnerability_read is present' do
      before do
        # This simulates Vulnerabilities::DismissService
        vulnerability.update!(state: :dismissed, dismissed_by_id: user.id, dismissed_at: Time.current)
        vulnerability.vulnerability_read.update!(dismissal_reason: state_transition.dismissal_reason)
      end

      it 'is populated from Vulnerabilities::Read object' do
        expect(vulnerabilities.first['dismissalReason']).to eq("USED_IN_TESTS")
      end
    end

    context 'when vulnerability_read is nil' do
      before do
        allow_next_instance_of(::Types::VulnerabilityType) do |instance|
          allow(instance).to receive(:object).and_return(vulnerability)
        end

        allow(vulnerability).to receive(:vulnerability_read).and_return(nil)
      end

      it 'returns nil and does not raise an error' do
        expect(vulnerabilities.first['dismissalReason']).to be_nil
      end
    end
  end

  describe 'merge_request' do
    let(:query_field) { 'mergeRequest { id }' }

    subject(:returned_mr_id) { vulnerabilities.first['mergeRequest']['id'] }

    context 'with a single merge request' do
      let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
      let_it_be(:merge_request) { create(:merge_request, source_project: project, description: 'Description for test') }

      before do
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: merge_request)
      end

      it 'returns the merge request through merge_request_link' do
        expect(returned_mr_id).to eq(merge_request.to_global_id.uri.to_s)
      end
    end

    context 'with multiple merge requests' do
      let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
      let_it_be(:older_merge_request) { create(:merge_request, source_project: project, created_at: 1.day.ago, source_branch: 'older-feature') }
      let_it_be(:newer_merge_request) { create(:merge_request, source_project: project, created_at: 1.hour.ago, source_branch: 'newer-feature') }

      before do
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: older_merge_request)
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: newer_merge_request)
      end

      it 'returns the oldest merge request for backward compatibility' do
        expect(returned_mr_id).to eq(older_merge_request.to_global_id.uri.to_s)
      end
    end

    context 'with merge requests having the same created_at timestamp' do
      let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
      let_it_be(:same_time) { 2.hours.ago }
      let_it_be(:mr_a) { create(:merge_request, source_project: project, created_at: same_time, source_branch: 'branch-a') }
      let_it_be(:mr_b) { create(:merge_request, source_project: project, created_at: same_time, source_branch: 'branch-b') }

      before do
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: mr_a)
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: mr_b)
      end

      it 'returns the merge request with the smaller ID as tiebreaker' do
        mr_with_smaller_id = [mr_a, mr_b].min_by(&:id)
        expect(returned_mr_id).to eq(mr_with_smaller_id.to_global_id.uri.to_s)
      end
    end
  end

  describe 'merge_requests' do
    let(:query_field) { 'mergeRequests { nodes { id } }' }

    subject(:returned_mr_ids) { vulnerabilities.first['mergeRequests']['nodes'].pluck('id') }

    context 'with multiple merge requests' do
      let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
      let_it_be(:older_merge_request) { create(:merge_request, source_project: project, created_at: 1.day.ago, source_branch: 'older-branch') }
      let_it_be(:newer_merge_request) { create(:merge_request, source_project: project, created_at: 1.hour.ago, source_branch: 'newer-branch') }

      before do
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: older_merge_request)
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: newer_merge_request)
      end

      it 'returns all merge requests ordered by creation date' do
        expect(returned_mr_ids).to eq([
          older_merge_request.to_global_id.uri.to_s,
          newer_merge_request.to_global_id.uri.to_s
        ])
      end
    end

    context 'with merge requests having the same created_at timestamp' do
      let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
      let_it_be(:same_time) { 2.hours.ago }
      let_it_be(:mr_a) { create(:merge_request, source_project: project, created_at: same_time, source_branch: 'branch-a') }
      let_it_be(:mr_b) { create(:merge_request, source_project: project, created_at: same_time, source_branch: 'branch-b') }

      before do
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: mr_a)
        create(:vulnerabilities_merge_request_link, vulnerability: vulnerability_with_finding, merge_request: mr_b)
      end

      it 'returns merge requests ordered by ID as tiebreaker when created_at is the same' do
        mrs_ordered_by_id = [mr_a, mr_b].sort_by(&:id)
        expected_ids = mrs_ordered_by_id.map { |mr| mr.to_global_id.uri.to_s }
        expect(returned_mr_ids).to eq(expected_ids)
      end
    end

    context 'when no merge requests are linked' do
      let_it_be(:vulnerability_without_mrs) { create(:vulnerability, :with_finding, project: project) }
      let(:vulnerability_with_finding) { vulnerability_without_mrs }

      it 'returns an empty array' do
        expect(returned_mr_ids).to be_empty
      end
    end

    context 'N+1 queries',
      quarantine: 'https://gitlab.com/gitlab-org/quality/test-failure-issues/-/issues/5340' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'present_on_default_branch' do
    let_it_be(:vulnerability_with_finding) { create(:vulnerability, :with_finding, project: project) }
    let(:query_field) { 'presentOnDefaultBranch' }

    context 'when vulnerability is present on default branch' do
      it 'returns true for presentOnDefaultBranch field' do
        expect(vulnerabilities.first['presentOnDefaultBranch']).to be(true)
      end
    end

    context 'when vulnerability is not present on default branch' do
      before do
        vulnerability_with_finding.update!(present_on_default_branch: false)
      end

      it 'returns false for presentOnDefaultBranch field' do
        expect(vulnerabilities.first['presentOnDefaultBranch']).to be(false)
      end
    end
  end

  describe 'cvss' do
    let(:query_field) { 'cvss { vendor vector version baseScore overallScore severity }' }

    subject(:cvss) { vulnerabilities.first['cvss'] }

    before do
      vulnerability.update!(cvss: cvss_data)
    end

    context 'when vulnerability has cvss data' do
      let(:cvss_data) { [{ vendor: 'GitLab', vector: 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N' }] }

      it 'returns all attributes' do
        data = cvss.first

        expect(data['vendor']).to eq('GitLab')
        expect(data['vector']).to eq('CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N')
        expect(data['version']).to eq(3.1)
        expect(data['baseScore']).to eq(3.8)
        expect(data['overallScore']).to eq(3.8)
        expect(data['severity']).to eq('LOW')
      end
    end

    context 'when vulnerability does not have cvss data' do
      let(:cvss_data) { [] }

      it 'returns an empty array' do
        expect(cvss).to be_empty
      end
    end
  end

  describe 'aiResolutionAvailable' do
    let(:query_field) { 'aiResolutionAvailable' }

    subject { vulnerabilities.first['aiResolutionAvailable'] }

    context 'when the vulnerability is of type SAST' do
      it { is_expected.to be true }
    end

    context 'when the vulnerability is not of type SAST' do
      before do
        vulnerability.finding.update!(report_type: 'dast')
      end

      it { is_expected.to be false }
    end
  end

  describe 'aiResolutionEnabled' do
    let(:query_field) { 'aiResolutionEnabled' }

    subject { vulnerabilities.first['aiResolutionEnabled'] }

    context 'when the vulnerability is of a supported CWE' do
      before do
        vulnerability.vulnerability_read.update!(has_vulnerability_resolution: true)
      end

      it { is_expected.to be true }
    end

    context 'when the vulnerability is not of a supported CWE' do
      before do
        vulnerability.vulnerability_read.update!(has_vulnerability_resolution: false)
      end

      it { is_expected.to be false }
    end

    context 'when vulnerability_read is nil' do
      before do
        allow_next_instance_of(::Types::VulnerabilityType) do |instance|
          allow(instance).to receive(:object).and_return(vulnerability)
        end

        allow(vulnerability).to receive(:vulnerability_read).and_return(nil)
      end

      it { is_expected.to be_nil }
    end
  end

  describe 'reachability' do
    let(:query_field) { 'reachability' }

    subject { vulnerabilities.first['reachability'] }

    it { is_expected.to be_nil }

    context 'with report type set to dependency scanning' do
      let_it_be_with_reload(:vulnerability) { create(:vulnerability, :with_remediation, project: project, report_type: :dependency_scanning) }

      it { is_expected.to eq 'UNKNOWN' }

      %i[in_use not_found].each do |reachability|
        context "when the vulnerability has related sbom_occurrences record with reachability set to `#{reachability}`" do
          let_it_be(:occurrence) { create(:sbom_occurrence, reachability: reachability) }
          let_it_be(:sbom_occurrences_vulnerability) { create(:sbom_occurrences_vulnerability, vulnerability: vulnerability, occurrence: occurrence) }

          it { is_expected.to eq reachability.to_s.upcase }
        end
      end
    end

    context 'N+1 queries', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/546294' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'external_issue_links' do
    let(:query_field) { 'externalIssueLinks {edges{node{id}}}' }

    let_it_be(:external_issue_link) { create(:vulnerabilities_external_issue_link, vulnerability: vulnerability, author: user) }

    it 'returns the external issue link' do
      expect(vulnerabilities.first.dig('externalIssueLinks', 'edges').first.dig('node', 'id')).to eq(external_issue_link.to_global_id.to_s)
    end

    context 'N+1 queries', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/546300' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'links' do
    let(:query_field) { 'links {name}' }

    let_it_be(:finding_link) { create(:finding_link, finding: vulnerability.finding) }

    it 'returns the finding link' do
      expect(vulnerabilities.first['links'].first['name']).to eq(finding_link.name)
    end

    context 'N+1 queries', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/547390' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe '.authorization_scopes' do
    it 'includes :ai_workflows' do
      expect(described_class.authorization_scopes).to include(:ai_workflows)
    end
  end

  describe 'field scopes' do
    {
      'id' => %i[api read_api ai_workflows],
      'title' => %i[api read_api ai_workflows],
      'description' => %i[api read_api ai_workflows],
      'state' => %i[api read_api ai_workflows],
      'severity' => %i[api read_api ai_workflows],
      'reportType' => %i[api read_api ai_workflows],
      'resolvedOnDefaultBranch' => %i[api read_api ai_workflows],
      'location' => %i[api read_api ai_workflows],
      'scanner' => %i[api read_api ai_workflows],
      'identifiers' => %i[api read_api ai_workflows],
      'project' => %i[api read_api ai_workflows],
      'confirmedAt' => %i[api read_api ai_workflows],
      'dismissedAt' => %i[api read_api ai_workflows],
      'updatedAt' => %i[api read_api ai_workflows],
      'dismissedBy' => %i[api read_api ai_workflows]
    }.each do |field, scopes|
      it "includes the correct scopes for #{field}" do
        expect(described_class.fields[field].instance_variable_get(:@scopes)).to include(*scopes)
      end
    end
  end

  describe 'initialDetectedPipeline' do
    let(:query_field) { 'initialDetectedPipeline { id }' }

    context 'when there is an initial pipeline' do
      let_it_be(:initial_pipeline) { create(:ci_pipeline, project: project) }
      let_it_be(:vulnerability_with_initial_pipeline) do
        finding = create(:vulnerabilities_finding, project: project, pipeline: initial_pipeline)
        create(:vulnerability, project: project, findings: [finding])
      end

      it 'returns the pipeline in which the vulnerability was first detected' do
        expect(vulnerabilities.first['initialDetectedPipeline']['id']).to eq(initial_pipeline.to_global_id.to_s)
      end
    end

    context 'when there is no initial pipeline' do
      it 'returns nil' do
        expect(vulnerabilities.first['initialDetectedPipeline']).to be_nil
      end
    end

    context 'N+1 queries', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/549933' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'latestDetectedPipeline' do
    let(:query_field) { 'latestDetectedPipeline { id }' }
    let_it_be(:latest_pipeline) { create(:ci_pipeline, project: project) }

    before do
      vulnerability.finding.update!(latest_pipeline_id: latest_pipeline.id)
    end

    it 'returns the pipeline in which the vulnerability was last detected' do
      expect(vulnerabilities.first['latestDetectedPipeline']['id']).to eq(latest_pipeline.to_global_id.to_s)
    end

    context 'when there is no latest pipeline' do
      before do
        vulnerability.finding.update!(latest_pipeline_id: nil)
      end

      it 'returns nil' do
        expect(vulnerabilities.first['latestDetectedPipeline']).to be_nil
      end
    end

    context 'N+1 queries', quarantine: 'https://gitlab.com/gitlab-org/gitlab/-/issues/550360' do
      single_query_count = 11

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'flags' do
    let(:query_field) { 'uuid, flags { nodes { id origin description confidenceScore status createdAt updatedAt } }' }
    let_it_be(:vulnerability_with_flags) { create(:vulnerability, :with_finding, project: project) }
    let_it_be(:flag_1) do
      create(:vulnerabilities_flag,
        finding: vulnerability_with_flags.finding,
        origin: 'post analyzer 1',
        description: 'First flag description',
        confidence_score: 0.8,
        status: :not_started)
    end

    let_it_be(:flag_2) do
      create(:vulnerabilities_flag,
        finding: vulnerability_with_flags.finding,
        origin: 'post analyzer 2',
        description: 'Second flag description',
        confidence_score: 0.9,
        status: :in_progress)
    end

    subject { vulnerabilities.find { |v| v['uuid'] == vulnerability_with_flags.finding_uuid }['flags']['nodes'] }

    context 'when vulnerability has associated flags' do
      it 'returns all flags with their attributes' do
        expect(subject.size).to eq(2)

        flag_data = subject.find { |f| f['origin'] == 'post analyzer 1' }
        expect(flag_data['id']).to eq(flag_1.to_global_id.to_s)
        expect(flag_data['origin']).to eq('post analyzer 1')
        expect(flag_data['description']).to eq('First flag description')
        expect(flag_data['confidenceScore']).to eq(0.8)
        expect(flag_data['status']).to eq('NOT_STARTED')
        expect(flag_data['createdAt']).to be_present
        expect(flag_data['updatedAt']).to be_present

        flag_data_2 = subject.find { |f| f['origin'] == 'post analyzer 2' }
        expect(flag_data_2['id']).to eq(flag_2.to_global_id.to_s)
        expect(flag_data_2['origin']).to eq('post analyzer 2')
        expect(flag_data_2['description']).to eq('Second flag description')
        expect(flag_data_2['confidenceScore']).to eq(0.9)
        expect(flag_data_2['status']).to eq('IN_PROGRESS')
      end
    end

    context 'when vulnerability has no associated flags' do
      let_it_be(:vulnerability_without_flags) do
        create(:vulnerability, :with_finding, project: project)
      end

      it 'returns empty array' do
        vuln = vulnerabilities.find { |v| v['uuid'] == vulnerability_without_flags.finding_uuid }
        expect(vuln['flags']['nodes']).to be_empty
      end
    end

    context 'when vulnerability has no finding' do
      let_it_be(:vulnerability_without_finding) do
        create(:vulnerability, project: project)
      end

      it 'returns empty array' do
        vuln = vulnerabilities.find { |v| v['uuid'] == vulnerability_without_finding.finding_uuid }
        expect(vuln).to be_nil
      end
    end

    context 'N+1 queries' do
      single_query_count = 15

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'latestFlag' do
    let(:query_field) { 'uuid, latestFlag { id origin description confidenceScore status createdAt updatedAt }' }
    let_it_be(:vulnerability_with_flags) { create(:vulnerability, :with_finding, project: project) }
    let_it_be(:older_flag) do
      create(:vulnerabilities_flag,
        finding: vulnerability_with_flags.finding,
        origin: 'post analyzer old',
        description: 'Older flag description',
        confidence_score: 0.7,
        status: :not_started,
        created_at: 2.days.ago)
    end

    let_it_be(:latest_flag) do
      create(:vulnerabilities_flag,
        finding: vulnerability_with_flags.finding,
        origin: 'post analyzer latest',
        description: 'Latest flag description',
        confidence_score: 0.95,
        status: :detected_as_fp,
        created_at: 1.day.ago)
    end

    subject { vulnerabilities.find { |v| v['uuid'] == vulnerability_with_flags.finding_uuid }['latestFlag'] }

    context 'when vulnerability has associated flags' do
      it 'returns the latest flag' do
        expect(subject['id']).to eq(latest_flag.to_global_id.to_s)
        expect(subject['origin']).to eq('post analyzer latest')
        expect(subject['description']).to eq('Latest flag description')
        expect(subject['confidenceScore']).to eq(0.95)
        expect(subject['status']).to eq('DETECTED_AS_FP')
        expect(subject['createdAt']).to be_present
        expect(subject['updatedAt']).to be_present
      end
    end

    context 'when vulnerability has single flag' do
      let_it_be(:vulnerability_with_single_flag) { create(:vulnerability, :with_finding, project: project) }
      let_it_be(:single_flag) do
        create(:vulnerabilities_flag,
          finding: vulnerability_with_single_flag.finding,
          origin: 'single analyzer',
          description: 'Single flag description',
          confidence_score: 0.85,
          status: :detected_as_not_fp)
      end

      it 'returns the single flag' do
        vuln = vulnerabilities.find { |v| v['uuid'] == vulnerability_with_single_flag.finding_uuid }
        latest_flag_data = vuln['latestFlag']

        expect(latest_flag_data['id']).to eq(single_flag.to_global_id.to_s)
        expect(latest_flag_data['origin']).to eq('single analyzer')
        expect(latest_flag_data['description']).to eq('Single flag description')
        expect(latest_flag_data['confidenceScore']).to eq(0.85)
        expect(latest_flag_data['status']).to eq('DETECTED_AS_NOT_FP')
      end
    end

    context 'when vulnerability has no associated flags' do
      let_it_be(:vulnerability_without_flags) do
        create(:vulnerability, :with_finding, project: project)
      end

      it 'returns nil' do
        expect(vulnerabilities.last['latestFlag']).to be_nil
      end
    end

    context 'when vulnerability has no finding' do
      let_it_be(:vulnerability_without_finding) do
        create(:vulnerability, project: project)
      end

      it 'returns nil' do
        expect(vulnerabilities.last['latestFlag']).to be_nil
      end
    end

    context 'N+1 queries' do
      single_query_count = 15

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'latestSecurityReportFinding' do
    let(:query_field) { 'uuid, latestSecurityReportFinding {uuid, severity}' }
    let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
    let_it_be(:security_scan) { create(:security_scan, pipeline: pipeline) }
    let_it_be(:security_finding) do
      create(:security_finding,
        scan: security_scan,
        uuid: vulnerability.finding.uuid,
        severity: :high)
    end

    before do
      allow(Ability).to receive(:allowed?).and_call_original
      allow(Ability).to receive(:allowed?).with(user, :read_security_resource, anything).and_return(true)
    end

    subject { vulnerabilities.first['latestSecurityReportFinding'] }

    context 'when vulnerability has associated security findings' do
      it 'returns the latest security finding' do
        expect(subject['uuid']).to eq(security_finding.uuid)
      end
    end

    context 'when vulnerability has no associated security findings' do
      let_it_be(:vulnerability_without_security_finding) do
        create(:vulnerability, :with_finding, project: project)
      end

      it 'returns nil' do
        vuln = vulnerabilities.find { |v| v['uuid'] == vulnerability_without_security_finding.finding_uuid }
        expect(vuln['latestSecurityReportFinding']).to be_nil
      end
    end

    context 'when vulnerability has multiple security findings' do
      let_it_be(:new_security_finding) do
        create(:security_finding,
          uuid: vulnerability.finding.uuid,
          severity: :medium,
          scan: create(:security_scan, latest: true)
        )
      end

      it 'returns the finding from the most recent finding' do
        expect(subject['uuid']).to eq(new_security_finding.uuid)
        expect(subject['severity'].capitalize).to eq(new_security_finding.severity.capitalize)
      end
    end

    context 'N+1 queries' do
      single_query_count = 12

      it_behaves_like "N+1 queries", single_query_count
    end
  end

  describe 'policyViolations' do
    let(:query_field) { 'policyViolations' }

    subject { vulnerabilities.first['policyViolations'] }

    context 'when the vulnerability has related policy dismissals' do
      let_it_be(:policy_dismissal) { create(:policy_dismissal, :preserved, project: project, security_findings_uuids: [vulnerability.finding.uuid]) }

      it { is_expected.to eq 'DISMISSED_IN_MR' }
    end

    context 'when the vulnerability has no related policy dismissals' do
      it { is_expected.to be_nil }
    end

    context 'N+1 queries' do
      single_query_count = 11
      number_of_vulnerabilities = 3
      multiple_queries_count = single_query_count + (number_of_vulnerabilities * 2)

      it_behaves_like "N+1 queries", single_query_count, multiple_queries_count
    end
  end
end
