# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::ProcessSbomScanWorker, feature_category: :software_composition_analysis do
  let_it_be(:project) { create(:project) }
  let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:job) { create(:ci_build, pipeline: pipeline) }

  let(:worker) { described_class.new }
  let(:sbom_scan) { create(:sbom_scan, :created, :with_sbom_file, build: job, project: project) }

  subject(:perform_worker) { worker.perform(sbom_scan.id) }

  it_behaves_like 'an idempotent worker' do
    let(:job_args) { [sbom_scan.id] }
  end

  describe '#perform' do
    context 'when sbom scan does not exist' do
      subject(:perform_worker) { worker.perform(non_existing_record_id) }

      it 'does not process the sbom scan and logs an error', :aggregate_failures do
        expect(Security::VulnerabilityScanning::ProcessSbomScanService).not_to receive(:new)
        expect(Gitlab::AppLogger).to receive(:error)
          .with(message: "Couldn't find Sbom Scan, skipping processing", sbom_scan_id: non_existing_record_id)

        perform_worker
      end
    end

    context 'when sbom scan exists and is in :created state' do
      it 'successfully processes the sbom scan' do
        expect_next_instance_of(Security::VulnerabilityScanning::ProcessSbomScanService, sbom_scan) do |service|
          expect(service).to receive(:execute)
        end

        expect { perform_worker }.not_to raise_error
      end
    end

    context 'when sbom scan exists but is not in :created state' do
      before do
        sbom_scan.update!(status: 1)
      end

      it 'does nothing', :aggregate_failures do
        expect(Security::VulnerabilityScanning::ProcessSbomScanService).not_to receive(:new)
        expect(described_class).not_to receive(:perform_in)
        expect(Gitlab::AppLogger).to receive(:error)
          .with(message: "Sbom Scan is not in created state, skipping processing", sbom_scan_id: sbom_scan.id,
            sbom_scan_status: sbom_scan.status_name)

        expect { perform_worker }.not_to raise_error
      end
    end

    context 'on failure' do
      shared_examples_for 'failed sbom scan' do
        it 'does not schedule a retry, marks the scan as failed, and bubbles up the error', :aggregate_failures do
          expect(described_class).not_to receive(:perform_in)

          expect { perform_worker }.to raise_error(error)

          sbom_scan.reload
          expect(sbom_scan.error_message).to match(error.message)
          expect(sbom_scan.failed?).to be_truthy
        end
      end

      before do
        allow_next_instance_of(Security::VulnerabilityScanning::ProcessSbomScanService, sbom_scan) do |service|
          allow(service).to receive(:execute).and_raise(error)
        end
      end

      context 'when a retryable error is raised' do
        where(:error_class, :expected_retry_delay) do
          [
            [StandardError, 0],
            [::Security::VulnerabilityScanning::ProcessSbomScanService::SbomFileNotAvailableError, 5.seconds],
            [::Security::VulnerabilityScanning::ProcessSbomScanService::SbomScanFailedError, 0]
          ]
        end

        with_them do
          let(:error) { error_class.new('Error message') }

          it 'swallows error, resets the sbom scan, and schedules a retry with expected delay', :aggregate_failures do
            expect(described_class).to receive(:perform_in)
              .with(expected_retry_delay, sbom_scan.id, 1)

            expect { perform_worker }.not_to raise_error

            sbom_scan.reload
            expect(sbom_scan.error_message).to be_nil
            expect(sbom_scan.status_name).to eq(:created)
          end

          context 'when retries are exhausted' do
            subject(:perform_worker) { worker.perform(sbom_scan.id, described_class::MAX_RETRIES) }

            it_behaves_like 'failed sbom scan'
          end
        end
      end

      context 'when a non-retryable error is raised' do
        let(:error) do
          ::Security::VulnerabilityScanning::ProcessSbomScanService::NonRetryableError.new('Error message')
        end

        it_behaves_like 'failed sbom scan'
      end
    end
  end
end
