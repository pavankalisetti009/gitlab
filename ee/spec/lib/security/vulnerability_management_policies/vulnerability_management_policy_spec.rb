# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityManagementPolicies::VulnerabilityManagementPolicy, feature_category: :security_policy_management do
  let(:policy_content) do
    {
      actions: [
        {
          type: 'auto_dismiss',
          dismissal_reason: 'false_positive'
        }
      ]
    }
  end

  let(:scope) do
    { groups: { including: [{ id: 1 }] }, projects: { excluding: [{ id: 5 }] } }
  end

  let(:policy_record) do
    create(:security_policy, :vulnerability_management_policy,
      name: 'Test Vulnerability Management Policy',
      description: 'Test Description',
      enabled: true,
      scope: scope.as_json,
      content: policy_content)
  end

  let(:vulnerability_management_policy) { described_class.new(policy_record) }

  describe '#actions' do
    subject(:actions) { vulnerability_management_policy.actions }

    it 'returns an array of Action instances with correct values' do
      expect(actions).to be_an(Array)
      expect(actions.length).to eq(1)
      expect(actions.first).to be_a(Security::VulnerabilityManagementPolicies::Action)
      expect(actions.first.type).to eq('auto_dismiss')
      expect(actions.first.dismissal_reason).to eq('false_positive')
    end

    context 'when actions is not present in policy_content' do
      let(:policy_content) { {} }

      it 'returns an empty array' do
        expect(actions).to be_empty
      end
    end

    context 'when actions contains auto_resolve type' do
      let(:policy_content) do
        {
          actions: [
            {
              type: 'auto_resolve'
            }
          ]
        }
      end

      it 'returns an array with auto_resolve action' do
        expect(actions.length).to eq(1)
        expect(actions.first.type).to eq('auto_resolve')
        expect(actions.first.dismissal_reason).to be_nil
      end
    end
  end

  describe '#rules' do
    subject(:rules) { vulnerability_management_policy.rules }

    context 'when rules are present' do
      let!(:no_longer_detected_rule) do
        create(:vulnerability_management_policy_rule, :no_longer_detected, security_policy: policy_record)
      end

      let!(:detected_rule) do
        create(:vulnerability_management_policy_rule, :detected, security_policy: policy_record)
      end

      it 'returns an array of Rule instances with correct values' do
        expect(rules).to be_an(Array)
        expect(rules.length).to eq(2)
        expect(rules).to all(be_a(Security::VulnerabilityManagementPolicies::Rule))

        no_longer_detected = rules.find { |r| r.type == 'no_longer_detected' }
        expect(no_longer_detected).to be_present
        expect(no_longer_detected.scanners).to match_array(['sast'])
        expect(no_longer_detected.severity_levels).to match_array(['low'])

        detected = rules.find { |r| r.type == 'detected' }
        expect(detected).to be_present
        expect(detected.criteria.length).to eq(1)
        expect(detected.criteria.first[:type]).to eq('file_path')
        expect(detected.criteria.first[:value]).to eq('**/*')
      end
    end

    context 'when rules are not present' do
      it 'returns an empty array' do
        expect(rules).to be_an(Array)
        expect(rules).to be_empty
      end
    end

    context 'when rule has multiple criteria' do
      let!(:detected_rule) do
        create(:vulnerability_management_policy_rule, :detected, security_policy: policy_record)
      end

      before do
        detected_rule.update!(
          content: {
            type: 'detected',
            criteria: [
              { type: 'file_path', value: 'app/**/*.rb' },
              { type: 'directory', value: 'test/' },
              { type: 'identifier', value: 'CVE-2025-*' }
            ]
          }
        )
      end

      it 'returns all criteria' do
        detected = rules.find { |r| r.type == 'detected' }
        expect(detected.criteria.length).to eq(3)
        expect(detected.criteria.pluck(:type)).to match_array(%w[file_path directory identifier])
      end
    end
  end

  describe 'inherited methods from BaseSecurityPolicy' do
    it 'delegates name to policy_record' do
      expect(vulnerability_management_policy.name).to eq('Test Vulnerability Management Policy')
    end

    it 'delegates description to policy_record' do
      expect(vulnerability_management_policy.description).to eq('Test Description')
    end

    it 'delegates enabled to policy_record' do
      expect(vulnerability_management_policy.enabled).to be true
    end

    describe '#policy_scope' do
      subject(:policy_scope) { vulnerability_management_policy.policy_scope }

      it 'returns a PolicyScope instance with correct values' do
        expect(policy_scope).to be_a(Security::PolicyScope)

        expect(policy_scope.projects).to eq({ excluding: [{ id: 5 }] })
        expect(policy_scope.groups).to eq({ including: [{ id: 1 }] })
      end

      it 'passes the policy scope data to PolicyScope' do
        expect(Security::PolicyScope).to receive(:new).with(scope)

        policy_scope
      end

      context 'when scope is not present in policy' do
        let(:scope) { {} }

        it 'returns a PolicyScope instance with default values' do
          expect(policy_scope.projects).to eq({})
          expect(policy_scope.groups).to eq({})
        end

        it 'passes an empty hash to PolicyScope' do
          expect(Security::PolicyScope).to receive(:new).with({})

          policy_scope
        end
      end
    end
  end
end
