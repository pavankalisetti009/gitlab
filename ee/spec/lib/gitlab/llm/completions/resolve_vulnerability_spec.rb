# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::Llm::Completions::ResolveVulnerability, feature_category: :vulnerability_management do
  let(:prompt_class) { Gitlab::Llm::Templates::Vulnerabilities::ResolveVulnerability }
  let(:merge_request_service) { ::MergeRequests::CreateFromVulnerabilityDataService }
  let(:merge_request) { create(:merge_request, :simple, source_project: project) }
  let(:mr_url) { Gitlab::Routing.url_helpers.project_merge_request_url(project, merge_request) }
  let(:finding_location_file) { 'main.c' }
  let(:changed_code) { "somecode\nexecute" }
  let(:content) { "```\n#{changed_code}\n``` and a ```\nsecond code block\n```" }
  let(:example_response) do
    {
      "id" => "msg_01JPMpeAAtZdoNLvq8Nqhd3D",
      "type" => "message",
      "role" => "assistant",
      "model" => "claude-3-haiku-20240307",
      "content" => [
        {
          "type" => "text",
          "text" => anthropic_content
        }
      ],
      "stop_reason" => "end_turn",
      "stop_sequence" => nil,
      "usage" => {
        "input_tokens" => 130,
        "output_tokens" => 26
      }
    }
  end

  let_it_be(:user) { create(:user) }
  let_it_be(:user2) { create(:user) }
  let_it_be(:project) do
    create(:project, :custom_repo, files: {
                                     'main.c' => "#include <stdio.h>\n\nint main() { printf(\"hello, world!\"); }"
                                   },
      developers: [user, user2])
  end

  let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

  let(:prompt_message) do
    build(:ai_message, :resolve_vulnerability, user: user, resource: vulnerability, request_id: 'uuid')
  end

  let(:options) { {} }

  let(:logger) { instance_double(Gitlab::Llm::Logger) }

  let(:tracking_context) { { request_id: "uuid", action: :resolve_vulnerability } }
  let(:code_patch) { "<old_code>printf(\"hello, world!\");</old_code><new_code>\n#{changed_code}</new_code>" }
  let(:is_false_positive) { "false" }
  let(:anthropic_content) do
    <<~CONTENT
      <analysis>
      analysis</analysis>
      <fixed_code>
      #{code_patch}</fixed_code>
      <is_false_positive>
      #{is_false_positive}</is_false_positive>
      <summary>
      some summary</summary>
    CONTENT
  end

  let(:description_options) { { analysis_data: "analysis", summary_data: "some summary", vulnerable_mr: nil } }

  subject(:resolve) { described_class.new(prompt_message, prompt_class, options) }

  before do
    stub_licensed_features(security_dashboard: true)

    [:admin_all_resources, :resolve_vulnerability_with_ai].each do |permission|
      allow(user).to receive(:can?).with(permission).and_return(true)
      allow(user2).to receive(:can?).with(permission).and_return(true)
    end

    vulnerability.finding.location['file'] = finding_location_file
    vulnerability.finding.location['start_line'] = 1

    allow(GraphqlTriggers).to receive(:ai_completion_response)
    allow(Gitlab::Llm::Logger).to receive(:build).and_return(logger)
    allow(logger).to receive(:error)
    allow(logger).to receive(:warn)
    allow(Gitlab::ErrorTracking).to receive(:track_exception)
  end

  def execute_resolve(message_params = {}, options = {})
    message = build(:ai_message, :resolve_vulnerability,
      { user: user, resource: vulnerability, request_id: 'uuid' }.merge(message_params))

    described_class.new(message, prompt_class, options).execute
  end

  def allow_llm_client_to_raise_error(error)
    allow_next_instance_of(::Gitlab::Llm::ResolveVulnerability::Client) do |client|
      allow(client).to receive(:messages_complete).and_raise(error)
    end
  end

  def allow_llm_client_to_return_message(message)
    allow_next_instance_of(::Gitlab::Llm::ResolveVulnerability::Client) do |client|
      allow(client).to receive(:messages_complete).and_return(message)
    end
  end

  def expect_published_graphql_content(content)
    expect(GraphqlTriggers).to have_received(:ai_completion_response)
      .with(an_object_having_attributes(
        content: content,
        user: user,
        resource: vulnerability,
        role: ::Gitlab::Llm::AiMessage::ROLE_ASSISTANT,
        request_id: 'uuid',
        errors: []
      )
           )
  end

  def expect_published_graphql_message(error)
    expect(GraphqlTriggers).to have_received(:ai_completion_response)
      .with(an_object_having_attributes(
        user: user,
        resource: vulnerability,
        role: ::Gitlab::Llm::AiMessage::ROLE_ASSISTANT,
        request_id: 'uuid',
        errors: Array.wrap(error)
      )
           )
  end

  def expect_tracked_error(error)
    expect(Gitlab::ErrorTracking).to have_received(:track_exception).with(error)
  end

  def expect_logged_error(error)
    expect(logger).to have_received(:error).with(message: "LLM completion error",
      error_message: error.to_s,
      klass: "Gitlab::Llm::Completions::ResolveVulnerability",
      ai_component: 'abstraction_layer',
      event_name: 'error_response_received')
  end

  describe '#execute', :clean_gitlab_redis_cache do
    context 'when the AIGW responds with an empty code block' do
      let(:code_patch) { '' }

      before do
        allow_llm_client_to_return_message(example_response)
      end

      it 'publishes a false positive error to the graphql subscription' do
        resolve.execute

        expect_published_graphql_message(a_string_starting_with('The response from the AI provider was ' \
          'empty because it has determined this vulnerability to be a false positive.'))
      end
    end

    context 'when the AIGW responds does not include a code block' do
      let(:anthropic_content) do
        <<~CONTENT
          <analysis>
          analysis</analysis>
          <is_false_positive>
          #{is_false_positive}</is_false_positive>
          <summary>
          some summary</summary>
        CONTENT
      end

      before do
        allow_llm_client_to_return_message(example_response)
      end

      it 'publishes a false positive error to the graphql subscription' do
        resolve.execute

        expect_published_graphql_message(a_string_starting_with('The response from the AI provider was ' \
          'empty because it has determined this vulnerability to be a false positive.'))
      end
    end

    context 'when the AIGW responds with the is_false_positive tag' do
      let(:is_false_positive) { "true" }

      before do
        allow_llm_client_to_return_message(example_response)
      end

      it 'publishes a false positive error to the graphql subscription' do
        resolve.execute

        expect_published_graphql_message(a_string_starting_with('The response from the AI provider was ' \
          'empty because it has determined this vulnerability to be a false positive.'))
      end
    end

    context 'when the AIGW returns an error response' do
      before do
        allow_llm_client_to_return_message({ 'error' => { 'message' => 'Ooops...' } })
      end

      it 'publishes the error to the graphql subscription' do
        resolve.execute

        expect_published_graphql_message(["Ooops..."])
      end
    end

    context 'when there is no file for the finding in the repo' do
      let(:finding_location_file) { 'no_such_file.c' }

      it 'returns an error' do
        resolve.execute

        expect_published_graphql_message('Unable to locate source code for vulnerability')
      end
    end

    context 'when vulnerable code exceeds maximum length' do
      it 'returns an error' do
        allow_next_instance_of(prompt_class) do |instance|
          allow(instance).to receive(:max_code_length).and_return(0)
        end

        resolve.execute

        expect_published_graphql_message('Vulnerable code exceeds maximum length (0)')
      end
    end

    context 'when vulnerability report_type is secret detection' do
      it 'returns an error' do
        allow(vulnerability).to receive(:secret_detection?).and_return(true)

        resolve.execute

        expect_published_graphql_message('Refusing to send possible secrets in AI prompt')
      end
    end

    context 'when the AIGW returns a nil response' do
      let(:example_response) { nil }

      before do
        allow_llm_client_to_return_message(example_response)
      end

      it 'records the error and publishes a message to the graphql subscription' do
        resolve.execute

        expect_tracked_error(described_class::EmptyResponseError)
        expect_logged_error("Empty response from LLM")
        expect_published_graphql_message(described_class::RESPONSE_FAILURE_ERROR)
      end
    end

    context 'when the response from the AIGW experiences a Net::ReadTimeout' do
      let(:error) { Net::ReadTimeout.new }

      before do
        allow_llm_client_to_raise_error(error)
      end

      it 'records the error and publishes a message to the graphql subscription' do
        resolve.execute

        expect_tracked_error(error)
        expect_logged_error("Net::ReadTimeout")
        expect_published_graphql_message(described_class::CLIENT_TIMEOUT_ERROR)
      end
    end

    context 'when the AIGW returns a Gitlab::AiGateway::ForbiddenError' do
      let(:error) { Gitlab::AiGateway::ForbiddenError.new }

      before do
        allow_llm_client_to_raise_error(error)
      end

      it 'records the error and publishes a message to the graphql subscription' do
        resolve.execute

        expect_tracked_error(error)
        expect_logged_error("Gitlab::AiGateway::ForbiddenError")
        expect_published_graphql_message(described_class::FORBIDDEN_ERROR)
      end
    end

    context 'when an unexpected error is raised reading the response from the AIGW' do
      let(:error) { StandardError.new("Ooops...") }

      before do
        allow_llm_client_to_raise_error(error)
      end

      it 'records the error and publishes a message to the graphql subscription' do
        resolve.execute

        expect_tracked_error(error)
        expect_logged_error(error.to_s)
        expect_published_graphql_message(described_class::DEFAULT_ERROR)
      end
    end

    context 'when the AIGW returns a successful response' do
      let(:mr_service_response) { { merge_request: merge_request, status: :success } }

      before do
        allow_llm_client_to_return_message(example_response)

        allow(merge_request_service).to receive(:new).and_call_original
        allow_next_instance_of(merge_request_service) do |mr_service|
          allow(mr_service).to receive(:execute).and_return(mr_service_response)
        end
      end

      it 'requests that a MR be created with the extracted patch' do
        resolve.execute

        expect(merge_request_service).to have_received(:new).with(
          project,
          vulnerability,
          user,
          llm_patch: code_patch,
          description_options: description_options
        )
      end

      it 'publishes the created merge request for the fix' do
        resolve.execute

        expect_published_graphql_content(mr_url)
      end

      it 'tracks internal event with success' do
        expect(Gitlab::InternalEvents).to receive(:track_event).with('track_mr_creation_from_vr',
          project: project,
          user: user,
          namespace: project.namespace,
          category: described_class.to_s,
          additional_properties: {
            property: "success",
            label: "resolve_vulnerability",
            vulnerability_id: vulnerability.id,
            internal_merge_request_id: merge_request.id,
            language: "C"
          }
        )

        resolve.execute
      end

      context 'when options has vulnerable_merge_request_id' do
        let(:vulnerable_mr) do
          create(
            :merge_request,
            source_branch: 'vulnerable',
            target_branch: project.default_branch,
            source_project: project
          )
        end

        let(:options) { { vulnerable_merge_request_id: mr_global_id } }
        let(:mr_global_id) { Gitlab::GlobalId.as_global_id(vulnerable_mr.id, model_name: MergeRequest) }
        let(:note) { create(:note_on_merge_request, project: vulnerable_mr.project, noteable: vulnerable_mr) }
        let(:expected_params) do
          note_regex = %r{Vulnerability Resolution has generated a fix.*merge_requests.*/\d+\+s.*}
          [
            vulnerable_mr.project,
            user,
            a_hash_including(note: a_string_matching(note_regex), noteable_id: vulnerable_mr.id)
          ]
        end

        before do
          allow(Notes::CreateService).to receive(:new).and_call_original
          allow_next_instance_of(Notes::CreateService) do |note_service|
            allow(note_service).to receive(:execute).and_return(note)
          end
        end

        it 'creates a note on the vulnerable merge request' do
          resolve.execute
          expect(Notes::CreateService).to have_received(:new).with(*expected_params)
        end

        it 'tracks internal event with success' do
          expect(Gitlab::InternalEvents).to receive(:track_event).with('track_mr_creation_from_vr_in_mr_request',
            project: project,
            user: user,
            namespace: project.namespace,
            category: described_class.to_s,
            additional_properties: {
              property: "success",
              label: "resolve_vulnerability",
              vulnerability_id: vulnerability.id,
              internal_merge_request_id: merge_request.id,
              language: "C"
            }
          )

          resolve.execute
        end
      end

      context 'when the AIGW responds with a typed code block' do
        let(:content) { "```java\n#{code_patch}\n```" }

        it 'publishes the created merge request for the fix' do
          resolve.execute

          expect_published_graphql_content(mr_url)
        end
      end

      context 'when the CreateFromVulnerabilityDataService service fails to create an MR for the vulnerability' do
        before do
          allow_next_instance_of(merge_request_service) do |service|
            allow(service).to receive(:execute).and_return({ status: :error })
          end
        end

        it 'records the error and publishes a message to the graphql subscription' do
          resolve.execute

          error = StandardError.new(described_class::RESOLUTION_FAILURE_ERROR)
          expect_tracked_error(error)
          expect_logged_error(error)
          expect_published_graphql_message(described_class::RESOLUTION_FAILURE_ERROR)
        end
      end

      context 'when the response from the merge reqeust service is malformed' do
        before do
          allow_next_instance_of(merge_request_service) do |service|
            allow(service).to receive(:execute)
                                .and_return({ status: :error, unreadable_response: true })
          end
        end

        it 'records the error and publishes a message to the graphql subscription' do
          resolve.execute

          error = StandardError.new(described_class::RESPONSE_FAILURE_ERROR)
          expect_tracked_error(error)
          expect_logged_error(error)
          expect_published_graphql_message(described_class::RESPONSE_FAILURE_ERROR)
        end

        it 'tracks internal event with error' do
          expect(Gitlab::InternalEvents).to receive(:track_event).with('track_mr_creation_from_vr',
            project: project,
            user: user,
            namespace: project.namespace,
            category: "Gitlab::Llm::Completions::ResolveVulnerability",
            additional_properties: {
              property: "error",
              label: "resolve_vulnerability",
              vulnerability_id: vulnerability.id,
              internal_merge_request_id: nil,
              language: "C"
            }
          )

          resolve.execute
        end

        it 'clears cache' do
          resolve.execute

          expect(Rails.cache.read([user.id, vulnerability.cache_key, 'resolve'].join('/'))).to be_nil
        end
      end

      context 'when request is cached', :use_clean_rails_redis_caching do
        context 'when unique users make the same request' do
          let(:fake_client) { instance_double(::Gitlab::Llm::ResolveVulnerability::Client) }

          before do
            allow(::Gitlab::Llm::ResolveVulnerability::Client).to receive(:new).and_return(fake_client)
            allow(fake_client).to receive(:messages_complete).twice.and_return(example_response)
          end

          it 'makes a fresh request for each user' do
            # cache miss
            execute_resolve
            execute_resolve({ user: user2 })

            # cache hit
            execute_resolve
            execute_resolve({ user: user2 })

            expect(fake_client).to have_received(:messages_complete).exactly(2).times
          end
        end
      end
    end
  end
end
