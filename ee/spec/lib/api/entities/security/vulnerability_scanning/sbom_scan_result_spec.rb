# frozen_string_literal: true

require 'spec_helper'

RSpec.describe API::Entities::Security::VulnerabilityScanning::SbomScanResult, feature_category: :software_composition_analysis do
  let_it_be(:project) { create(:project) }
  let_it_be(:pipeline) { create(:ci_pipeline, project: project) }

  let(:scanner) { Gitlab::VulnerabilityScanning::SecurityScanner.fabricate }
  let(:serialized_scanner) { API::Entities::Security::VulnerabilityScanning::Scanner.represent(scanner).as_json }
  let(:finding1) { build_stubbed(:ci_reports_security_finding, :dependency_scanning) }
  let(:finding2) { build_stubbed(:ci_reports_security_finding, :dependency_scanning) }
  let(:serialized_findings) do
    [
      API::Entities::Security::VulnerabilityScanning::Finding.represent(finding1).as_json,
      API::Entities::Security::VulnerabilityScanning::Finding.represent(finding2).as_json
    ]
  end

  let(:security_report) do
    ::Gitlab::Ci::Reports::Security::Report.new(:dependency_scanning, pipeline, Time.zone.now).tap do |report|
      report.scanner = scanner
      report.add_finding(finding1)
      report.add_finding(finding2)
    end
  end

  let(:expected_formatted_json) do
    {
      scanner: serialized_scanner,
      findings: serialized_findings
    }
  end

  subject { described_class.new(security_report).as_json }

  it { is_expected.to eq(expected_formatted_json) }

  context 'when security report has no findings' do
    let(:security_report) do
      ::Gitlab::Ci::Reports::Security::Report.new(:dependency_scanning, pipeline, Time.zone.now).tap do |report|
        report.scanner = scanner
      end
    end

    let(:serialized_findings) { [] }

    it { is_expected.to eq(expected_formatted_json) }
  end
end
