# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::VulnerabilityAggregations, feature_category: :vulnerability_management do
  let(:query_hash) { {} }

  describe '#by_severity_counts' do
    let(:options) { { count_by_severity: true } }

    it 'adds size and aggs to query_hash' do
      expect(described_class.by_severity_counts(query_hash: query_hash, options: options)).to eq({
        size: 0,
        aggs: {
          severity_counts: {
            terms: {
              field: "severity"
            }
          }
        }
      })
    end
  end

  describe '#vulnerabilities_over_time' do
    subject(:by_vulnerabilities_over_time) do
      described_class.by_vulnerabilities_over_time(query_hash: query_hash, options: options)
    end

    let(:start_date) { Date.parse('2023-01-01') }
    let(:end_date) { Date.parse('2023-01-03') }
    let(:group_by) { "severity" }
    let(:vulnerabilities_over_time) { true }
    let(:created_after) { start_date }
    let(:created_before) { end_date }

    let(:options) do
      {
        vulnerabilities_over_time: vulnerabilities_over_time,
        group_by: group_by,
        bucket_start_date: created_after,
        bucket_end_date: created_before
      }
    end

    context "when valid options" do
      shared_examples 'creates size and filters aggregation' do
        it 'adds size and filters aggregation to query_hash', :aggregate_failures do
          result = by_vulnerabilities_over_time

          expect(result[:size]).to eq(0)
          expect(result[:aggs][:open_by_day][:filters][:filters]).to have_key("2023-01-01")
          expect(result[:aggs][:open_by_day][:filters][:filters]).to have_key("2023-01-02")
          expect(result[:aggs][:open_by_day][:filters][:filters]).to have_key("2023-01-03")

          day1_filter = result[:aggs][:open_by_day][:filters][:filters]["2023-01-01"]
          expect(day1_filter[:bool][:must]).to include({ range: { created_at: { lte: "2023-01-01T23:59:59Z" } } })
          expect(day1_filter[:bool][:must_not]).to include({ range: { resolved_at: { lte: "2023-01-01T23:59:59Z" } } })
          expect(day1_filter[:bool][:must_not]).to include({ range: { dismissed_at: { lte: "2023-01-01T23:59:59Z" } } })

          expect(result[:aggs][:open_by_day][:aggs][:"by_#{group_by}"][:terms][:field]).to eq(group_by)
          expect(result[:aggs][:open_by_day][:aggs][:"by_#{group_by}"][:terms][:size]).to eq(10)
        end
      end

      context "when group_by is 'severity'" do
        let(:group_by) { "severity" }

        it_behaves_like 'creates size and filters aggregation'

        it 'creates aggregation with by_severity field' do
          result = by_vulnerabilities_over_time
          expect(result[:aggs][:open_by_day][:aggs]).to have_key(:by_severity)
        end
      end

      context "when group_by is 'report_type'" do
        let(:group_by) { "report_type" }

        it_behaves_like 'creates size and filters aggregation'

        it 'creates aggregation with by_report_type field' do
          result = by_vulnerabilities_over_time
          expect(result[:aggs][:open_by_day][:aggs]).to have_key(:by_report_type)
        end
      end
    end

    context "with invalid options" do
      context "when group_by is invalid" do
        let(:group_by) { "invalid_field" }

        it 'raises ArgumentError' do
          expect { by_vulnerabilities_over_time }.to raise_error(ArgumentError, "group_by is required")
        end
      end

      context "when vulnerabilities_over_time is false" do
        let(:vulnerabilities_over_time) { false }

        it 'returns original query_hash unchanged' do
          expect(by_vulnerabilities_over_time).to eq(query_hash)
        end
      end

      context 'with invalid dates' do
        shared_examples 'raises date validation argument error' do
          it 'raises ArgumentError for missing or empty dates' do
            expect do
              by_vulnerabilities_over_time
            end.to raise_error(ArgumentError, "bucket_start_date and bucket_end_date are required")
          end
        end

        context "when bucket_start_date is missing" do
          let(:created_after) { nil }

          it_behaves_like 'raises date validation argument error'
        end

        context "when bucket_end_date is missing" do
          let(:created_before) { nil }

          it_behaves_like 'raises date validation argument error'
        end

        context "when bucket_start_date is empty" do
          let(:created_after) { "" }

          it_behaves_like 'raises date validation argument error'
        end

        context "when bucket_end_date is empty" do
          let(:created_before) { "" }

          it_behaves_like 'raises date validation argument error'
        end
      end

      context "when start_date is greater than end_date" do
        let(:created_after) { end_date }
        let(:created_before) { start_date }

        it 'raises ArgumentError' do
          expect do
            by_vulnerabilities_over_time
          end.to raise_error(ArgumentError, "bucket_start_date must be before or equal to bucket_end_date")
        end
      end

      context "when date range is more than 31 days" do
        let(:created_before) { start_date + 32.days }

        it 'raises ArgumentError' do
          expect do
            by_vulnerabilities_over_time
          end.to raise_error(ArgumentError, "bucket_start_date and bucket_end_date must be within 31 days")
        end
      end
    end
  end

  describe '.by_identifiers_search' do
    let(:options) { { partial_identifier_name: "cVE-2020-5247" } }

    it "adds size and aggs to query_hash" do
      expect(described_class.by_identifiers_search(query_hash: query_hash, options: options)).to eq({
        size: 0,
        aggs: {
          unique_identifiers: {
            terms: {
              field: "identifier_names.original",
              size: ::Vulnerabilities::Identifier::SEARCH_RESULTS_LIMIT,
              include: ".*(cve-2020-5247|CVE-2020-5247|cVE-2020-5247).*"
            }
          }
        }
      })
    end
  end

  describe '.by_risk_score_sum' do
    let(:options) { { risk_score_sum: risk_score_sum } }

    context 'with risk_score set to false' do
      let(:risk_score_sum) { false }

      it "does not modify the query" do
        expect(described_class.by_risk_score_sum(query_hash: query_hash, options: options)).to eq(query_hash)
      end
    end

    context 'with risk_score set to true' do
      let(:risk_score_sum) { true }

      it "adds size and aggs to query_hash" do
        expect(described_class.by_risk_score_sum(query_hash: query_hash, options: options)).to eq({
          size: 0,
          aggs: {
            risk_scores_sum: {
              sum: {
                field: "risk_score"
              }
            }
          }
        })
      end
    end
  end

  describe '.by_created_at_sum' do
    let(:options) { { created_at_sum: created_at_sum } }

    context 'with created_at set to false' do
      let(:created_at_sum) { false }

      it "does not modify the query" do
        expect(described_class.by_created_at_sum(query_hash: query_hash, options: options)).to eq(query_hash)
      end
    end

    context 'with created_at set to true' do
      let(:created_at_sum) { true }

      it "adds size and aggs to query_hash" do
        expect(described_class.by_created_at_sum(query_hash: query_hash, options: options)).to eq({
          size: 0,
          aggs: {
            created_at_sum: {
              sum: {
                field: "created_at"
              }
            }
          }
        })
      end
    end
  end
end
