# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::References::Vulnerability, :elastic_helpers, :request_store, feature_category: :global_search do
  # Create project and group structure
  let_it_be(:parent_group) { create(:group) }
  let_it_be(:group) { create(:group, parent: parent_group) }
  let_it_be(:project) { create(:project, group: group) }
  let_it_be(:user_project) { create(:project, namespace: create(:namespace)) }

  let_it_be(:vulnerability) { create(:vulnerability, :with_read, project: project, report_type: :container_scanning) }
  let_it_be(:user_vulnerability) { create(:vulnerability, :with_read, project: user_project, report_type: :sast) }

  # Create identifiers for CVE information
  let_it_be(:identifier) do
    create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-12345', name: 'CVE-2023-12345')
  end

  let_it_be(:user_identifier) do
    create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-67890', name: 'CVE-2023-67890')
  end

  # Create findings associated with vulnerabilities
  let_it_be(:finding) do
    create(:vulnerabilities_finding, vulnerability: vulnerability, project: project, identifiers: [identifier])
  end

  let_it_be(:user_finding) do
    create(:vulnerabilities_finding, vulnerability: user_vulnerability, project: user_project,
      identifiers: [user_identifier])
  end

  let_it_be(:vulnerability_read) do
    vulnerability.vulnerability_read
  end

  let_it_be(:user_vulnerability_read) do
    user_vulnerability.vulnerability_read
  end

  # Basic configuration for tests
  before do
    allow(::Elastic::DataMigrationService).to receive(:migration_has_finished?).and_return(true)

    stub_const('Gitlab::QueryLimiting::Transaction::THRESHOLD', 100)
  end

  describe '#as_indexed_json' do
    let(:base_vulnerability_hash) do
      {
        vulnerability_id: object.vulnerability_id,
        created_at: be_within(0.1.seconds).of(object.vulnerability.created_at),
        updated_at: be_within(0.1.seconds).of(object.vulnerability.updated_at),
        detected_at: be_within(0.1.seconds).of(object.vulnerability.detected_at),
        resolved_at: nil,
        dismissed_at: nil,
        project_id: object.project_id,
        scanner_id: object.scanner_id,
        scanner_external_id: object.scanner.external_id,
        report_type: object.report_type_before_type_cast,
        severity: object.severity_before_type_cast,
        state: object.state_before_type_cast,
        has_issues: object.has_issues,
        resolved_on_default_branch: object.resolved_on_default_branch,
        uuid: object.uuid,
        location_image: object.location_image,
        cluster_agent_id: object.cluster_agent_id,
        casted_cluster_agent_id: object.casted_cluster_agent_id,
        dismissal_reason: object.dismissal_reason_before_type_cast,
        has_merge_request: object.has_merge_request,
        has_remediations: object.has_remediations,
        traversal_ids: object.project.namespace.elastic_namespace_ancestry,
        archived: object.archived,
        has_vulnerability_resolution: object.has_vulnerability_resolution,
        auto_resolved: object.auto_resolved,
        identifier_names: object.identifier_names,
        epss_scores: [],
        reachability: [],
        token_status: [],
        policy_violations: [],
        risk_score: [],
        type: described_class::DOC_TYPE,
        schema_version: described_class::SCHEMA_VERSION
      }
    end

    let(:object) { vulnerability_read }
    let(:expected_hash) { base_vulnerability_hash }

    let(:vulnerability_reference_object) do
      described_class.new(object.vulnerability_id, object.es_parent)
    end

    subject(:indexed_json) do
      vulnerability_reference_object.as_indexed_json.with_indifferent_access
    end

    it 'serializes vulnerability as a hash' do
      expect(indexed_json).to match(expected_hash)
    end

    context 'with CVE identifiers and EPSS scores' do
      let(:cve_value) { vulnerability_read.cve_value }
      let(:epss_score) { 0.85 }
      let(:cve_enrichment) do
        create(:pm_cve_enrichment, cve: cve_value, epss_score: epss_score)
      end

      before do
        allow(object).to receive_messages(
          cve_value: cve_value,
          epss_scores: [epss_score]
        )

        # epss_scores is set only during preloading by the proxy record creation. So preloading below.
        allow(PackageMetadata::CveEnrichment).to receive(:by_cves).with(
          [cve_enrichment.cve]).and_return([cve_enrichment])
        described_class.preload_indexing_data([vulnerability_reference_object])
      end

      it 'includes EPSS scores in the indexed JSON' do
        expect(indexed_json[:epss_scores]).to eq([epss_score])
      end
    end

    context 'with reachability mappings' do
      let(:reachability_data) { 1 }

      before do
        allow(object).to receive(:reachability).and_return(reachability_data)
        allow(vulnerability_reference_object).to receive(:database_record).and_return(object)
      end

      it 'includes reachability in the indexed JSON' do
        expect(indexed_json[:reachability]).to eq(reachability_data)
      end
    end

    context 'with resolved_at, dismissed_at mappings' do
      before do
        set_elasticsearch_migration_to(:add_resolved_at_dismissed_at_fields_to_vulnerability)
      end

      context 'when migrations are completed' do
        context 'with resolved_at' do
          let(:resolved_at) { 1.day.ago }
          let(:resolved_vulnerability) do
            create(:vulnerability, :with_read, project: project, resolved_at: resolved_at)
          end

          let(:resolved_vulnerability_read) { resolved_vulnerability.vulnerability_read }
          let(:object) { resolved_vulnerability_read }

          it 'sets resolved_at field on the indexed json' do
            expect(indexed_json[:resolved_at]).to be_within(0.1.seconds).of(resolved_at)
          end

          it 'returns schema version' do
            expect(indexed_json[:schema_version]).to eq(25_36)
          end
        end

        context 'with dismissed_at' do
          let(:dismissed_at) { 1.day.ago }
          let(:dismissed_vulnerability) do
            create(:vulnerability, :with_read, project: project, dismissed_at: dismissed_at)
          end

          let(:dismissed_vulnerability_read) { dismissed_vulnerability.vulnerability_read }
          let(:object) { dismissed_vulnerability_read }

          it 'sets dismissed_at field on the indexed json' do
            expect(indexed_json[:dismissed_at]).to be_within(0.1.seconds).of(dismissed_at)
          end

          it 'returns schema version' do
            expect(indexed_json[:schema_version]).to eq(25_36)
          end
        end

        context 'when the resolved_at/dismissed_at migration has not completed' do
          before do
            set_elasticsearch_migration_to(:add_resolved_at_dismissed_at_fields_to_vulnerability, including: false)
          end

          it 'returns schema version with reachability only' do
            expect(indexed_json[:schema_version]).to eq(25_26)
          end

          it 'does not assign resolved_at dismissed_at but assigns reachability on the indexed json',
            :aggregate_failures do
            expect(indexed_json[:reachability]).not_to be_nil
            expect(indexed_json[:resolved_at]).to be_nil
            expect(indexed_json[:dismissed_at]).to be_nil
          end
        end
      end
    end

    context 'with token_status migration mappings' do
      context 'when token_status migration has finished' do
        let(:token_status_data) { ::Security::TokenStatus::ACTIVE }

        before do
          set_elasticsearch_migration_to(:add_token_status_field_to_vulnerability)

          allow(object).to receive(:token_status).and_return(token_status_data)
          allow(vulnerability_reference_object).to receive(:database_record).and_return(object)
        end

        it 'returns schema version' do
          expect(indexed_json[:schema_version]).to eq(25_37)
        end

        it 'includes token_status in the indexed json' do
          expect(indexed_json[:token_status]).to eq(token_status_data)
        end
      end

      context 'when migration has not completed' do
        before do
          set_elasticsearch_migration_to(:add_token_status_field_to_vulnerability, including: false)
        end

        it 'returns schema version with resolved_at and dismissed_at' do
          expect(indexed_json[:schema_version]).to eq(25_36)
        end

        it 'does not assign token_status on the indexed json', :aggregate_failures do
          expect(indexed_json[:token_status]).to be_nil
        end
      end
    end

    context 'with policy_violations migration mappings' do
      context 'when policy_violations migration has finished' do
        let(:policy_violations_data) { ::Security::PolicyViolations::DISMISSED_IN_MR }

        before do
          set_elasticsearch_migration_to(:add_policy_violations_field_to_vulnerability)

          allow(object).to receive(:policy_violations).and_return(policy_violations_data)
          allow(vulnerability_reference_object).to receive(:database_record).and_return(object)
        end

        it 'returns schema version' do
          expect(indexed_json[:schema_version]).to eq(25_42)
        end

        it 'includes policy_violations in the indexed json' do
          expect(indexed_json[:policy_violations]).to eq(policy_violations_data)
        end
      end

      context 'when migration has not completed' do
        before do
          set_elasticsearch_migration_to(:add_policy_violations_field_to_vulnerability, including: false)
        end

        it 'returns schema version with token_status' do
          expect(indexed_json[:schema_version]).to eq(25_37)
        end

        it 'does not assign token_status on the indexed json', :aggregate_failures do
          expect(indexed_json[:policy_violations]).to be_nil
        end
      end
    end

    context 'with risk_score migration mappings' do
      context 'when risk_Score migration has finished' do
        let(:risk_score_data) { 0.5 }

        before do
          set_elasticsearch_migration_to(:add_risk_score_field_to_vulnerability)

          allow(object).to receive(:risk_score).and_return(risk_score_data)
          allow(vulnerability_reference_object).to receive(:database_record).and_return(object)
        end

        it 'returns schema version' do
          expect(indexed_json[:schema_version]).to eq(25_43)
        end

        it 'includes token_status in the indexed json' do
          expect(indexed_json[:risk_score]).to eq(risk_score_data)
        end
      end

      context 'when migration has not completed' do
        before do
          set_elasticsearch_migration_to(:add_risk_score_field_to_vulnerability, including: false)
        end

        it 'returns schema version with policy_violations' do
          expect(indexed_json[:schema_version]).to eq(25_42)
        end

        it 'does not assign risk_score on the indexed json', :aggregate_failures do
          expect(indexed_json[:risk_score]).to be_nil
        end
      end
    end

    context 'with detected_at mappings' do
      before do
        set_elasticsearch_migration_to(:add_detected_at_field_to_vulnerability)
      end

      context 'when migrations are completed' do
        context 'with detected_at' do
          let(:detected_at) { 2.days.ago }
          let(:detected_vulnerability) do
            create(:vulnerability, :with_read, project: project, detected_at: detected_at)
          end

          let(:detected_vulnerability_read) { detected_vulnerability.vulnerability_read }
          let(:object) { detected_vulnerability_read }

          it 'sets detected_at field on the indexed json' do
            expect(indexed_json[:detected_at]).to be_within(0.1.seconds).of(detected_at)
          end

          it 'returns schema version' do
            expect(indexed_json[:schema_version]).to eq(25_44)
          end
        end

        context 'when the detected_at migration has not completed' do
          before do
            set_elasticsearch_migration_to(:add_detected_at_field_to_vulnerability, including: false)
          end

          it 'returns schema version with risk_score only' do
            expect(indexed_json[:schema_version]).to eq(25_43)
          end

          it 'does not assign detected_at on the indexed json', :aggregate_failures do
            expect(indexed_json[:detected_at]).to be_nil
          end
        end
      end
    end

    context 'when all migrations have completed' do
      it 'returns the current schema version' do
        expect(indexed_json[:schema_version]).to eq(described_class::SCHEMA_VERSION)
      end
    end

    context 'when no migration have completed' do
      before do
        set_elasticsearch_migration_to(:add_resolved_at_dismissed_at_fields_to_vulnerability, including: false)
      end

      it 'returns oldest schema version' do
        expect(indexed_json[:schema_version]).to eq(25_26)
      end
    end
  end

  describe '.preload_indexing_data' do
    let(:vulnerability_ref) { described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent) }
    let(:user_vulnerability_ref) do
      described_class.new(user_vulnerability_read.vulnerability_id, user_vulnerability_read.es_parent)
    end

    let(:refs) { [vulnerability_ref, user_vulnerability_ref] }

    it 'preloads vulnerability records' do
      expect(::Vulnerabilities::Read).to receive(:preload_indexing_data).and_call_original
      expect(described_class).to receive(:extract_cve_values).and_call_original
      expect(described_class).to receive(:preload_cve_enrichments).and_call_original

      described_class.preload_indexing_data(refs)

      expect(vulnerability_ref.database_record).to be_present
      expect(user_vulnerability_ref.database_record).to be_present
    end

    context 'with CVE values' do
      let_it_be(:cve_enrichment) { create(:pm_cve_enrichment, cve: vulnerability_read.cve_value) }
      let_it_be(:cve_identifier) do
        create(:vulnerabilities_identifier, external_type: 'cve', external_id: cve_enrichment.cve,
          name: cve_enrichment.cve)
      end

      let_it_be(:cve_vulnerability) { create(:vulnerability, project: project, report_type: :container_scanning) }
      let_it_be(:cve_finding) do
        create(
          :vulnerabilities_finding,
          vulnerability: cve_vulnerability,
          identifiers: [cve_identifier]
        )
      end

      let(:vulnerability_ref_with_cve) do
        described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent)
      end

      before do
        allow_next_instance_of(::Vulnerabilities::Read) do |instance|
          allow(instance).to receive(:cve_value).and_return(cve_enrichment.cve)
        end

        allow(PackageMetadata::CveEnrichment).to receive(:by_cves).with(
          [cve_enrichment.cve]).and_return([cve_enrichment])
      end

      it 'extracts CVE values and preloads CVE enrichments' do
        expect(PackageMetadata::CveEnrichment).to receive(:by_cves).with(
          [cve_enrichment.cve]).and_return([cve_enrichment])

        described_class.preload_indexing_data([vulnerability_ref_with_cve])
      end
    end

    context 'with reachability data' do
      let!(:sbom_occurrence_1) do
        create(:sbom_occurrence, reachability: 'in_use')
      end

      let!(:sbom_occurrence_2) do
        create(:sbom_occurrence, reachability: 'unknown')
      end

      let!(:sbom_occurrences_vulnerability_1) do
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence_1,
          vulnerability_id: vulnerability_read.vulnerability_id)
      end

      let!(:sbom_occurrences_vulnerability_2) do
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence_2,
          vulnerability_id: user_vulnerability_read.vulnerability_id)
      end

      it 'preserves reachability data after preloading' do
        described_class.preload_indexing_data(refs)

        expect(vulnerability_ref.database_record.reachability).to eq(
          sbom_occurrence_1.reachability_before_type_cast)
        expect(user_vulnerability_ref.database_record.reachability).to eq(
          sbom_occurrence_2.reachability_before_type_cast)
      end
    end

    context 'with policy_violations data' do
      before do
        create(:policy_dismissal, :preserved, project: project, security_findings_uuids: [vulnerability_read.uuid])
      end

      it 'preloads policy_violations' do
        described_class.preload_indexing_data(refs)

        expect(vulnerability_ref.database_record.policy_violations).to eq(::Security::PolicyViolations::DISMISSED_IN_MR)
        expect(user_vulnerability_ref.database_record.policy_violations).to eq(
          ::Security::PolicyViolations::NOT_APPLICABLE)
      end
    end

    context 'for database_record' do
      it 'without preloading returns an instance of model class' do
        expect(vulnerability_ref.database_record).to be_an_instance_of(described_class.model_klass)
      end

      it 'with preloading it returns the proxy record' do
        described_class.preload_indexing_data(refs)

        expect(vulnerability_ref.database_record).to be_an_instance_of(Search::Elastic::RecordProxy::Vulnerability)
      end
    end

    context 'when checking for N+1 queries', :request_store do
      it 'does not have N+1 queries when preloading multiple references' do
        stub_env('GITALY_DISABLE_REQUEST_LIMITS', 'true')

        # Create initial test data
        project1 = create(:project, group: group)
        project2 = create(:project, namespace: create(:namespace))

        vulnerability1 = create(:vulnerability, :with_read, project: project1, report_type: :container_scanning)
        vulnerability2 = create(:vulnerability, :with_read, project: project2, report_type: :sast)

        # Create CVE identifiers
        identifier1 = create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-11111',
          name: 'CVE-2023-11111')
        identifier2 = create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-22222',
          name: 'CVE-2023-22222')

        # Create findings with CVE identifiers
        finding1 = create(:vulnerabilities_finding, vulnerability: vulnerability1, project: project1,
          identifiers: [identifier1])
        finding2 = create(:vulnerabilities_finding, vulnerability: vulnerability2, project: project2,
          identifiers: [identifier2])

        # Create CVE enrichments with EPSS scores
        create(:pm_cve_enrichment, cve: 'CVE-2023-11111', epss_score: 0.75)
        create(:pm_cve_enrichment, cve: 'CVE-2023-22222', epss_score: 0.85)

        # Create SBOM occurrences for reachability data
        sbom_occurrence1 = create(:sbom_occurrence, reachability: 'in_use')
        sbom_occurrence2 = create(:sbom_occurrence, reachability: 'unknown')

        vulnerability_read1 = vulnerability1.vulnerability_read
        vulnerability_read2 = vulnerability2.vulnerability_read

        # Create SBOM occurrences vulnerabilities for reachability
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence1,
          vulnerability_id: vulnerability_read1.vulnerability_id)
        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence2,
          vulnerability_id: vulnerability_read2.vulnerability_id)

        # Create Policy Dismissal occurrences for policy_violations data
        create(:policy_dismissal, :preserved, project: project1, security_findings_uuids: [vulnerability_read1.uuid])
        create(:policy_dismissal, :preserved, project: project2, security_findings_uuids: [vulnerability_read2.uuid])

        # Create risk scores for the vulnerability findings
        create(:vulnerability_finding_risk_score, finding: finding1, risk_score: 0.6)
        create(:vulnerability_finding_risk_score, finding: finding2, risk_score: 0.4)

        # Create refs array for initial batch
        refs = [
          described_class.new(vulnerability_read1.vulnerability_id, vulnerability_read1.es_parent)
        ]

        # Establish baseline query count
        control = ActiveRecord::QueryRecorder.new(skip_cached: false) do
          described_class.preload_indexing_data(refs)
        end

        # Create additional test data for second batch
        project3 = create(:project, group: group)

        vulnerability3 = create(:vulnerability, :with_read, project: project3, report_type: :container_scanning)

        identifier3 = create(:vulnerabilities_identifier, external_type: 'cve', external_id: 'CVE-2023-33333',
          name: 'CVE-2023-33333')

        # Create finding with CVE identifier
        finding3 = create(:vulnerabilities_finding, vulnerability: vulnerability3, project: project3,
          identifiers: [identifier3])

        # Create CVE enrichment with EPSS score for the third vulnerability
        create(:pm_cve_enrichment, cve: 'CVE-2023-33333', epss_score: 0.65)

        # Create SBOM occurrence for reachability data for the third vulnerability
        sbom_occurrence3 = create(:sbom_occurrence, reachability: 'not_found')

        vulnerability_read3 = vulnerability3.vulnerability_read

        create(:sbom_occurrences_vulnerability,
          occurrence: sbom_occurrence3,
          vulnerability_id: vulnerability_read3.vulnerability_id)

        # Create Policy Dismissal occurrences for policy_violations data
        create(:policy_dismissal, :preserved, project: project3, security_findings_uuids: [vulnerability_read3.uuid])

        # Create risk score for the third vulnerability finding
        create(:vulnerability_finding_risk_score, finding: finding3, risk_score: 0.5)

        # Add new refs to the array
        refs += [
          described_class.new(vulnerability_read2.vulnerability_id, vulnerability_read2.es_parent),
          described_class.new(vulnerability_read3.vulnerability_id, vulnerability_read3.es_parent)
        ]

        expect { described_class.preload_indexing_data(refs) }.not_to exceed_all_query_limit(control)

        expect { refs.each(&:as_indexed_json) }.not_to exceed_all_query_limit(0)
      end
    end
  end

  describe '#fetch_record_attribute' do
    let(:vulnerability_ref) { described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent) }

    subject(:fetch_record_attribute) do
      vulnerability_ref.send(:fetch_record_attribute, record, attribute)
    end

    context 'when record responds to the attribute' do
      let(:record) { vulnerability_read }
      let(:attribute) { :epss_scores }
      let(:expected_result) { [0.5, 0.8] }

      before do
        allow(record).to receive(attribute).and_return(expected_result)
        allow(record).to receive(:respond_to?).with(attribute).and_return(true)
      end

      it 'returns the attribute value' do
        expect(fetch_record_attribute).to eq(expected_result)
      end
    end

    context 'when record does not respond to the attribute' do
      let(:record) { vulnerability_read }
      let(:attribute) { :non_existent_attribute }

      before do
        allow(record).to receive(:respond_to?).with(attribute).and_return(false)
      end

      it 'returns an empty array' do
        expect(fetch_record_attribute).to eq([])
      end
    end
  end

  describe '#instantiate' do
    let(:vulnerability_ref) { described_class.new(vulnerability_read.vulnerability_id, vulnerability_read.es_parent) }

    it 'instantiates vulnerability' do
      new_vulnerability = described_class.instantiate(vulnerability_ref.serialize)
      expect(new_vulnerability.routing).to eq(vulnerability_read.es_parent)
      expect(new_vulnerability.identifier).to eq(vulnerability_read.vulnerability_id)
    end
  end

  describe '#serialize' do
    it 'returns serialized string of vulnerability record from class method' do
      expect(described_class.serialize(vulnerability_read)).to eq(
        "Vulnerability|#{vulnerability_read.vulnerability_id}|#{vulnerability_read.es_parent}")
    end

    it 'returns serialized string of vulnerability record from instance method' do
      expect(described_class.new(vulnerability_read.vulnerability_id,
        vulnerability_read.es_parent).serialize).to eq(
          "Vulnerability|#{vulnerability_read.vulnerability_id}|#{vulnerability_read.es_parent}")
    end
  end

  describe '#index_name' do
    it 'returns correct environment based index name from class method' do
      expect(described_class.index).to eq('gitlab-test-vulnerabilities')
    end

    it 'returns correct environment based index name from instance method' do
      expect(described_class.new(vulnerability_read.vulnerability_id,
        vulnerability_read.es_parent).index_name).to eq('gitlab-test-vulnerabilities')
    end
  end
end
