# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::VulnerabilityQueryBuilder, :elastic_helpers, feature_category: :vulnerability_management do
  let(:base_options) do
    {
      search_level: 'group'
    }
  end

  let(:options) { base_options }

  subject(:build) { described_class.build(query: nil, options: options) }

  it 'contains all default expected filters' do
    assert_names_in_query(build, with: %w[
      filters:archived_projects
    ])
  end

  describe 'filters' do
    let_it_be(:project) { create(:project) }

    describe 'traversal_id' do
      let(:options) { base_options.merge(traversal_ids: project.namespace.traversal_ids) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          namespace:ancestry_filter:descendants
        ])
      end
    end

    describe 'archived' do
      let(:options) { base_options.merge(include_archived_projects: true) }

      it 'show only non-archived projects vulnerabilities' do
        assert_names_in_query(build, without: %w[filters:archived_projects])
      end
    end

    describe 'cluster_agent_id' do
      let_it_be(:cluster_agent) { create(:cluster_agent, project: project) }
      let(:options) { base_options.merge(cluster_agent_id: cluster_agent.id.to_s) }

      it 'show only non-archived projects vulnerabilities' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:cluster_agent_id
        ])
      end
    end

    describe 'state and dismissal_reason' do
      context 'when state and dismissal_reason are set' do
        let(:options) { base_options.merge(dismissal_reason: [1], state: [1, 2, 3]) }

        it 'does add both state and dismissal reason filters' do
          assert_names_in_query(build, with: %w[filters:state_and_dismissal_reason])
        end
      end

      context 'when state is set but dismissal_reason is not set' do
        let(:options) { base_options.merge(state: [1, 2, 3]) }

        it 'does add only state filter' do
          assert_names_in_query(build, with: %w[filters:state])
        end
      end

      context 'when state is not set but dismissal_reason is set' do
        let(:options) { base_options.merge(dismissal_reason: [1]) }

        it 'does add only dismissal reason filters' do
          assert_names_in_query(build, with: %w[filters:dismissal_reason])
        end
      end
    end

    describe 'has_ai_resolution' do
      let(:options) { base_options.merge(has_ai_resolution: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_ai_resolution
        ])
      end
    end

    describe 'has_issues' do
      let(:options) { base_options.merge(has_issues: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_issues
        ])
      end
    end

    describe 'has_merge_request' do
      let(:options) { base_options.merge(has_merge_request: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_merge_request
        ])
      end
    end

    describe 'has_remediations' do
      let(:options) { base_options.merge(has_remediations: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_remediations
        ])
      end
    end

    describe 'has_resolution' do
      let(:options) { base_options.merge(has_resolution: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_resolution
        ])
      end
    end

    describe 'identifier_names' do
      let(:identifier_name) { 'CVE-2024-1234' }
      let(:options) { base_options.merge(identifier_name: [identifier_name]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:identifier_name
        ])
      end
    end

    describe 'image' do
      let(:options) { base_options.merge(image: ['image_name']) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:image
        ])
      end
    end

    describe 'projects' do
      let(:options) { base_options.merge(project_id: [project.id]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:project_id
        ])
      end
    end

    describe 'report_type' do
      let(:options) { base_options.merge(report_type: [1]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:report_type
        ])
      end
    end

    describe 'scanner_external_id' do
      let(:options) { base_options.merge(scanner_external_id: ["gemnasium"]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:scanner_external_id
        ])
      end
    end

    describe 'scanner_id' do
      let(:options) { base_options.merge(scanner_id: [1]) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:scanner_id
        ])
      end
    end
  end

  describe 'severity' do
    let(:options) { base_options.merge(severity: [1]) }

    it 'does add filter' do
      assert_names_in_query(build, with: %w[
        filters:archived_projects
        filters:severity
      ])
    end
  end

  it_behaves_like 'a sorted query'

  describe 'formats' do
    it_behaves_like 'a query that sets source_fields',
      ::Search::Elastic::References::Vulnerability::DEFAULT_SOURCE_FIELDS
    it_behaves_like 'a query formatted for size'
    it_behaves_like 'a query that is paginated'
  end
end
