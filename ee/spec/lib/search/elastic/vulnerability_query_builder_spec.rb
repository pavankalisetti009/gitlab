# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::VulnerabilityQueryBuilder, :elastic_helpers, feature_category: :vulnerability_management do
  let(:base_options) do
    {
      search_level: 'group'
    }
  end

  let(:options) { base_options }

  subject(:build) { described_class.build(query: nil, options: options) }

  it 'contains all default expected filters' do
    assert_names_in_query(build, with: %w[
      filters:archived_projects
    ])
  end

  describe 'filters' do
    let_it_be(:project) { create(:project) }

    describe 'traversal_id' do
      let(:options) { base_options.merge(traversal_ids: project.namespace.traversal_ids) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          namespace:ancestry_filter:descendants
        ])
      end
    end

    describe 'archived' do
      let(:options) { base_options.merge(include_archived: true) }

      it 'show only non-archived projects vulnerabilities' do
        assert_names_in_query(build, without: %w[filters:archived_projects])
      end
    end

    describe 'cluster_agent_id' do
      let_it_be(:cluster_agent) { create(:cluster_agent, project: project) }
      let(:options) { base_options.merge(cluster_agent_id: cluster_agent.id.to_s) }

      it 'show only non-archived projects vulnerabilities' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:cluster_agent_id
        ])
      end
    end

    describe 'dismissal_reason' do
      context 'when state is not dismissed' do
        let(:options) { base_options.merge(dismissal_reason: 1) }

        it 'does not add filter' do
          assert_names_in_query(build, with: %w[
            filters:archived_projects
          ])
        end
      end

      context 'when state is dismissed' do
        let(:options) { base_options.merge(dismissal_reason: 1, state: 2) }

        it 'does add filter' do
          assert_names_in_query(build, with: %w[
            filters:archived_projects
            filters:dismissal_reason
          ])
        end
      end
    end

    describe 'has_ai_resolution' do
      let(:options) { base_options.merge(has_ai_resolution: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_ai_resolution
        ])
      end
    end

    describe 'has_issues' do
      let(:options) { base_options.merge(has_issues: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_issues
        ])
      end
    end

    describe 'has_merge_request' do
      let(:options) { base_options.merge(has_merge_request: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_merge_request
        ])
      end
    end

    describe 'has_remediations' do
      let(:options) { base_options.merge(has_remediations: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_remediations
        ])
      end
    end

    describe 'has_resolution' do
      let(:options) { base_options.merge(has_resolution: true) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:has_resolution
        ])
      end
    end

    describe 'identifier_names' do
      let(:identifier_name) { 'CVE-2024-1234' }
      let(:options) { base_options.merge(identifier_names: identifier_name) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:identifier_names
        ])
      end
    end

    describe 'image' do
      let(:identifier_name) { 'CVE-2024-1234' }
      let(:options) { base_options.merge(image: 'image_name') }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:image
        ])
      end
    end

    describe 'projects' do
      let(:options) { base_options.merge(project_id: project.id) }

      context 'when level is group' do
        it 'does add filter' do
          assert_names_in_query(build, with: %w[
            filters:archived_projects
            filters:project_id
          ])
        end
      end

      context 'when level is project' do
        let(:options) do
          {
            search_level: 'project',
            project_id: project.id
          }

          it 'does not add filter' do
            assert_names_in_query(
              build,
              with: %w[
                filters:archived_projects
              ],
              without: %w[
                filters:project_id
              ])
          end
        end
      end
    end

    describe 'report_type' do
      let(:options) { base_options.merge(report_type: 1) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:report_type
        ])
      end
    end

    describe 'scanner_id' do
      let(:options) { base_options.merge(scanner_id: 1) }

      it 'does add filter' do
        assert_names_in_query(build, with: %w[
          filters:archived_projects
          filters:scanner_id
        ])
      end
    end
  end

  describe 'severity' do
    let(:options) { base_options.merge(severity: 1) }

    it 'does add filter' do
      assert_names_in_query(build, with: %w[
        filters:archived_projects
        filters:severity
      ])
    end
  end

  describe 'state' do
    let(:options) { base_options.merge(state: 1) }

    it 'does add filter' do
      assert_names_in_query(build, with: %w[
        filters:archived_projects
        filters:state
      ])
    end
  end

  it_behaves_like 'a sorted query'

  describe 'formats' do
    it_behaves_like 'a query that sets source_fields'
    it_behaves_like 'a query formatted for size'
    it_behaves_like 'a query that is paginated'
  end
end
