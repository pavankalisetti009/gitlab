# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::RecordProxy::Vulnerability, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:vulnerability) { create(:vulnerability, :with_read, project: project) }
  let(:vulnerability_record) { vulnerability.vulnerability_read }

  describe 'inheritance' do
    it 'inherits from Search::Elastic::RecordProxy::Base' do
      expect(described_class.superclass).to eq(Search::Elastic::RecordProxy::Base)
    end
  end

  describe 'initialization' do
    it 'can be initialized with a vulnerability record' do
      proxy = described_class.new(vulnerability_record)
      expect(proxy.vulnerability_id).to eq(vulnerability.id)
      expect(proxy.project_id).to eq(project.id)
    end
  end

  describe '.create_with_enhancements' do
    let(:enhancements) do
      { reachability: 1, token_status: ::Security::TokenStatus::ACTIVE,
        policy_violations: ::Security::PolicyViolations::DISMISSED_IN_MR }
    end

    it 'creates a new proxy instance' do
      proxy = described_class.create_with_enhancements(vulnerability_record, enhancements)
      expect(proxy).to be_an_instance_of(described_class)
    end

    it 'delegates to the underlying record' do
      proxy = described_class.create_with_enhancements(vulnerability_record, enhancements)

      expect(proxy.vulnerability_id).to eq(vulnerability.id)
      expect(proxy.project_id).to eq(project.id)
    end

    it 'enhances the proxy with reachability data' do
      proxy = described_class.create_with_enhancements(vulnerability_record, enhancements)

      expect(proxy.reachability).to eq(1)
    end

    it 'enhances the proxy with token_status data' do
      proxy = described_class.create_with_enhancements(vulnerability_record, enhancements)

      expect(proxy.token_status).to eq(::Security::TokenStatus::ACTIVE)
    end

    it 'enhances the proxy with policy_violations data' do
      proxy = described_class.create_with_enhancements(vulnerability_record, enhancements)

      expect(proxy.policy_violations).to eq(::Security::PolicyViolations::DISMISSED_IN_MR)
    end

    context 'with missing reachability in enhancements' do
      let(:enhancements) { { token_status: ::Security::TokenStatus::INACTIVE } }

      it 'sets reachability to nil when not provided' do
        proxy = described_class.create_with_enhancements(vulnerability_record, enhancements)

        expect(proxy.reachability).to be_nil
      end
    end

    describe 'integration with EnhancedProxy' do
      let(:refs) do
        [Search::Elastic::References::Vulnerability.new(
          vulnerability_record.vulnerability_id,
          vulnerability_record.es_parent
        )]
      end

      let(:enhanced_proxy) do
        Search::Elastic::Preloaders::Vulnerability::EnhancedProxy.new(refs, vulnerability_record)
      end

      before do
        allow(Search::Elastic::Preloaders::Vulnerability::Reachability)
          .to receive(:new).and_return(instance_double(
            Search::Elastic::Preloaders::Vulnerability::Reachability, preload: {}
          ))

        allow(Search::Elastic::Preloaders::Vulnerability::TokenStatus)
          .to receive(:new).and_return(instance_double(
            Search::Elastic::Preloaders::Vulnerability::TokenStatus, preload: {}
          ))

        allow(Search::Elastic::Preloaders::Vulnerability::PolicyViolations)
          .to receive(:new).and_return(instance_double(
            Search::Elastic::Preloaders::Vulnerability::PolicyViolations, preload: {}
          ))
      end

      it 'defaults token_status to UNKNOWN when missing' do
        enhanced_proxy.preload_and_enhance!
        proxy = refs.first.database_record

        expect(proxy.token_status).to eq(::Security::TokenStatus::UNKNOWN)
      end

      it 'defaults policy_violations to nil when missing' do
        enhanced_proxy.preload_and_enhance!
        proxy = refs.first.database_record

        expect(proxy.policy_violations).to be_nil
      end
    end
  end
end
