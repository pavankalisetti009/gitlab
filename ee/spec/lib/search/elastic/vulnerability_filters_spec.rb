# frozen_string_literal: true

require 'spec_helper'

RSpec.describe ::Search::Elastic::VulnerabilityFilters, feature_category: :vulnerability_management do
  include_context 'with filters shared context'

  describe '.by_archived_projects' do
    subject(:by_archived_projects) { described_class.by_archived_projects(query_hash: query_hash, options: options) }

    context 'when search_level not provided in options' do
      let(:options) { {} }

      it 'raises an exception' do
        expect { by_archived_projects }.to raise_exception(ArgumentError)
      end
    end

    context 'when options[:archived] is empty' do
      let(:options) { { search_level: 'group' } }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:archived] is false' do
      let(:options) { { archived: false, search_level: 'group' } }

      it 'adds the archived filter to query_hash' do
        query_hash = by_archived_projects
        expected_filter = [{ term: { archived: { _name: 'filters:archived_projects', value: false } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end

    context 'when options[:search_level] is project' do
      let(:options) { { archived: false, search_level: 'project' } }

      it_behaves_like 'does not modify the query_hash'
    end
  end

  describe '.by_cluster_agent_id' do
    subject(:by_cluster_agent_id) { described_class.by_cluster_agent_id(query_hash: query_hash, options: options) }

    context 'when options[:cluster_agent_id] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:cluster_agent_id] is provided' do
      let(:options) { { cluster_agent_id: '123' } }

      it 'adds the cluster_agent_id filter to query_hash' do
        query_hash = by_cluster_agent_id
        expected_filter = [{ term: { cluster_agent_id: { _name: 'filters:cluster_agent_id', value: '123' } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_dismissal_reason' do
    subject(:by_dismissal_reason) { described_class.by_dismissal_reason(query_hash: query_hash, options: options) }

    context 'when options[:dismissal_reason] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:dismissal_reason]is provided and state is dismissed' do
      let(:options) { { dismissal_reason: 1, state: 2 } } # "dismissed"=>2

      it 'adds the dismissal_reason filter to query_hash' do
        query_hash = by_dismissal_reason
        expected_filter = [{ term: { dismissal_reason: { _name: 'filters:dismissal_reason', value: 1 } } }]
        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_ai_resolution' do
    subject(:by_has_ai_resolution) { described_class.by_has_ai_resolution(query_hash: query_hash, options: options) }

    context 'when options[:has_ai_resolution] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_ai_resolution] contains a valid search has_ai_resolution' do
      let(:options) { { has_ai_resolution: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_ai_resolution
        expected_filter = [
          { term: { has_vulnerability_resolution: { _name: 'filters:has_ai_resolution', value: true } } }
        ]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_issues' do
    subject(:by_has_issues) { described_class.by_has_issues(query_hash: query_hash, options: options) }

    context 'when options[:has_issues] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_issues] contains a valid search has_issues' do
      let(:options) { { has_issues: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_issues
        expected_filter = [{ term: { has_issues: { _name: 'filters:has_issues', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_merge_request' do
    subject(:by_has_merge_request) { described_class.by_has_merge_request(query_hash: query_hash, options: options) }

    context 'when options[:has_merge_request] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_merge_request] contains a valid search has_merge_request' do
      let(:options) { { has_merge_request: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_merge_request
        expected_filter = [{ term: { has_merge_request: { _name: 'filters:has_merge_request', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_remediations' do
    subject(:by_has_remediations) { described_class.by_has_remediations(query_hash: query_hash, options: options) }

    context 'when options[:has_remediations] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_remediations] contains a valid search has_remediations' do
      let(:options) { { has_remediations: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_remediations
        expected_filter = [{ term: { has_remediations: { _name: 'filters:has_remediations', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_has_resolution' do
    subject(:by_has_resolution) { described_class.by_has_resolution(query_hash: query_hash, options: options) }

    context 'when options[:has_resolution] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:has_resolution] contains a valid search has_resolution' do
      let(:options) { { has_resolution: true } }

      it 'adds the report_type filter to query_hash' do
        query_hash = by_has_resolution
        expected_filter = [{ term: { resolved_on_default_branch: { _name: 'filters:has_resolution', value: true } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_identifier_names' do
    subject(:by_identifier_names) { described_class.by_identifier_names(query_hash: query_hash, options: options) }

    context 'when options[:identifiers] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:identifiers] contains a valid search identifier_name' do
      let(:options) do
        { identifier_names: %w[cve-2020-5247 ghsa-84j7-475p-hp8v,gemnasium-66c46af8-8f1d-46c9-be8e-36ee0801fba3] }
      end

      it 'adds the identifier_name filter to query_hash' do
        query_hash = by_identifier_names
        expected_filter = [
          {
            bool: {
              must: {
                terms: {
                  _name: 'filters:identifier_names',
                  identifier_names: %w[cve-2020-5247 ghsa-84j7-475p-hp8v,gemnasium-66c46af8-8f1d-46c9-be8e-36ee0801fba3]
                }
              }
            }
          }
        ]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_image' do
    subject(:by_image) { described_class.by_image(query_hash: query_hash, options: options) }

    context 'when options[:image] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:image] is provided' do
      let(:options) { { image: 'my_image' } }

      it 'adds the image filter to query_hash' do
        query_hash = by_image
        expected_filter = [{ term: { image: { _name: 'filters:image', value: 'my_image' } } }]
        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_owasp_10_2017' do
    subject(:by_owasp_10_2017) { described_class.by_owasp_10_2017(query_hash: query_hash, options: options) }

    context 'when options[:owasp_10_2017] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:owasp_10_2017] is provided' do
      let(:options) { { owasp_10_2017: true } }

      it 'adds the OWASP 2017 filter to query_hash' do
        patterns = %w[
          A1:2017* A01:2017* A2:2017* A02:2017*
          A3:2017* A03:2017* A4:2017* A04:2017*
          A5:2017* A05:2017* A6:2017* A06:2017*
          A7:2017* A07:2017* A8:2017* A08:2017*
          A9:2017* A09:2017* A10:2017*
        ].freeze

        should_clauses = patterns.map do |pattern|
          { wildcard: { identifier_name: pattern } }
        end

        expected_filter = [
          {
            _name: "filters:owasp_10_2017",
            should: should_clauses,
            minimum_should_match: 1
          }
        ]

        query_hash = by_owasp_10_2017
        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_projects' do
    subject(:by_projects) { described_class.by_projects(query_hash: query_hash, options: options) }

    context 'when search_level not provided in options' do
      let(:options) { {} }

      it 'raises an exception' do
        expect { by_projects }.to raise_exception(ArgumentError)
      end
    end

    context 'when options[:project_id] is empty' do
      let(:options) { { search_level: 'group' } }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:project_id] is provided' do
      let(:options) { { project_id: 1, search_level: 'group' } }

      it 'adds the project_id filter to query_hash' do
        query_hash = by_projects
        expected_filter = [{ term: { project_id: { _name: 'filters:project_id', value: 1 } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
        end
      end
    end
  end

  describe '.by_report_type' do
    subject(:by_report_type) { described_class.by_report_type(query_hash: query_hash, options: options) }

    context 'when options[:report_type] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:report_type] contains a valid search report_type' do
      let(:options) { { report_type: 0 } } # "sast"=>0

      it 'adds the report_type filter to query_hash' do
        query_hash = by_report_type
        expected_filter = [{ term: { report_type: { _name: 'filters:report_type', value: 0 } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
        end
      end
    end
  end

  describe '.by_scanner_ids' do
    subject(:by_scanner_ids) { described_class.by_scanner_ids(query_hash: query_hash, options: options) }

    context 'when options[:scanner_id] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:scanner_id] contains a valid search scanner_id' do
      let(:options) { { scanner_id: 1 } }

      it 'adds the scanner_id filter to query_hash' do
        query_hash = by_scanner_ids
        expected_filter = [{ term: { scanner_id: { _name: 'filters:scanner_id', value: 1 } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
        end
      end
    end
  end

  describe '.by_severities' do
    subject(:by_severities) { described_class.by_severities(query_hash: query_hash, options: options) }

    context 'when options[:severity] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'

      context 'when options[:severity] contains a valid search severity' do
        let(:options) { { severity: 7 } } # "critical"=>7

        it 'adds the severity filter to query_hash' do
          query_hash = by_severities
          expected_filter = [{ term: { severity: { _name: 'filters:severity', value: 7 } } }]

          aggregate_failures do
            expect(query_hash.dig(:query, :bool, :must)).to be_empty
            expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
            expect(query_hash.dig(:query, :bool, :should)).to be_empty
            expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
          end
        end
      end
    end
  end

  describe '.by_state' do
    subject(:by_state) { described_class.by_state(query_hash: query_hash, options: options) }

    context 'when options[:state] is empty' do
      let(:options) { {} }

      it_behaves_like 'does not modify the query_hash'
    end

    context 'when options[:state] contains a valid search state' do
      let(:options) { { state: 1 } } # "detected"=>1

      it 'adds the state filter to query_hash' do
        query_hash = by_state
        expected_filter = [{ term: { state: { _name: 'filters:state', value: 1 } } }]

        aggregate_failures do
          expect(query_hash.dig(:query, :bool, :must)).to be_empty
          expect(query_hash.dig(:query, :bool, :must_not)).to be_empty
          expect(query_hash.dig(:query, :bool, :should)).to be_empty
          expect(query_hash.dig(:query, :bool, :filter)).to eq(expected_filter)
        end
      end
    end
  end
end
