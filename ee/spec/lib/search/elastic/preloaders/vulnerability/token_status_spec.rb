# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::TokenStatus, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:reads_by_status) do
    {
      active: create_read_with_status(Security::TokenStatus::ACTIVE, project),
      inactive: create_read_with_status(Security::TokenStatus::INACTIVE, project),
      unknown: create_read_with_status(Security::TokenStatus::UNKNOWN, project)
    }
  end

  def create_read_with_status(status, project)
    vuln = create(:vulnerability, :with_read, project: project)

    finding = create(
      :vulnerabilities_finding,
      report_type: :secret_detection,
      vulnerability: vuln
    )

    create(:finding_token_status, finding: finding, status: status) if status != ::Security::TokenStatus::UNKNOWN

    vuln.vulnerability_read
  end

  describe '#preload' do
    subject(:preloader) { described_class.new(records) }

    context 'with vulnerability records having different token statuses' do
      let(:records) { reads_by_status.values }

      it 'returns token status for vulnerabilities with DB entries' do
        result = preloader.preload

        expect(result[reads_by_status[:active].vulnerability_id]).to eq(::Security::TokenStatus::ACTIVE)
        expect(result[reads_by_status[:inactive].vulnerability_id]).to eq(::Security::TokenStatus::INACTIVE)
      end

      it 'includes vulnerabilities without DB entries as UNKNOWN' do
        result = preloader.preload

        expect(result[reads_by_status[:active].vulnerability_id]).to eq(::Security::TokenStatus::ACTIVE)
        expect(result[reads_by_status[:inactive].vulnerability_id]).to eq(::Security::TokenStatus::INACTIVE)
        expect(result[reads_by_status[:unknown].vulnerability_id]).to eq(::Security::TokenStatus::UNKNOWN)
      end
    end

    context 'with edge cases' do
      context 'when records are empty' do
        let(:records) { [] }

        it 'returns empty hash' do
          expect(preloader.preload).to eq({})
        end
      end

      context 'when database query fails' do
        let(:records) { [reads_by_status[:active]] }

        before do
          allow(::Vulnerabilities::Finding).to receive(:by_vulnerability).and_raise(StandardError, 'Database error')
          allow(::Gitlab::ErrorTracking).to receive(:track_exception)
        end

        it 'handles errors gracefully and tracks exceptions' do
          result = preloader.preload

          expect(result).to eq({})
          expect(::Gitlab::ErrorTracking).to have_received(:track_exception)
                                               .with(instance_of(StandardError), class: described_class.name)
        end
      end
    end
  end

  describe '#data_for' do
    subject(:preloader) do
      described_class.new([
        reads_by_status[:active],
        reads_by_status[:inactive]
      ])
    end

    it 'returns preloaded token status data for specific vulnerability' do
      preloader.preload
      data = preloader.data_for(reads_by_status[:active])

      expect(data).to eq(::Security::TokenStatus::ACTIVE)
    end

    it 'returns nil for vulnerability not in preloaded records' do
      preloader.preload
      data = preloader.data_for(reads_by_status[:unknown])

      expect(data).to be_nil
    end
  end

  describe 'base class integration' do
    subject(:preloader) do
      described_class.new([
        reads_by_status[:active],
        reads_by_status[:inactive]
      ])
    end

    it 'tracks preloaded state correctly' do
      expect(preloader.preloaded?).to be false

      preloader.preload

      expect(preloader.preloaded?).to be true
    end

    it 'caches preloaded data to avoid duplicate queries' do
      expect(::Vulnerabilities::Finding).to receive(:by_vulnerability).once.and_call_original

      result1 = preloader.preload
      result2 = preloader.preload

      expect(result1).to eq(result2)
    end

    it 'handles single record input' do
      single_preloader = described_class.new(reads_by_status[:active])
      result = single_preloader.preload

      expect(result).to have_key(reads_by_status[:active].vulnerability_id)
      expect(result[reads_by_status[:active].vulnerability_id]).to eq(::Security::TokenStatus::ACTIVE)
    end

    it 'deduplicates records correctly' do
      duplicate_records = [
        reads_by_status[:active],
        reads_by_status[:active],
        reads_by_status[:inactive]
      ]
      duplicate_preloader = described_class.new(duplicate_records)
      result = duplicate_preloader.preload

      expect(result.keys).to match_array([
        reads_by_status[:active].vulnerability_id,
        reads_by_status[:inactive].vulnerability_id
      ])
    end
  end

  describe 'performance characteristics' do
    let_it_be(:large_vulnerability_set) do
      create_list(:vulnerability, 5, :with_read, project: project).map(&:vulnerability_read)
    end

    it 'performs efficient batch querying' do
      preloader = described_class.new(large_vulnerability_set)

      expect { preloader.preload }.not_to exceed_query_limit(3)
    end
  end
end
