# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::EnhancedProxy, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:vulnerabilities) do
    create_list(:vulnerability, 3, :with_read, project: project)
  end

  let_it_be(:vulnerability_reads) { vulnerabilities.map(&:vulnerability_read) }

  let(:refs) do
    vulnerability_reads.map do |vuln_read|
      Search::Elastic::References::Vulnerability.new(
        vuln_read.vulnerability_id, vuln_read.es_parent)
    end
  end

  let(:mock_reachability_preloader) { instance_double(Search::Elastic::Preloaders::Vulnerability::Reachability) }
  let(:mock_token_status_preloader) { instance_double(Search::Elastic::Preloaders::Vulnerability::TokenStatus) }
  let(:mock_policy_violations_preloader) do
    instance_double(Search::Elastic::Preloaders::Vulnerability::PolicyViolations)
  end

  let(:mock_risk_score_preloader) { instance_double(Search::Elastic::Preloaders::Vulnerability::RiskScore) }

  let(:reachability_data) do
    {
      vulnerability_reads[0].vulnerability_id => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::IN_USE],
      vulnerability_reads[1].vulnerability_id => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::NOT_FOUND]
    }
  end

  let(:token_status_data) do
    {
      vulnerability_reads[0].vulnerability_id => ::Security::TokenStatus::ACTIVE,
      vulnerability_reads[1].vulnerability_id => ::Security::TokenStatus::INACTIVE
      # third intentionally missing
    }
  end

  let(:policy_violations_data) do
    {
      vulnerability_reads[0].vulnerability_id => ::Security::PolicyViolations::DISMISSED_IN_MR,
      vulnerability_reads[1].vulnerability_id => nil
    }
  end

  let(:risk_score_data) do
    {
      vulnerability_reads[0].vulnerability_id => 0.4,
      vulnerability_reads[1].vulnerability_id => 0.6
      # third intentionally missing
    }
  end

  let(:enhanced_proxy) { described_class.new(refs, vulnerability_reads) }

  before do
    allow(Search::Elastic::Preloaders::Vulnerability::Reachability)
      .to receive(:new)
      .with(vulnerability_reads)
      .and_return(mock_reachability_preloader)

    allow(mock_reachability_preloader)
      .to receive(:preload)
      .and_return(reachability_data)

    allow(Search::Elastic::Preloaders::Vulnerability::TokenStatus)
      .to receive(:new)
            .with(vulnerability_reads)
            .and_return(mock_token_status_preloader)

    allow(mock_token_status_preloader)
      .to receive(:preload)
            .and_return(token_status_data)

    allow(Search::Elastic::Preloaders::Vulnerability::PolicyViolations)
      .to receive(:new)
            .with(vulnerability_reads)
            .and_return(mock_policy_violations_preloader)

    allow(mock_policy_violations_preloader)
      .to receive(:preload)
            .and_return(policy_violations_data)
        .and_return(policy_violations_data)

    allow(Search::Elastic::Preloaders::Vulnerability::RiskScore)
    .to receive(:new)
      .with(vulnerability_reads)
      .and_return(mock_risk_score_preloader)

    allow(mock_risk_score_preloader)
      .to receive(:preload)
            .and_return(risk_score_data)
  end

  describe '#initialize' do
    it 'creates index of records by vulnerability_id' do
      records_by_id = enhanced_proxy.instance_variable_get(:@records_by_id)

      expect(records_by_id.keys).to match_array(vulnerability_reads.map(&:vulnerability_id))
      expect(records_by_id[vulnerability_reads[0].vulnerability_id]).to eq(vulnerability_reads[0])
    end

    context 'with single record' do
      let(:single_proxy) { described_class.new(refs, vulnerability_reads.first) }

      it 'normalizes single record to array' do
        records_by_id = single_proxy.instance_variable_get(:@records_by_id)
        expect(records_by_id.keys).to eq([vulnerability_reads.first.vulnerability_id])
      end
    end
  end

  describe '#preload_and_enhance!' do
    it 'preloads reachability, token status, policy_violations and risk score data' do
      enhanced_proxy.preload_and_enhance!

      expect(Search::Elastic::Preloaders::Vulnerability::Reachability)
        .to have_received(:new).with(vulnerability_reads)
      expect(mock_reachability_preloader).to have_received(:preload)

      expect(Search::Elastic::Preloaders::Vulnerability::TokenStatus)
        .to have_received(:new).with(vulnerability_reads)
      expect(mock_token_status_preloader).to have_received(:preload)

      expect(Search::Elastic::Preloaders::Vulnerability::PolicyViolations)
        .to have_received(:new).with(vulnerability_reads)
      expect(mock_policy_violations_preloader).to have_received(:preload)

      expect(Search::Elastic::Preloaders::Vulnerability::RiskScore)
        .to have_received(:new).with(vulnerability_reads)
      expect(mock_risk_score_preloader).to have_received(:preload)
    end

    it 'creates enhanced proxies for matching refs' do
      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .exactly(3).times
        .and_call_original

      enhanced_proxy.preload_and_enhance!

      refs.each do |ref|
        database_record = ref.database_record
        expect(database_record).to be_an_instance_of(Search::Elastic::RecordProxy::Vulnerability)
      end
    end

    context 'with unmatched ref identifier' do
      let(:unmatched_ref) do
        Search::Elastic::References::Vulnerability.new(
          vulnerability_reads.last.id + 99999,
          vulnerability_reads.last.es_parent)
      end

      let(:mixed_refs) { refs + [unmatched_ref] }
      let(:mixed_proxy) { described_class.new(mixed_refs, vulnerability_reads) }

      it 'skips unmatched refs but processes matched ones' do
        mixed_proxy.preload_and_enhance!

        expect(unmatched_ref.database_record).to be_nil

        refs.each do |ref|
          database_record = ref.database_record
          expect(database_record).to be_an_instance_of(Search::Elastic::RecordProxy::Vulnerability)
        end
      end
    end
  end

  describe 'proxy enhancement' do
    it 'enhances proxies with correct reachability, token_status policy_violations and risk_score data' do
      expected_enhancements_in_use = {
        'reachability' => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::IN_USE],
        'token_status' => ::Security::TokenStatus::ACTIVE,
        'policy_violations' => ::Security::PolicyViolations::DISMISSED_IN_MR,
        'risk_score' => 0.4
      }.with_indifferent_access

      expected_enhancements_not_found = {
        'reachability' => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::NOT_FOUND],
        'token_status' => ::Security::TokenStatus::INACTIVE,
        'policy_violations' => nil,
        'risk_score' => 0.6
      }.with_indifferent_access

      expected_enhancements_unknown = {
        'reachability' => ::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::UNKNOWN],
        'token_status' => ::Security::TokenStatus::UNKNOWN,
        'policy_violations' => nil,
        'risk_score' => 0.0
      }.with_indifferent_access

      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .with(vulnerability_reads[0], expected_enhancements_in_use)
        .and_call_original

      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .with(vulnerability_reads[1], expected_enhancements_not_found)
        .and_call_original

      expect(::Search::Elastic::RecordProxy::Vulnerability)
        .to receive(:create_with_enhancements)
        .with(vulnerability_reads[2], expected_enhancements_unknown)
        .and_call_original

      enhanced_proxy.preload_and_enhance!
    end

    it 'creates working proxies that delegate to original records' do
      enhanced_proxy.preload_and_enhance!

      assigned_proxy = refs[0].database_record
      expect(assigned_proxy.vulnerability_id).to eq(vulnerability_reads[0].vulnerability_id)
      expect(assigned_proxy.project_id).to eq(vulnerability_reads[0].project_id)
      expect(assigned_proxy.reachability).to eq(reachability_data[vulnerability_reads[0].vulnerability_id])
      expect(assigned_proxy.token_status).to eq(token_status_data[vulnerability_reads[0].vulnerability_id])
      expect(assigned_proxy.policy_violations).to eq(policy_violations_data[vulnerability_reads[0].vulnerability_id])
      expect(assigned_proxy.risk_score).to eq(risk_score_data[vulnerability_reads[0].vulnerability_id])
    end
  end

  describe 'error handling' do
    context 'when reachability preloader fails' do
      before do
        allow(mock_reachability_preloader)
          .to receive(:preload)
          .and_raise(StandardError, 'Preloader failed')
      end

      it 'propagates the error' do
        expect { enhanced_proxy.preload_and_enhance! }
          .to raise_error(StandardError, 'Preloader failed')
      end
    end
  end

  describe '#fetch_reachability_value' do
    it 'returns preloaded value when available' do
      enhanced_proxy.instance_variable_set(:@reachability_data, { 123 => 'in_use' })

      result = enhanced_proxy.send(:fetch_reachability_value, 123)
      expect(result).to eq('in_use')
    end

    it 'returns UNKNOWN for missing data' do
      enhanced_proxy.instance_variable_set(:@reachability_data, {})

      result = enhanced_proxy.send(:fetch_reachability_value, 123)
      expect(result).to eq(::Enums::Sbom::REACHABILITY_TYPES[::Enums::Sbom::UNKNOWN])
    end
  end

  describe '#fetch_token_status_value' do
    it 'returns preloaded value when available' do
      enhanced_proxy.instance_variable_set(:@token_status_data, { 123 => ::Security::TokenStatus::ACTIVE })

      result = enhanced_proxy.send(:fetch_token_status_value, 123)
      expect(result).to eq(::Security::TokenStatus::ACTIVE)
    end

    it 'returns UNKNOWN for missing data' do
      enhanced_proxy.instance_variable_set(:@token_status_data, {})

      result = enhanced_proxy.send(:fetch_token_status_value, 999)
      expect(result).to eq(::Security::TokenStatus::UNKNOWN)
    end
  end

  describe '#fetch_policy_violations_value' do
    it 'returns preloaded value when available' do
      enhanced_proxy.instance_variable_set(:@policy_violations_data,
        { 123 => ::Security::PolicyViolations::DISMISSED_IN_MR })

      result = enhanced_proxy.send(:fetch_policy_violation_value, 123)
      expect(result).to eq(::Security::PolicyViolations::DISMISSED_IN_MR)
    end

    it 'returns nil for missing data' do
      enhanced_proxy.instance_variable_set(:@policy_violations_data, {})

      result = enhanced_proxy.send(:fetch_policy_violation_value, 999)
      expect(result).to be_nil
    end
  end

  describe '#fetch_risk_score_value' do
    it 'returns preloaded value when available' do
      enhanced_proxy.instance_variable_set(:@risk_score_data, { 123 => 0.5 })

      result = enhanced_proxy.send(:fetch_risk_score_value, 123)
      expect(result).to eq(0.5)
    end

    it 'returns UNKNOWN for missing data' do
      enhanced_proxy.instance_variable_set(:@risk_score_data, {})

      result = enhanced_proxy.send(:fetch_risk_score_value, 123)
      expect(result).to eq(0.0)
    end
  end
end
