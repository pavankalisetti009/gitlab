# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::PolicyAutoDismissed, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:security_policy_bot) { create(:user, :security_policy_bot) }
  let_it_be(:regular_user) { create(:user) }
  let_it_be(:reads_by_policy_auto_dismissed_type) do
    {
      policy_auto_dismissed: create_read_with_policy_violations(true, security_policy_bot),
      dismissed: create_read_with_policy_violations(true, regular_user),
      not_dismissed: create_read_with_policy_violations(false)
    }
  end

  def create_read_with_policy_violations(dismissed, dismissed_by = nil)
    vulnerability = if dismissed
                      create(:vulnerability, :with_finding, :dismissed, dismissed_by: dismissed_by, project: project)
                    else
                      create(:vulnerability, :with_finding, project: project)
                    end

    vulnerability.vulnerability_read
  end

  describe '#preload' do
    subject(:preloader) { described_class.new(records) }

    context 'with vulnerability records auto dismissed by security policies' do
      let(:records) { reads_by_policy_auto_dismissed_type.values }

      it 'returns policy_auto_dismissed value for vulnerabilities' do
        result = preloader.preload

        vulnerability_auto_dismissed = reads_by_policy_auto_dismissed_type[:policy_auto_dismissed].vulnerability_id
        vulnerability_not_dismissed = reads_by_policy_auto_dismissed_type[:not_dismissed].vulnerability_id
        vulnerability_dismissed = reads_by_policy_auto_dismissed_type[:dismissed].vulnerability_id

        expect(result[vulnerability_auto_dismissed]).to be(true)
        expect(result[vulnerability_not_dismissed]).to be(false)
        expect(result[vulnerability_dismissed]).to be(false)
      end

      context 'when the feature flag `auto_dismiss_vulnerability_policies` is_disabled' do
        before do
          stub_feature_flags(auto_dismiss_vulnerability_policies: false)
        end

        it 'returns false even if the vulnerability was auto dismissed by a security policy' do
          result = preloader.preload

          vulnerability_auto_dismissed = reads_by_policy_auto_dismissed_type[:policy_auto_dismissed].vulnerability_id

          expect(result[vulnerability_auto_dismissed]).to be(false)
        end
      end
    end

    context 'with edge cases' do
      context 'when records are empty' do
        let(:records) { [] }

        it 'returns empty hash' do
          expect(preloader.preload).to eq({})
        end
      end

      context 'when database query fails' do
        let(:records) { reads_by_policy_auto_dismissed_type.values }

        before do
          allow(::Vulnerability).to receive(:by_ids).and_raise(StandardError, 'Database error')
          allow(::Gitlab::ErrorTracking).to receive(:track_exception)
        end

        it 'handles errors gracefully and tracks exceptions' do
          result = preloader.preload

          expect(result).to eq({})
          expect(::Gitlab::ErrorTracking).to have_received(:track_exception)
                                               .with(instance_of(StandardError), class: described_class.name)
        end
      end
    end

    describe 'performance characteristics' do
      let_it_be(:large_vulnerability_set) do
        create_list(:vulnerability, 5, :with_read, :dismissed, dismissed_by: security_policy_bot,
          project: project).map(&:vulnerability_read)
      end

      let_it_be(:extra_vulnerability_set) do
        create_list(:vulnerability, 2, :with_read, :dismissed, dismissed_by: security_policy_bot,
          project: project).map(&:vulnerability_read)
      end

      it 'performs efficient batch querying' do
        preloader = described_class.new(large_vulnerability_set)

        expect { preloader.preload }.not_to exceed_query_limit(3)
      end

      it 'avoids N+1 queries with larger datasets' do
        preloader = described_class.new(large_vulnerability_set)
        control_count = count_queries { preloader.preload }

        # Adding more records should not increase query count
        larger_set = large_vulnerability_set + extra_vulnerability_set
        larger_preloader = described_class.new(larger_set)

        expect { larger_preloader.preload }.not_to exceed_query_limit(control_count)
      end
    end
  end

  private

  def count_queries(&block)
    ActiveRecord::QueryRecorder.new(&block).count
  end
end
