# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::UndetectedSince,
  feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }

  def create_vulnerability_with_detection_transition(detected:, created_at: Time.current)
    vulnerability = create(:vulnerability, :with_read, project: project)
    finding = create(:vulnerabilities_finding, vulnerability: vulnerability)

    create(:vulnerability_detection_transition,
      finding: finding,
      detected: detected,
      created_at: created_at
    )

    vulnerability.vulnerability_read
  end

  describe '#preload' do
    subject(:preloader) { described_class.new(records) }

    context 'with vulnerabilities having different detection states' do
      let_it_be(:vuln_undetected) do
        create_vulnerability_with_detection_transition(detected: false, created_at: 2.days.ago)
      end

      let_it_be(:vuln_detected) do
        create_vulnerability_with_detection_transition(detected: true, created_at: 1.day.ago)
      end

      let(:records) { [vuln_undetected, vuln_detected] }

      it 'returns undetected_since timestamp for undetected vulnerabilities',
        quarantine: 'https://gitlab.com/gitlab-org/quality/test-failure-issues/-/issues/20776' do
        result = preloader.preload

        expect(result[vuln_undetected.vulnerability_id]).to be_present
        expect(result[vuln_undetected.vulnerability_id]).to be_within(5.seconds).of(2.days.ago)
      end

      it 'does not include detected vulnerabilities in the result' do
        result = preloader.preload

        expect(result).not_to have_key(vuln_detected.vulnerability_id)
      end
    end

    context 'with vulnerabilities having multiple detection transitions' do
      let_it_be(:vuln_with_multiple_transitions) do
        vulnerability = create(:vulnerability, :with_read, project: project)
        finding = create(:vulnerabilities_finding, vulnerability: vulnerability)

        create(:vulnerability_detection_transition,
          finding: finding,
          detected: true,
          created_at: 3.days.ago
        )

        create(:vulnerability_detection_transition,
          finding: finding,
          detected: false,
          created_at: 1.day.ago
        )

        vulnerability.vulnerability_read
      end

      let(:records) { [vuln_with_multiple_transitions] }

      it 'returns the timestamp from the latest detection transition' do
        result = preloader.preload

        expect(result[vuln_with_multiple_transitions.vulnerability_id]).to be_within(1.second).of(1.day.ago)
      end
    end

    context 'with edge cases' do
      context 'when records are empty' do
        let(:records) { [] }

        it 'returns an empty hash' do
          expect(preloader.preload).to eq({})
        end
      end

      context 'when vulnerability has no detection transitions' do
        let_it_be(:vuln_without_transition) do
          vulnerability = create(:vulnerability, :with_read, project: project)
          create(:vulnerabilities_finding, vulnerability: vulnerability)
          vulnerability.vulnerability_read
        end

        let(:records) { [vuln_without_transition] }

        it 'does not include the vulnerability in the result' do
          result = preloader.preload

          expect(result).not_to have_key(vuln_without_transition.vulnerability_id)
        end
      end

      context 'when database query raises an error' do
        let(:records) { [create_vulnerability_with_detection_transition(detected: false)] }

        before do
          allow(::Vulnerabilities::Finding)
            .to receive(:by_vulnerability)
            .and_raise(StandardError, 'DB failure')

          allow(::Gitlab::ErrorTracking).to receive(:track_exception)
        end

        it 'handles gracefully and tracks the error' do
          result = begin
            preloader.preload
          rescue StandardError
            {}
          end

          expect(result).to eq({})
          expect(::Gitlab::ErrorTracking).to have_received(:track_exception)
            .with(instance_of(StandardError), class: described_class.name)
        end
      end
    end
  end

  describe '#data_for' do
    let_it_be(:vuln_undetected) do
      create_vulnerability_with_detection_transition(detected: false, created_at: 2.days.ago)
    end

    let_it_be(:vuln_detected) do
      create_vulnerability_with_detection_transition(detected: true)
    end

    subject(:preloader) { described_class.new([vuln_undetected, vuln_detected]) }

    before do
      preloader.preload
    end

    it 'returns undetected_since timestamp for undetected vulnerabilities',
      quarantine: 'https://gitlab.com/gitlab-org/quality/test-failure-issues/-/issues/20775' do
      expect(preloader.data_for(vuln_undetected)).to be_within(5.seconds).of(2.days.ago)
    end

    it 'returns nil for detected vulnerabilities' do
      expect(preloader.data_for(vuln_detected)).to be_nil
    end

    it 'returns nil for unknown vulnerability' do
      unknown_read = create(:vulnerability, :with_read, project: project).vulnerability_read
      expect(preloader.data_for(unknown_read)).to be_nil
    end
  end

  describe 'integration with PreloaderBase' do
    let_it_be(:vuln_undetected) do
      create_vulnerability_with_detection_transition(detected: false)
    end

    subject(:preloader) { described_class.new([vuln_undetected]) }

    it 'tracks preload state correctly' do
      expect(preloader.preloaded?).to be false
      preloader.preload
      expect(preloader.preloaded?).to be true
    end

    it 'deduplicates vulnerabilities before querying' do
      duplicates = [vuln_undetected, vuln_undetected]
      preloader = described_class.new(duplicates)

      expect(::Vulnerabilities::Finding).to receive(:by_vulnerability).once.and_call_original
      preloader.preload
    end

    it 'caches preloaded data to avoid duplicate queries' do
      expect(::Vulnerabilities::Finding).to receive(:by_vulnerability).once.and_call_original

      result1 = preloader.preload
      result2 = preloader.preload

      expect(result1).to eq(result2)
    end
  end

  describe 'performance characteristics' do
    let_it_be(:large_vulnerability_set) do
      Array.new(5) do
        create_vulnerability_with_detection_transition(detected: false, created_at: rand(1..10).days.ago)
      end
    end

    it 'performs batch queries efficiently' do
      preloader = described_class.new(large_vulnerability_set)
      expect { preloader.preload }.not_to exceed_query_limit(3)
    end

    it 'avoids N+1 queries with larger datasets' do
      initial_set = large_vulnerability_set.take(2)
      preloader = described_class.new(initial_set)
      control = ActiveRecord::QueryRecorder.new { preloader.preload }

      larger_preloader = described_class.new(large_vulnerability_set)

      expect { larger_preloader.preload }.not_to exceed_query_limit(control)
    end
  end
end
