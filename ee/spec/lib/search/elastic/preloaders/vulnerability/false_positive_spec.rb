# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::FalsePositive,
  feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:vuln_with_flag) { create_vulnerability_with_flag }
  let_it_be(:vuln_without_flag) { create_vulnerability_with_flag(has_flag: false) }

  def create_vulnerability_with_flag(has_flag: true)
    vulnerability = create(:vulnerability, :with_read, project: project)
    create(:vulnerabilities_finding, vulnerability: vulnerability)

    if has_flag
      create(:vulnerabilities_flag, :false_positive,
        finding: vulnerability.findings.first)
    end

    vulnerability.vulnerability_read
  end

  describe '#preload' do
    subject(:preloader) { described_class.new(records) }

    context 'with mixed vulnerability false_positive flags' do
      let(:records) { [vuln_with_flag, vuln_without_flag] }

      it 'returns true for vulnerabilities with a false positive flag' do
        result = preloader.preload
        expect(result[vuln_with_flag.vulnerability_id]).to be(true)
      end

      it 'returns false for vulnerabilities without a false positive flag' do
        result = preloader.preload
        expect(result[vuln_without_flag.vulnerability_id]).to be(false)
      end
    end

    context 'with edge cases' do
      context 'when records are empty' do
        let(:records) { [] }

        it 'returns an empty hash' do
          expect(preloader.preload).to eq({})
        end
      end

      context 'when database query raises an error' do
        let(:records) { [vuln_with_flag] }

        before do
          allow(::Vulnerabilities::Finding)
            .to receive(:by_vulnerability)
                  .and_raise(StandardError, 'DB failure')

          allow(::Gitlab::ErrorTracking).to receive(:track_exception)
        end

        it 'handles gracefully and tracks the error' do
          result = begin
            preloader.preload
          rescue StandardError
            {}
          end

          expect(result).to eq({})
          expect(::Gitlab::ErrorTracking).to have_received(:track_exception)
            .with(instance_of(StandardError), class: described_class.name)
        end
      end
    end
  end

  describe '#data_for' do
    subject(:preloader) { described_class.new([vuln_with_flag, vuln_without_flag]) }

    before do
      preloader.preload
    end

    it 'returns true for vulnerabilities with false positive flag' do
      expect(preloader.data_for(vuln_with_flag)).to be(true)
    end

    it 'returns false for vulnerabilities without false positive flag' do
      expect(preloader.data_for(vuln_without_flag)).to be(false)
    end

    it 'returns nil for unknown vulnerability' do
      unknown_read = create(:vulnerability, :with_read, project: project).vulnerability_read
      expect(preloader.data_for(unknown_read)).to be_nil
    end
  end

  describe 'integration with PreloaderBase' do
    subject(:preloader) { described_class.new([vuln_with_flag, vuln_without_flag]) }

    it 'tracks preload state correctly' do
      expect(preloader.preloaded?).to be false
      preloader.preload
      expect(preloader.preloaded?).to be true
    end

    it 'deduplicates vulnerabilities before querying' do
      duplicates = [vuln_with_flag, vuln_with_flag, vuln_without_flag]
      preloader = described_class.new(duplicates)

      expect(::Vulnerabilities::Finding).to receive(:by_vulnerability).once.and_call_original
      preloader.preload
    end
  end

  describe 'performance characteristics' do
    let_it_be(:large_vulnerability_set) do
      create_list(:vulnerability, 5, :with_read, project: project).map do |v|
        create(:vulnerabilities_finding, vulnerability: v)
        create(:vulnerabilities_flag, :false_positive, finding: v.findings.first)
        v.vulnerability_read
      end
    end

    it 'performs batch queries efficiently' do
      preloader = described_class.new(large_vulnerability_set)
      expect { preloader.preload }.not_to exceed_query_limit(3)
    end
  end
end
