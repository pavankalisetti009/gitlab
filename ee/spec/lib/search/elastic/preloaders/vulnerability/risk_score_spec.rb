# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::RiskScore, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }

  let_it_be(:risk_scores) do
    {
      high: 0.7,
      medium: 0.4,
      low: 0.05
    }
  end

  let_it_be(:reads_by_risk_score) do
    risk_scores.transform_values { |score| create_read_with_risk_score(score, project) }
  end

  describe '#preload' do
    subject(:preloader) { described_class.new(records) }

    context 'with vulnerability records having different risk scores' do
      let(:records) { reads_by_risk_score.values }

      it 'returns risk score data for all vulnerabilities' do
        result = preloader.preload

        expect(result).to be_a(Hash)
        expect(result.keys).to match_array(reads_by_risk_score.values.map(&:vulnerability_id))
        expect(result.values).to match_array(risk_scores.values)
      end
    end

    context 'with edge cases' do
      context 'when records are empty' do
        let(:records) { [] }

        it 'returns empty hash' do
          expect(preloader.preload).to eq({})
        end
      end

      context 'when database query fails' do
        let(:records) { [reads_by_risk_score[:high]] }

        before do
          allow(::Vulnerabilities::Finding).to receive(:by_vulnerability).and_raise(StandardError, 'Database error')
          allow(::Gitlab::ErrorTracking).to receive(:track_exception)
        end

        it 'handles errors gracefully and tracks exceptions' do
          result = preloader.preload

          expect(result).to eq({})
          expect(::Gitlab::ErrorTracking).to have_received(:track_exception)
                                               .with(instance_of(StandardError), class: described_class.name)
        end
      end
    end
  end

  describe '#data_for' do
    subject(:preloader) do
      described_class.new([
        reads_by_risk_score[:high],
        reads_by_risk_score[:medium]
      ])
    end

    it 'returns preloaded risk score data for specific vulnerability' do
      preloader.preload
      data = preloader.data_for(reads_by_risk_score[:high])

      expect(data).to eq(risk_scores[:high])
    end
  end

  describe 'base class integration' do
    subject(:preloader) do
      described_class.new([
        reads_by_risk_score[:high],
        reads_by_risk_score[:medium]
      ])
    end

    it 'tracks preloaded state correctly' do
      expect(preloader.preloaded?).to be false

      preloader.preload

      expect(preloader.preloaded?).to be true
    end

    it 'caches preloaded data to avoid duplicate queries' do
      expect(::Vulnerabilities::Finding).to receive(:by_vulnerability).once.and_call_original

      result1 = preloader.preload
      result2 = preloader.preload

      expect(result1).to eq(result2)
    end

    it 'handles single record input' do
      single_preloader = described_class.new(reads_by_risk_score[:high])
      result = single_preloader.preload

      expect(result).to have_key(reads_by_risk_score[:high].vulnerability_id)
      expect(result[reads_by_risk_score[:high].vulnerability_id]).to eq(risk_scores[:high])
    end

    it 'deduplicates records correctly' do
      duplicate_records = [
        reads_by_risk_score[:high],
        reads_by_risk_score[:high],
        reads_by_risk_score[:medium]
      ]
      duplicate_preloader = described_class.new(duplicate_records)

      result = duplicate_preloader.preload

      expect(result.keys).to match_array([
        reads_by_risk_score[:high].vulnerability_id,
        reads_by_risk_score[:medium].vulnerability_id
      ])
    end
  end

  describe 'performance characteristics' do
    let_it_be(:additional_reads_by_risk_score) do
      {
        vuln1: create_read_with_risk_score(0.1, project),
        vuln2: create_read_with_risk_score(0.5, project)
      }
    end

    it 'performs efficient batch querying' do
      preloader = described_class.new(reads_by_risk_score.values)

      expect { preloader.preload }.not_to exceed_query_limit(3)
    end

    it 'avoids N+1 queries with larger datasets' do
      preloader = described_class.new(reads_by_risk_score.values)
      control = ActiveRecord::QueryRecorder.new { preloader.preload }

      larger_set = reads_by_risk_score.values + [additional_reads_by_risk_score[:vuln1],
        additional_reads_by_risk_score[:vuln2]]
      larger_preloader = described_class.new(larger_set)

      expect { larger_preloader.preload }.not_to exceed_query_limit(control)
    end
  end

  private

  def create_read_with_risk_score(risk_score, project)
    vuln = create(:vulnerability, :with_read, project: project)
    finding = create(:vulnerabilities_finding, vulnerability: vuln)

    create(:vulnerability_finding_risk_score, finding: finding, risk_score: risk_score)

    vuln.vulnerability_read
  end
end
