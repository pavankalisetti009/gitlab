# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Preloaders::Vulnerability::PolicyViolations, feature_category: :vulnerability_management do
  let_it_be(:project) { create(:project) }
  let_it_be(:reads_by_policy_violation_type) do
    {
      dismissed_in_mr: create_read_with_policy_violations(true, project),
      no_violations: create_read_with_policy_violations(false, project)
    }
  end

  def create_read_with_policy_violations(has_violations, project)
    vulnerability = create(:vulnerability, :with_finding, project: project)

    if has_violations
      create(:policy_dismissal, :preserved, project: project,
        security_findings_uuids: [vulnerability.finding.uuid])
    end

    vulnerability.vulnerability_read
  end

  describe '#preload' do
    subject(:preloader) { described_class.new(records) }

    context 'with vulnerability records having different policy violation types' do
      let(:records) { reads_by_policy_violation_type.values }

      it 'returns policy violation status for vulnerabilities' do
        result = preloader.preload

        vulnerability_dismissed_in_mr = reads_by_policy_violation_type[:dismissed_in_mr].vulnerability_id
        vulnerability_without_dismissal = reads_by_policy_violation_type[:no_violations].vulnerability_id

        expect(result[vulnerability_dismissed_in_mr]).to eq(Security::PolicyViolations::DISMISSED_IN_MR)
        expect(result[vulnerability_without_dismissal]).to eq(Security::PolicyViolations::NOT_APPLICABLE)
      end
    end

    context 'with edge cases' do
      context 'when records are empty' do
        let(:records) { [] }

        it 'returns empty hash' do
          expect(preloader.preload).to eq({})
        end
      end

      context 'when database query fails' do
        let(:records) { [reads_by_policy_violation_type[:dismissed_in_mr]] }

        before do
          allow(::Security::PolicyDismissal).to receive(:for_projects).and_raise(StandardError, 'Database error')
          allow(::Gitlab::ErrorTracking).to receive(:track_exception)
        end

        it 'handles errors gracefully and tracks exceptions' do
          result = preloader.preload

          expect(result).to eq({})
          expect(::Gitlab::ErrorTracking).to have_received(:track_exception)
            .with(instance_of(StandardError), class: described_class.name)
        end
      end
    end

    describe 'performance characteristics' do
      let_it_be(:large_vulnerability_set) do
        create_list(:vulnerability, 5, :with_read, project: project).map(&:vulnerability_read)
      end

      let_it_be(:extra_vulnerability_set) do
        create_list(:vulnerability, 2, :with_read, project: project).map(&:vulnerability_read)
      end

      it 'performs efficient batch querying' do
        preloader = described_class.new(large_vulnerability_set)

        expect { preloader.preload }.not_to exceed_query_limit(3)
      end

      it 'avoids N+1 queries with larger datasets' do
        # Setup some vulnerabilities with policy dismissals
        large_vulnerability_set.first(3).each do |vulnerability_read|
          create(:policy_dismissal, :preserved, project: project, security_findings_uuids: [vulnerability_read.uuid])
        end

        preloader = described_class.new(large_vulnerability_set)
        control_count = count_queries { preloader.preload }

        # Adding more records should not significantly increase query count
        larger_set = large_vulnerability_set + extra_vulnerability_set
        larger_preloader = described_class.new(larger_set)

        expect { larger_preloader.preload }.not_to exceed_query_limit(control_count + 1)
      end
    end
  end

  private

  def count_queries(&block)
    ActiveRecord::QueryRecorder.new(&block).count
  end
end
