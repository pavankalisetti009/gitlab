# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::AdvancedFinders::Security::Vulnerability::CountOverTimeFinder, :elastic_delete_by_query, :sidekiq_inline, feature_category: :vulnerability_management do
  let_it_be_with_reload(:group) { create(:group) }
  let_it_be_with_reload(:project) { create(:project, namespace: group) }

  let_it_be(:current_day) { Time.current.beginning_of_day }
  let_it_be(:current_day_minus_1) { current_day - 1.day }
  let_it_be(:current_day_minus_2) { current_day - 2.days }
  let_it_be(:current_day_plus_1) { current_day + 1.day }

  let_it_be(:vulnerabilities) do
    dates = [current_day_minus_2, current_day_minus_1, current_day, current_day_plus_1]
    severity_report_pairs = [
      { severity: :low, report_type: :sast },
      { severity: :medium, report_type: :dast },
      { severity: :high, report_type: :dependency_scanning }
    ]

    dates.flat_map do |date|
      severity_report_pairs.map do |config|
        create(
          :vulnerability,
          :with_finding,
          severity: config[:severity],
          report_type: config[:report_type],
          project: project,
          created_at: date
        )
      end
    end
  end

  let(:params) do
    { created_after: current_day_minus_2.to_date, created_before: current_day.to_date, group_by: group_by }
  end

  let(:vulnerable) { group }

  subject(:execute) { described_class.new(vulnerable, params).execute }

  before do
    stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)
  end

  describe '#execute' do
    before do
      Elastic::ProcessBookkeepingService.track!(*vulnerabilities)
      ensure_elasticsearch_index!
    end

    context "when grouping by severity" do
      let(:group_by) { 'severity' }

      it "fetches count by each severity" do
        is_expected.to eq([
          {
            "date" => current_day_minus_2.to_date.iso8601,
            :by_severity => [
              { "count" => 0, "severity" => "INFO" },
              { "count" => 0, "severity" => "UNKNOWN" },
              { "count" => 1, "severity" => "LOW" },
              { "count" => 1, "severity" => "MEDIUM" },
              { "count" => 1, "severity" => "HIGH" },
              { "count" => 0, "severity" => "CRITICAL" }
            ]
          },
          {
            "date" => current_day_minus_1.to_date.iso8601,
            :by_severity => [
              { "count" => 0, "severity" => "INFO" },
              { "count" => 0, "severity" => "UNKNOWN" },
              { "count" => 2, "severity" => "LOW" },
              { "count" => 2, "severity" => "MEDIUM" },
              { "count" => 2, "severity" => "HIGH" },
              { "count" => 0, "severity" => "CRITICAL" }
            ]
          },
          {
            "date" => current_day.to_date.iso8601,
            :by_severity => [
              { "count" => 0, "severity" => "INFO" },
              { "count" => 0, "severity" => "UNKNOWN" },
              { "count" => 3, "severity" => "LOW" },
              { "count" => 3, "severity" => "MEDIUM" },
              { "count" => 3, "severity" => "HIGH" },
              { "count" => 0, "severity" => "CRITICAL" }
            ]
          }
        ])
      end

      it_behaves_like 'a vulnerability elastic finder'
    end

    context "when grouping by report type" do
      let(:group_by) { 'report_type' }

      it "fetches count by each severity" do
        is_expected.to eq([
          {
            "date" => current_day_minus_2.to_date.iso8601,
            :by_report_type => [
              { "count" => 1, "report_type" => "SAST" },
              { "count" => 1, "report_type" => "DEPENDENCY_SCANNING" },
              { "count" => 0, "report_type" => "CONTAINER_SCANNING" },
              { "count" => 1, "report_type" => "DAST" },
              { "count" => 0, "report_type" => "SECRET_DETECTION" },
              { "count" => 0, "report_type" => "COVERAGE_FUZZING" },
              { "count" => 0, "report_type" => "API_FUZZING" },
              { "count" => 0, "report_type" => "CLUSTER_IMAGE_SCANNING" },
              { "count" => 0, "report_type" => "CONTAINER_SCANNING_FOR_REGISTRY" },
              { "count" => 0, "report_type" => "GENERIC" }
            ]
          },
          {
            "date" => current_day_minus_1.to_date.iso8601,
            :by_report_type => [
              { "count" => 2, "report_type" => "SAST" },
              { "count" => 2, "report_type" => "DEPENDENCY_SCANNING" },
              { "count" => 0, "report_type" => "CONTAINER_SCANNING" },
              { "count" => 2, "report_type" => "DAST" },
              { "count" => 0, "report_type" => "SECRET_DETECTION" },
              { "count" => 0, "report_type" => "COVERAGE_FUZZING" },
              { "count" => 0, "report_type" => "API_FUZZING" },
              { "count" => 0, "report_type" => "CLUSTER_IMAGE_SCANNING" },
              { "count" => 0, "report_type" => "CONTAINER_SCANNING_FOR_REGISTRY" },
              { "count" => 0, "report_type" => "GENERIC" }
            ]
          },
          {
            "date" => current_day.to_date.iso8601,
            :by_report_type => [
              { "count" => 3, "report_type" => "SAST" },
              { "count" => 3, "report_type" => "DEPENDENCY_SCANNING" },
              { "count" => 0, "report_type" => "CONTAINER_SCANNING" },
              { "count" => 3, "report_type" => "DAST" },
              { "count" => 0, "report_type" => "SECRET_DETECTION" },
              { "count" => 0, "report_type" => "COVERAGE_FUZZING" },
              { "count" => 0, "report_type" => "API_FUZZING" },
              { "count" => 0, "report_type" => "CLUSTER_IMAGE_SCANNING" },
              { "count" => 0, "report_type" => "CONTAINER_SCANNING_FOR_REGISTRY" },
              { "count" => 0, "report_type" => "GENERIC" }
            ]
          }
        ])
      end

      it_behaves_like 'a vulnerability elastic finder'
    end

    context "when filtering by selected severities" do
      let(:params) do
        {
          created_after: current_day_minus_2.to_date,
          created_before: current_day.to_date,
          group_by: 'severity',
          severity: %w[high medium]
        }
      end

      it "returns only the filtered severities in the response", :aggregate_failures do
        execute.each do |date_data|
          expect(date_data[:by_severity].size).to eq(2)
          severities = date_data[:by_severity].pluck("severity")
          expect(severities).to contain_exactly("HIGH", "MEDIUM")
        end
      end
    end

    context "when filtering by selected report types" do
      let(:params) do
        {
          created_after: current_day_minus_2.to_date,
          created_before: current_day.to_date,
          group_by: 'report_type',
          report_type: %w[sast dast]
        }
      end

      it "returns only the filtered report types in the response" do
        execute.each do |date_data|
          expect(date_data[:by_report_type].size).to eq(2)
          report_types = date_data[:by_report_type].pluck("report_type")
          expect(report_types).to contain_exactly("SAST", "DAST")
        end
      end
    end

    context "for resolved vulnerability" do
      let_it_be(:resolved_vulnerability) do
        create(
          :vulnerability,
          :with_finding,
          severity: :low,
          report_type: :sast,
          project: project,
          created_at: current_day_minus_2,
          state: :resolved,
          resolved_at: current_day_minus_1
        )
      end

      let_it_be(:vulnerabilities) { resolved_vulnerability }

      let(:params) do
        {
          created_after: current_day_minus_2.to_date,
          created_before: current_day.to_date,
          group_by: 'severity',
          severity: %w[low]
        }
      end

      it 'does not increment count after the resolved_at day' do
        is_expected.to eq([
          {
            "date" => current_day_minus_2.to_date.iso8601,
            :by_severity => [{ "count" => 1, "severity" => "LOW" }]
          },
          {
            "date" => current_day_minus_1.to_date.iso8601,
            :by_severity => [{ "count" => 0, "severity" => "LOW" }]
          },
          {
            "date" => current_day.to_date.iso8601,
            :by_severity => [{ "count" => 0, "severity" => "LOW" }]
          }
        ])
      end
    end

    context "for dismissed vulnerability" do
      let_it_be(:dismissed_vulnerability) do
        create(
          :vulnerability,
          :with_finding,
          severity: :medium,
          report_type: :dast,
          project: project,
          created_at: current_day_minus_2,
          state: :dismissed,
          dismissed_at: current_day_minus_1
        )
      end

      let_it_be(:vulnerabilities) { dismissed_vulnerability }

      let(:params) do
        {
          created_after: current_day_minus_2.to_date,
          created_before: current_day.to_date,
          group_by: 'severity',
          severity: %w[medium]
        }
      end

      it 'does not increment count after the dismissed_at day' do
        is_expected.to eq([
          {
            "date" => current_day_minus_2.to_date.iso8601,
            :by_severity => [{ "count" => 1, "severity" => "MEDIUM" }]
          },
          {
            "date" => current_day_minus_1.to_date.iso8601,
            :by_severity => [{ "count" => 0, "severity" => "MEDIUM" }]
          },
          {
            "date" => current_day.to_date.iso8601,
            :by_severity => [{ "count" => 0, "severity" => "MEDIUM" }]
          }
        ])
      end
    end

    context "when there are open vulnerabilities before the created_after date" do
      let(:params) do
        { created_after: current_day_minus_1.to_date, created_before: current_day.to_date, group_by: group_by }
      end

      let(:group_by) { 'severity' }

      it 'counts the open vulnerabilities before the created_after date' do
        is_expected.to eq([
          {
            "date" => current_day_minus_1.to_date.iso8601,
            :by_severity => [
              { "count" => 0, "severity" => "INFO" },
              { "count" => 0, "severity" => "UNKNOWN" },
              { "count" => 2, "severity" => "LOW" },
              { "count" => 2, "severity" => "MEDIUM" },
              { "count" => 2, "severity" => "HIGH" },
              { "count" => 0, "severity" => "CRITICAL" }
            ]
          },
          {
            "date" => current_day.to_date.iso8601,
            :by_severity => [
              { "count" => 0, "severity" => "INFO" },
              { "count" => 0, "severity" => "UNKNOWN" },
              { "count" => 3, "severity" => "LOW" },
              { "count" => 3, "severity" => "MEDIUM" },
              { "count" => 3, "severity" => "HIGH" },
              { "count" => 0, "severity" => "CRITICAL" }
            ]
          }
        ])
      end
    end

    context 'for overidden arguments' do
      let(:params) do
        { created_after: current_day_minus_1.to_date, created_before: current_day.to_date, group_by: group_by }
      end

      let(:group_by) { 'severity' }

      it 'calls query builder with the overriden arguments' do
        expected_options = {
          vulnerabilities_over_time: true,
          created_after: current_day.to_date - 1.year,
          bucket_start_date: current_day_minus_1.to_date,
          bucket_end_date: current_day.to_date,
          group_by: 'severity'
        }

        expect(::Search::Elastic::VulnerabilityQueryBuilder).to receive(:build)
          .with(hash_including(options: hash_including(expected_options)))
          .and_call_original

        execute
      end
    end
  end
end
