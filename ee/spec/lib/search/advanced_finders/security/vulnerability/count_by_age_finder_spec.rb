# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::AdvancedFinders::Security::Vulnerability::CountByAgeFinder, :elastic_delete_by_query, :sidekiq_inline, feature_category: :vulnerability_management do
  let_it_be_with_reload(:group) { create(:group) }
  let_it_be_with_reload(:project) { create(:project, namespace: group) }

  let_it_be(:current_day) { Time.current.beginning_of_day }
  let(:params) { { group_by: group_by } }
  let(:vulnerable) { group }

  subject(:execute) { described_class.new(vulnerable, params).execute }

  before do
    stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)
  end

  describe '#execute' do
    context "when grouping by severity" do
      let(:group_by) { 'severity' }

      let_it_be(:vulnerabilities) do
        [
          create(:vulnerability, :with_finding, severity: :low, report_type: :sast,
            project: project, detected_at: current_day - 5.days),
          create(:vulnerability, :with_finding, severity: :medium, report_type: :dast,
            project: project, detected_at: current_day - 20.days),
          create(:vulnerability, :with_finding, severity: :high, report_type: :dependency_scanning,
            project: project, detected_at: current_day - 200.days)
        ]
      end

      before do
        Elastic::ProcessBookkeepingService.track!(*vulnerabilities)
        ensure_elasticsearch_index!
      end

      it "fetches count by age band and severity", :aggregate_failures do
        result = execute

        # Find the specific age bands with vulnerabilities
        less_than_7 = result.find { |r| r["name"] == "< 7 days" }
        days_15_to_30 = result.find { |r| r["name"] == "15 - 30 days" }
        greater_than_180 = result.find { |r| r["name"] == "> 180 days" }

        # Each vulnerability shows up in its corresponding age band
        expect(less_than_7[:by_severity]).to match_array([
          { "count" => 0, "severity" => "INFO" },
          { "count" => 0, "severity" => "UNKNOWN" },
          { "count" => 1, "severity" => "LOW" },
          { "count" => 0, "severity" => "MEDIUM" },
          { "count" => 0, "severity" => "HIGH" },
          { "count" => 0, "severity" => "CRITICAL" }
        ])

        expect(days_15_to_30[:by_severity]).to match_array([
          { "count" => 0, "severity" => "INFO" },
          { "count" => 0, "severity" => "UNKNOWN" },
          { "count" => 0, "severity" => "LOW" },
          { "count" => 1, "severity" => "MEDIUM" },
          { "count" => 0, "severity" => "HIGH" },
          { "count" => 0, "severity" => "CRITICAL" }
        ])

        expect(greater_than_180[:by_severity]).to match_array([
          { "count" => 0, "severity" => "INFO" },
          { "count" => 0, "severity" => "UNKNOWN" },
          { "count" => 0, "severity" => "LOW" },
          { "count" => 0, "severity" => "MEDIUM" },
          { "count" => 1, "severity" => "HIGH" },
          { "count" => 0, "severity" => "CRITICAL" }
        ])
      end

      it "returns all age bands", :aggregate_failures do
        result = execute
        age_band_names = result.pluck("name")

        expect(age_band_names).to match_array([
          "< 7 days",
          "7 - 14 days",
          "15 - 30 days",
          "31 - 60 days",
          "61 - 90 days",
          "91 - 180 days",
          "> 180 days"
        ])
      end

      it_behaves_like 'a vulnerability elastic finder'
    end

    context "when grouping by report type" do
      let(:group_by) { 'report_type' }

      let_it_be(:vulnerabilities) do
        [
          create(:vulnerability, :with_finding, severity: :low, report_type: :sast,
            project: project, detected_at: current_day - 5.days),
          create(:vulnerability, :with_finding, severity: :medium, report_type: :dast,
            project: project, detected_at: current_day - 20.days),
          create(:vulnerability, :with_finding, severity: :high, report_type: :dependency_scanning,
            project: project, detected_at: current_day - 200.days)
        ]
      end

      before do
        Elastic::ProcessBookkeepingService.track!(*vulnerabilities)
        ensure_elasticsearch_index!
      end

      it "fetches count by age band and report type", :aggregate_failures do
        result = execute

        less_than_7 = result.find { |r| r["name"] == "< 7 days" }
        days_15_to_30 = result.find { |r| r["name"] == "15 - 30 days" }
        greater_than_180 = result.find { |r| r["name"] == "> 180 days" }

        # Check specific report types in their age bands
        expect(less_than_7[:by_report_type].find { |rt| rt["report_type"] == "SAST" }).to eq(
          { "count" => 1, "report_type" => "SAST" }
        )

        expect(days_15_to_30[:by_report_type].find { |rt| rt["report_type"] == "DAST" }).to eq(
          { "count" => 1, "report_type" => "DAST" }
        )

        expect(greater_than_180[:by_report_type].find { |rt| rt["report_type"] == "DEPENDENCY_SCANNING" }).to eq(
          { "count" => 1, "report_type" => "DEPENDENCY_SCANNING" }
        )
      end

      it_behaves_like 'a vulnerability elastic finder'
    end

    context "when filtering by selected severities" do
      let_it_be(:vulnerabilities) do
        [
          create(:vulnerability, :with_finding, severity: :low, report_type: :sast,
            project: project, detected_at: current_day - 5.days),
          create(:vulnerability, :with_finding, severity: :medium, report_type: :dast,
            project: project, detected_at: current_day - 5.days),
          create(:vulnerability, :with_finding, severity: :high, report_type: :dependency_scanning,
            project: project, detected_at: current_day - 5.days)
        ]
      end

      let(:params) do
        {
          group_by: 'severity',
          severity: %w[high medium]
        }
      end

      before do
        Elastic::ProcessBookkeepingService.track!(*vulnerabilities)
        ensure_elasticsearch_index!
      end

      it "returns only the filtered severities in the response", :aggregate_failures do
        execute.each do |age_band_data|
          expect(age_band_data[:by_severity].size).to eq(2)
          severities = age_band_data[:by_severity].pluck("severity")
          expect(severities).to contain_exactly("HIGH", "MEDIUM")
        end
      end
    end

    context "when filtering by selected report types" do
      let_it_be(:vulnerabilities) do
        [
          create(:vulnerability, :with_finding, severity: :low, report_type: :sast,
            project: project, detected_at: current_day - 5.days),
          create(:vulnerability, :with_finding, severity: :medium, report_type: :dast,
            project: project, detected_at: current_day - 5.days),
          create(:vulnerability, :with_finding, severity: :high, report_type: :dependency_scanning,
            project: project, detected_at: current_day - 5.days)
        ]
      end

      let(:params) do
        {
          group_by: 'report_type',
          report_type: %w[sast dast]
        }
      end

      before do
        Elastic::ProcessBookkeepingService.track!(*vulnerabilities)
        ensure_elasticsearch_index!
      end

      it "returns only the filtered report types in the response", :aggregate_failures do
        execute.each do |age_band_data|
          expect(age_band_data[:by_report_type].size).to eq(2)
          report_types = age_band_data[:by_report_type].pluck("report_type")
          expect(report_types).to contain_exactly("SAST", "DAST")
        end
      end
    end

    context "for resolved vulnerability" do
      let_it_be(:resolved_vulnerability) do
        create(
          :vulnerability,
          :with_finding,
          severity: :low,
          report_type: :sast,
          project: project,
          detected_at: current_day - 10.days,
          state: :resolved,
          resolved_at: current_day - 3.days
        )
      end

      let_it_be(:open_vulnerability) do
        create(
          :vulnerability,
          :with_finding,
          severity: :medium,
          report_type: :dast,
          project: project,
          detected_at: current_day - 10.days
        )
      end

      let(:params) do
        {
          group_by: 'severity',
          state: %w[detected confirmed]
        }
      end

      before do
        Elastic::ProcessBookkeepingService.track!(resolved_vulnerability, open_vulnerability)
        ensure_elasticsearch_index!
      end

      it 'does not count resolved vulnerabilities when filtering by open states', :aggregate_failures do
        result = execute
        days_7_to_14 = result.find { |r| r["name"] == "7 - 14 days" }

        # Only the open MEDIUM vulnerability should be counted
        expect(days_7_to_14[:by_severity].find { |s| s["severity"] == "LOW" }["count"]).to eq(0)
        expect(days_7_to_14[:by_severity].find { |s| s["severity"] == "MEDIUM" }["count"]).to eq(1)
      end
    end

    context "for dismissed vulnerability" do
      let_it_be(:dismissed_vulnerability) do
        create(
          :vulnerability,
          :with_finding,
          severity: :medium,
          report_type: :dast,
          project: project,
          detected_at: current_day - 10.days,
          state: :dismissed,
          dismissed_at: current_day - 3.days
        )
      end

      let_it_be(:open_vulnerability) do
        create(
          :vulnerability,
          :with_finding,
          severity: :high,
          report_type: :sast,
          project: project,
          detected_at: current_day - 10.days
        )
      end

      let(:params) do
        {
          group_by: 'severity',
          state: %w[detected confirmed]
        }
      end

      before do
        Elastic::ProcessBookkeepingService.track!(dismissed_vulnerability, open_vulnerability)
        ensure_elasticsearch_index!
      end

      it 'does not count dismissed vulnerabilities when filtering by open states', :aggregate_failures do
        result = execute
        days_7_to_14 = result.find { |r| r["name"] == "7 - 14 days" }

        # Only the open HIGH vulnerability should be counted
        expect(days_7_to_14[:by_severity].find { |s| s["severity"] == "MEDIUM" }["count"]).to eq(0)
        expect(days_7_to_14[:by_severity].find { |s| s["severity"] == "HIGH" }["count"]).to eq(1)
      end
    end

    context 'for passed arguments' do
      let(:params) { { group_by: 'severity' } }
      let(:group_by) { 'severity' }

      it 'calls query builder with count_by_age option', :aggregate_failures do
        expected_options = {
          count_by_age: true,
          group_by: 'severity'
        }

        expect(::Search::Elastic::VulnerabilityQueryBuilder).to receive(:build) do |args|
          expect(args[:options]).to include(expected_options)
          expect(args[:query]).to be_nil
        end.and_call_original

        execute
      end
    end

    context "when vulnerabilities span multiple age bands" do
      let_it_be(:vulnerabilities_across_bands) do
        [
          create(:vulnerability, :with_finding, severity: :critical, report_type: :sast,
            project: project, detected_at: current_day - 3.days),
          create(:vulnerability, :with_finding, severity: :high, report_type: :dast,
            project: project, detected_at: current_day - 12.days),
          create(:vulnerability, :with_finding, severity: :medium, report_type: :dependency_scanning,
            project: project, detected_at: current_day - 45.days),
          create(:vulnerability, :with_finding, severity: :low, report_type: :sast,
            project: project, detected_at: current_day - 100.days),
          create(:vulnerability, :with_finding, severity: :critical, report_type: :dast,
            project: project, detected_at: current_day - 250.days)
        ]
      end

      let(:group_by) { 'severity' }

      before do
        Elastic::ProcessBookkeepingService.track!(*vulnerabilities_across_bands)
        ensure_elasticsearch_index!
      end

      it 'groups vulnerabilities into correct age bands with non-zero counts', :aggregate_failures do
        result = execute

        # Find age bands with actual vulnerabilities
        less_than_7 = result.find { |r| r["name"] == "< 7 days" }
        days_7_to_14 = result.find { |r| r["name"] == "7 - 14 days" }
        days_31_to_60 = result.find { |r| r["name"] == "31 - 60 days" }
        days_91_to_180 = result.find { |r| r["name"] == "91 - 180 days" }
        greater_than_180 = result.find { |r| r["name"] == "> 180 days" }

        # Verify non-zero counts in appropriate bands (created 3 days ago)
        expect(less_than_7[:by_severity].find { |s| s["severity"] == "CRITICAL" }["count"]).to eq(1)

        # Created 12 days ago - should be in DAYS_7_TO_14
        expect(days_7_to_14[:by_severity].find { |s| s["severity"] == "HIGH" }["count"]).to eq(1)

        # Created 45 days ago - should be in DAYS_31_TO_60
        expect(days_31_to_60[:by_severity].find { |s| s["severity"] == "MEDIUM" }["count"]).to eq(1)

        # Created 100 days ago - should be in DAYS_91_TO_180
        expect(days_91_to_180[:by_severity].find { |s| s["severity"] == "LOW" }["count"]).to eq(1)

        # Created 250 days ago - should be in GREATER_THAN_180_DAYS
        expect(greater_than_180[:by_severity].find { |s| s["severity"] == "CRITICAL" }["count"]).to eq(1)
      end
    end

    context "when no vulnerabilities exist" do
      let(:group_by) { 'severity' }

      before do
        # Don't track any vulnerabilities
        ensure_elasticsearch_index!
      end

      it 'returns all age bands with zero counts', :aggregate_failures do
        result = execute

        expect(result.size).to eq(7)

        result.each do |age_band_data|
          total_count = age_band_data[:by_severity].sum { |s| s["count"] }
          expect(total_count).to eq(0)
        end
      end
    end
  end

  describe '#parse_aggregation' do
    let(:group_by) { 'severity' }
    let(:finder) { described_class.new(vulnerable, params) }

    context 'when response is empty', :aggregate_failures do
      it 'returns empty hash' do
        expect(finder.send(:parse_aggregation, nil)).to eq({})
        expect(finder.send(:parse_aggregation, {})).to eq({})
      end
    end

    context 'when buckets is empty hash' do
      let(:response) { { 'age_counts' => { 'buckets' => {} } } }

      it 'handles nil buckets gracefully' do
        expect(finder.send(:parse_aggregation, response)).to eq({})
      end
    end

    context 'when response has age_counts but buckets is nil' do
      let(:response) { { 'age_counts' => { 'buckets' => nil } } }

      it 'handles nil buckets gracefully' do
        result = finder.send(:parse_aggregation, response)
        expect(result).to be_nil
      end
    end
  end

  describe '#extract_bucket_data' do
    let(:group_by) { 'report_type' }
    let(:finder) { described_class.new(vulnerable, params) }

    context 'when bucket has by_report_type data' do
      let(:bucket) do
        {
          'by_report_type' => {
            'buckets' => [
              { 'key' => 'sast', 'doc_count' => 5 },
              { 'key' => 'dast', 'doc_count' => 3 }
            ]
          }
        }
      end

      it 'returns by_report_type data' do
        result = finder.send(:extract_bucket_data, bucket)
        expect(result['by_report_type']).to eq(bucket['by_report_type']['buckets'])
      end
    end

    context 'when bucket has neither by_severity nor by_report_type' do
      let(:bucket) { {} }

      it 'returns nil' do
        expect(finder.send(:extract_bucket_data, bucket)).to be_nil
      end
    end
  end

  describe '#count_by_age' do
    let(:group_by) { 'severity' }
    let(:finder) { described_class.new(vulnerable, params) }

    context 'when parsed_aggregation is empty', :aggregate_failures do
      it 'returns empty array' do
        expect(finder.send(:count_by_age, {}, {})).to eq([])
        expect(finder.send(:count_by_age, nil, {})).to eq([])
      end
    end

    context 'when age range has no metrics' do
      let(:parsed_aggregation) do
        {
          '< 7 days' => nil,
          '7 - 14 days' => { 'by_severity' => { 'buckets' => [] } }
        }
      end

      it 'skips nil metrics and processes valid ones' do
        allow(finder).to receive(:build_age_range_metrics).and_return({ age_range: '7 - 14 days' })
        result = finder.send(:count_by_age, parsed_aggregation, {})
        expect(result.length).to eq(1)
      end
    end
  end

  describe '#build_severity_data' do
    let(:group_by) { 'severity' }
    let(:finder) { described_class.new(vulnerable, params) }

    context 'when filtered_severities is empty' do
      let(:buckets) do
        [
          { 'key' => 1, 'doc_count' => 10 },
          { 'key' => 2, 'doc_count' => 5 }
        ]
      end

      it 'uses all severities' do
        result = finder.send(:build_severity_data, buckets, [])
        expect(result.length).to eq(::Vulnerability.severities.length)
      end
    end
  end

  describe '#build_metric_data' do
    let(:group_by) { 'severity' }
    let(:finder) { described_class.new(vulnerable, params) }
    let(:buckets) { [{ 'key' => 'test', 'doc_count' => 1 }] }

    context 'with unknown metric_name' do
      it 'returns nil for unhandled metric types' do
        result = finder.send(:build_metric_data, 'unknown_metric', buckets, {})
        expect(result).to be_nil
      end
    end

    context 'with empty metric_name' do
      it 'returns nil for empty metric name' do
        result = finder.send(:build_metric_data, '', buckets, {})
        expect(result).to be_nil
      end
    end

    context 'with nil metric_name' do
      it 'returns nil for nil metric name' do
        result = finder.send(:build_metric_data, nil, buckets, {})
        expect(result).to be_nil
      end
    end
  end
end
