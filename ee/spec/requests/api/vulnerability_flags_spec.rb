# frozen_string_literal: true

require 'spec_helper'

RSpec.describe API::VulnerabilityFlags, feature_category: :vulnerability_management do
  include AccessMatchersForRequest

  let_it_be(:project) { create(:project) }
  let_it_be(:user) { create(:user) }
  let_it_be(:vulnerability) { create(:vulnerability, :with_finding, project: project) }
  let_it_be(:finding) { vulnerability.findings.first }

  let(:vulnerability_id) { vulnerability.id }
  let(:api_path) { "/vulnerabilities/#{vulnerability_id}/flags/ai_detection" }

  let(:valid_params) do
    {
      confidence_score: 85,
      description: 'AI detected this as a false positive with high confidence'
    }
  end

  before do
    stub_licensed_features(security_dashboard: true)
  end

  describe 'POST /vulnerabilities/:vulnerability_id/flags/ai_detection' do
    subject(:post_ai_detection) { post api(api_path, user), params: valid_params }

    context 'with an authorized user with proper permissions' do
      before_all do
        project.add_maintainer(user)
      end

      it 'creates a vulnerability flag successfully' do
        expect { post_ai_detection }.to change { Vulnerabilities::Flag.count }.by(1)

        expect(response).to have_gitlab_http_status(:created)
        expect(json_response['message']).to eq('AI detection results updated successfully')

        flag = Vulnerabilities::Flag.last
        expect(flag.finding).to eq(finding)
        expect(flag.flag_type).to eq('false_positive')
        expect(flag.origin).to eq('ai_sast_fp_detection')
        expect(flag.description).to eq('AI detected this as a false positive with high confidence')
        expect(flag.confidence_score).to eq(0.85)
        expect(flag.status).to eq('not_started')
        expect(flag.project_id).to eq(project.id)
      end

      context 'when updating an existing flag' do
        let!(:existing_flag) do
          create(:vulnerabilities_flag, :false_positive,
            finding: finding,
            origin: 'ai_sast_fp_detection',
            description: 'Old description',
            confidence_score: 0.5
          )
        end

        it 'updates the existing flag without creating a new one' do
          expect { post_ai_detection }.not_to change { Vulnerabilities::Flag.count }

          expect(response).to have_gitlab_http_status(:ok)
          expect(json_response['message']).to eq('AI detection results updated successfully')

          existing_flag.reload
          expect(existing_flag.description).to eq('AI detected this as a false positive with high confidence')
          expect(existing_flag.confidence_score).to eq(0.85)
          expect(existing_flag.status).to eq('not_started')
        end
      end

      context 'with edge case confidence scores' do
        it 'accepts confidence_score of 0' do
          post api(api_path, user), params: valid_params.merge(confidence_score: 0)

          expect(response).to have_gitlab_http_status(:created)
          flag = Vulnerabilities::Flag.last
          expect(flag.confidence_score).to eq(0.0)
        end

        it 'accepts confidence_score of 100' do
          post api(api_path, user), params: valid_params.merge(confidence_score: 100)

          expect(response).to have_gitlab_http_status(:created)
          flag = Vulnerabilities::Flag.last
          expect(flag.confidence_score).to eq(1.0)
        end
      end

      context 'with invalid parameters' do
        it 'returns bad request for missing confidence_score' do
          post api(api_path, user), params: { description: 'Test description' }

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['error']).to include('confidence_score is missing')
        end

        it 'returns bad request for missing description' do
          post api(api_path, user), params: { confidence_score: 85 }

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['error']).to include('description is missing')
        end

        it 'returns bad request for confidence_score out of range' do
          post api(api_path, user), params: valid_params.merge(confidence_score: 101)

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['error']).to include('confidence_score does not have a valid value')
        end

        it 'returns bad request for negative confidence_score' do
          post api(api_path, user), params: valid_params.merge(confidence_score: -1)

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['error']).to include('confidence_score does not have a valid value')
        end

        it 'returns bad request for blank description' do
          post api(api_path, user), params: valid_params.merge(description: '')

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['error']).to include('description is empty')
        end
      end

      context 'when vulnerability does not exist' do
        let(:vulnerability_id) { 'non-existent' }

        it 'returns not found' do
          post_ai_detection

          expect(response).to have_gitlab_http_status(:not_found)
        end
      end

      context 'when vulnerability has no findings' do
        let(:vulnerability_without_findings) { create(:vulnerability, project: project) }
        let(:vulnerability_id) { vulnerability_without_findings.id }

        it 'returns bad request' do
          post_ai_detection

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['message']).to eq('No current finding available')
        end
      end

      context 'when service returns an error' do
        it 'returns the service error' do
          allow_next_instance_of(Vulnerabilities::Flags::UpdateAiDetectionService) do |service|
            allow(service).to receive(:execute).and_return(
              ServiceResponse.error(message: 'Something went wrong')
            )
          end

          post_ai_detection

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['message']).to eq('Something went wrong')
        end
      end

      it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features' do
        subject { post_ai_detection }
      end
    end

    context 'when authenticated with a token that has the ai_workflows scope' do
      let(:oauth_access_token) { create(:oauth_access_token, user: project.owner, scopes: [:ai_workflows]) }

      it 'allows access to endpoint' do
        post api(api_path, user, oauth_access_token: oauth_access_token), params: valid_params

        expect(response).to have_gitlab_http_status(:created)
      end
    end

    context 'when user is not authenticated' do
      let(:user) { nil }

      it 'returns unauthorized' do
        post_ai_detection

        expect(response).to have_gitlab_http_status(:unauthorized)
      end
    end

    describe 'permissions' do
      it { expect { post_ai_detection }.to be_allowed_for(:owner).of(project) }
      it { expect { post_ai_detection }.to be_allowed_for(:maintainer).of(project) }
      it { expect { post_ai_detection }.to be_allowed_for(:developer).of(project) }
      it { expect { post_ai_detection }.to be_denied_for(:reporter).of(project) }
      it { expect { post_ai_detection }.to be_denied_for(:guest).of(project) }
      it { expect { post_ai_detection }.to be_denied_for(:anonymous) }
    end
  end
end
