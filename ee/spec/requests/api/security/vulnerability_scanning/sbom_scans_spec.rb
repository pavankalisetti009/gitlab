# frozen_string_literal: true

require 'spec_helper'

RSpec.describe API::Security::VulnerabilityScanning::SbomScans, feature_category: :software_composition_analysis do
  let_it_be(:project) { create(:project) }
  let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:job) { create(:ci_build, :running, pipeline: pipeline, project: project) }

  let(:token) { job.token }
  let(:headers) { { API::Ci::Helpers::Runner::JOB_TOKEN_HEADER => token } }

  describe 'POST /jobs/:id/sbom_scans/authorize' do
    include_context 'workhorse headers'

    let(:filesize) { 1.megabyte }
    let(:params) { { filesize: filesize } }
    let(:api_path) { "/jobs/#{job.id}/sbom_scans/authorize" }

    subject(:authorize_upload) { post api(api_path), params: params, headers: headers.merge(workhorse_headers) }

    context 'when dependency_scanning licensed feature is available' do
      let_it_be(:expected_max_artifact_size) { Ci::JobArtifact.max_artifact_size(type: :cyclonedx, project: project) }

      before do
        stub_licensed_features(dependency_scanning: true)
      end

      context 'when job token is valid' do
        it 'returns success with workhorse headers' do
          authorize_upload

          expect(response).to have_gitlab_http_status(:ok)
          expect(response.content_type).to eq(Gitlab::Workhorse::INTERNAL_API_CONTENT_TYPE)
        end

        it_behaves_like 'rate limited endpoint', rate_limit_key: :dependency_scanning_sbom_scan_api_upload do
          let_it_be(:project2) { create(:project) }
          let_it_be(:job2) { create(:ci_build, :running, pipeline: pipeline, project: project2) }

          def request
            post api(api_path), params: params, headers: headers.merge(workhorse_headers)
          end

          def request_with_second_scope
            post api("/jobs/#{job2.id}/sbom_scans/authorize"),
              params: params,
              headers: { API::Ci::Helpers::Runner::JOB_TOKEN_HEADER => job2.token }.merge(workhorse_headers)
          end
        end

        context 'when using remote storage' do
          context 'when direct upload is enabled' do
            before do
              stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: true,
                direct_upload: true)
            end

            it 'responds with status 200, location of file remote store and object details', :aggregate_failures do
              authorize_upload

              expect(response).to have_gitlab_http_status(:ok)
              expect(response.media_type.to_s).to eq(Gitlab::Workhorse::INTERNAL_API_CONTENT_TYPE)
              expect(json_response).not_to have_key('TempPath')
              expect(json_response['RemoteObject']).to have_key('ID')
              expect(json_response['RemoteObject']).to have_key('GetURL')
              expect(json_response['RemoteObject']).to have_key('StoreURL')
              expect(json_response['RemoteObject']).to have_key('DeleteURL')
              expect(json_response['RemoteObject']).to have_key('MultipartUpload')
              expect(json_response['MaximumSize']).to eq(expected_max_artifact_size)
            end
          end

          context 'when direct upload is disabled' do
            before do
              stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: true,
                direct_upload: false)
            end

            it 'handles as a local file', :aggregate_failures do
              authorize_upload

              expect(response).to have_gitlab_http_status(:ok)
              expect(response.media_type.to_s).to eq(Gitlab::Workhorse::INTERNAL_API_CONTENT_TYPE)
              expect(json_response['RemoteObject']).to be_nil
              expect(json_response['MaximumSize']).to eq(expected_max_artifact_size)
              expect(json_response['TempPath'])
                .to eq(Security::VulnerabilityScanning::SbomScanUploader.workhorse_local_upload_path)
            end
          end
        end

        context 'when using local storage' do
          before do
            stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: false)
          end

          it 'handles as a local file', :aggregate_failures do
            authorize_upload

            expect(response).to have_gitlab_http_status(:ok)
            expect(response.media_type.to_s).to eq(Gitlab::Workhorse::INTERNAL_API_CONTENT_TYPE)
            expect(json_response['RemoteObject']).to be_nil
            expect(json_response['MaximumSize']).to eq(expected_max_artifact_size)
            expect(json_response['TempPath'])
              .to eq(Security::VulnerabilityScanning::SbomScanUploader.workhorse_local_upload_path)
          end
        end

        context 'when filesize is not provided' do
          let(:params) { {} }

          it 'calls the service with nil filesize' do
            expect_next_instance_of(Security::VulnerabilityScanning::CreateSbomScanService) do |service|
              expect(service).to receive(:authorize).with(filesize: nil).and_call_original
            end

            authorize_upload

            expect(response).to have_gitlab_http_status(:ok)
          end
        end
      end

      context 'when file is too large' do
        before do
          allow_next_instance_of(Security::VulnerabilityScanning::CreateSbomScanService) do |service|
            allow(service).to receive(:authorize).and_return(
              ServiceResponse.error(message: 'file size has reached maximum size limit', reason: :payload_too_large)
            )
          end
        end

        it 'returns error response', :aggregate_failures do
          authorize_upload

          expect(response).to have_gitlab_http_status(:payload_too_large)
          expect(json_response['message']).to eq('file size has reached maximum size limit')
        end
      end

      context 'when job token is invalid' do
        let(:token) { 'invalid_token' }

        it 'returns forbidden' do
          authorize_upload

          expect(response).to have_gitlab_http_status(:forbidden)
        end
      end

      context 'when job does not exist' do
        let(:api_path) { "/jobs/0/sbom_scans/authorize" }

        it 'returns forbidden' do
          authorize_upload

          expect(response).to have_gitlab_http_status(:forbidden)
        end
      end

      context 'when workhorse header is missing' do
        before do
          workhorse_headers.delete(Gitlab::Workhorse::INTERNAL_API_REQUEST_HEADER)
        end

        it 'returns forbidden' do
          authorize_upload

          expect(response).to have_gitlab_http_status(:forbidden)
        end
      end

      context 'when the `dependency_scanning_sbom_scan_api` feature flag is disabled' do
        before do
          stub_feature_flags(dependency_scanning_sbom_scan_api: false)
        end

        it 'returns forbidden', :aggregate_failures do
          authorize_upload

          expect(response).to have_gitlab_http_status(:forbidden)
          expect(json_response['message'])
            .to eq('403 Forbidden - Feature flag dependency_scanning_sbom_scan_api disabled for this project')
        end
      end
    end

    context 'when dependency_scanning licensed feature is not available' do
      before do
        stub_licensed_features(dependency_scanning: false)
      end

      it 'returns forbidden', :aggregate_failures do
        authorize_upload

        expect(response).to have_gitlab_http_status(:forbidden)
        expect(json_response['message']).to eq('403 Forbidden - License required for dependency scanning')
      end
    end
  end

  describe 'POST /jobs/:id/sbom_scans' do
    include WorkhorseHelpers
    include_context 'workhorse headers'

    let(:sbom_file) do
      fixture_file_upload('ee/spec/fixtures/security/vulnerability_scanning/sbom_scans/sbom.json', 'application/json')
    end

    let(:params) { { file: sbom_file } }
    let(:sbom_scan) { Security::VulnerabilityScanning::SbomScan.last }

    subject(:upload_sbom) do
      workhorse_finalize(
        api("/jobs/#{job.id}/sbom_scans"),
        method: :post,
        file_key: :file,
        params: params,
        headers: headers.merge(workhorse_headers),
        send_rewritten_field: true
      )
    end

    context 'when dependency_scanning licensed feature is available' do
      before do
        stub_licensed_features(dependency_scanning: true)
      end

      context 'when upload is successful' do
        shared_examples 'successful sbom upload' do |location|
          it 'creates a new sbom scan record and returns created status with sbom scan entity', :aggregate_failures do
            expect(response).to have_gitlab_http_status(:created)
            expect(json_response['id']).to eq(sbom_scan.id)
            expect(json_response['download_url']).to match(%r{/jobs/#{job.id}/sbom_scans/#{sbom_scan.id}})
            expect(json_response).not_to have_key('throttled')
            expect(json_response).not_to have_key('project_throttling_resets_in')
          end

          it 'stores the file locally', :aggregate_failures, if: location == :local do
            expect(sbom_scan.sbom_file_store).to be(ObjectStorage::Store::LOCAL)
            expect(sbom_scan.sbom_file).to be_file_storage
            expect(sbom_scan.sbom_file.object_store).to eq(ObjectStorage::Store::LOCAL)
          end

          it 'stores the file remotely', :aggregate_failures, if: location == :remote do
            expect(sbom_scan.sbom_file_store).to eq(ObjectStorage::Store::REMOTE)
            expect(sbom_scan.sbom_file).not_to be_file_storage
            expect(sbom_scan.sbom_file.object_store).to eq(ObjectStorage::Store::REMOTE)
          end
        end

        context 'when throttled' do
          before do
            stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: false)
            allow(Gitlab::ApplicationRateLimiter).to receive(:threshold)
              .with(:dependency_scanning_sbom_scan_api_throttling).and_return(1)

            # Call it once here to trigger throttling on the test request
            Gitlab::ApplicationRateLimiter.throttled?(:dependency_scanning_sbom_scan_api_throttling, scope: project)

            upload_sbom
          end

          it 'includes throttling information in the JSON response', :aggregate_failures do
            expect(response).to have_gitlab_http_status(:created)
            expect(json_response['throttled']).to be(true)
            expect(json_response['project_throttling_resets_in']).to be > 0
          end
        end

        context 'when using local storage' do
          before do
            stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: false)

            upload_sbom
          end

          it_behaves_like 'successful sbom upload', :local
        end

        context 'when using remote storage' do
          context 'when direct upload is enabled and file is stored in its final location' do
            # This test requires to create a file in a remote location before calling the upload method to
            # simulate that it has already been uploaded by workhorse.
            let!(:fog_connection) do
              stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: true,
                direct_upload: true)
            end

            let(:remote_object) do
              fog_connection.directories.new(key: 'uploads').files.create( # rubocop:disable Rails/SaveBang -- false negative
                key: remote_path,
                body: 'content'
              )
            end

            let(:remote_path) { '12345/foo-bar-123' }
            let(:sbom_file) { fog_to_uploaded_file(remote_object) }
            let(:params) { { file: sbom_file, 'file.remote_id' => remote_path } }

            before do
              allow(Security::VulnerabilityScanning::SbomScanUploader).to receive(:generate_final_store_path)
                .and_return(remote_path)
              # This PendingDirectUpload object is created when calling /authorize endpoint and use_final_store_path
              # is set to true. Its presence tells the uploader that the file is already stored in its final location
              # and the model's attribute `<mount_point>_final_path` should be set.
              ObjectStorage::PendingDirectUpload.prepare(
                Security::VulnerabilityScanning::SbomScanUploader.storage_location_identifier,
                remote_path
              )

              upload_sbom
            end

            it_behaves_like 'successful sbom upload', :remote

            it 'stores the file in its final path during upload' do
              expect(sbom_scan.sbom_file_final_path).to eq(remote_path)
            end
          end

          context 'when direct upload is disabled', :aggregate_failures do
            before do
              stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: true,
                direct_upload: false)
              upload_sbom
            end

            it_behaves_like 'successful sbom upload', :remote

            it 'does not store the file in its final path during upload' do
              expect(sbom_scan.sbom_file_final_path).to be_nil
            end
          end
        end
      end

      context 'when upload fails due to file size' do
        before do
          allow_next_instance_of(Security::VulnerabilityScanning::CreateSbomScanService) do |service|
            allow(service).to receive(:execute).and_return(
              ServiceResponse.error(message: 'file size has reached maximum size limit', reason: :payload_too_large)
            )
          end
        end

        it 'returns error response', :aggregate_failures do
          upload_sbom

          expect(response).to have_gitlab_http_status(:payload_too_large)
          expect(json_response['message']).to eq('file size has reached maximum size limit')
        end
      end

      context 'when upload fails due to validation errors' do
        before do
          allow_next_instance_of(Security::VulnerabilityScanning::CreateSbomScanService) do |service|
            allow(service).to receive(:execute).and_return(
              ServiceResponse.error(message: ['Project must exist'], reason: :unprocessable_entity)
            )
          end
        end

        it 'returns unprocessable entity', :aggregate_failures do
          upload_sbom

          expect(response).to have_gitlab_http_status(:unprocessable_entity)
          expect(json_response['message']).to eq(['Project must exist'])
        end
      end

      context 'when job token is invalid' do
        let(:token) { 'invalid_token' }

        it 'returns forbidden' do
          upload_sbom

          expect(response).to have_gitlab_http_status(:forbidden)
        end
      end

      context 'when file parameter is missing' do
        let(:params) { {} }

        it 'returns bad request', :aggregate_failures do
          upload_sbom

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response['error']).to eq('file is missing')
        end
      end

      context 'when the `dependency_scanning_sbom_scan_api` feature flag is disabled' do
        before do
          stub_feature_flags(dependency_scanning_sbom_scan_api: false)
        end

        it 'returns forbidden', :aggregate_failures do
          upload_sbom

          expect(response).to have_gitlab_http_status(:forbidden)
          expect(json_response['message'])
            .to eq('403 Forbidden - Feature flag dependency_scanning_sbom_scan_api disabled for this project')
        end
      end
    end

    context 'when dependency_scanning licensed feature is not available' do
      before do
        stub_licensed_features(dependency_scanning: false)
      end

      it 'returns forbidden', :aggregate_failures do
        upload_sbom

        expect(response).to have_gitlab_http_status(:forbidden)
        expect(json_response['message']).to eq('403 Forbidden - License required for dependency scanning')
      end

      it 'does not create a new sbom scan record' do
        expect { upload_sbom }.not_to change { Security::VulnerabilityScanning::SbomScan.count }
      end
    end
  end

  describe 'GET /jobs/:id/sbom_scans/:sbom_scan_id' do
    let(:sbom_scan) { create(:sbom_scan, build: job, project: project) }
    let(:params) { {} }

    before do
      stub_uploads_object_storage(Security::VulnerabilityScanning::SbomScanUploader, enabled: false)
    end

    subject(:download_results) do
      get api("/jobs/#{job.id}/sbom_scans/#{sbom_scan.id}"), params: params, headers: headers
    end

    context 'when dependency_scanning licensed feature is available' do
      before do
        stub_licensed_features(dependency_scanning: true)
      end

      it_behaves_like 'rate limited endpoint', rate_limit_key: :dependency_scanning_sbom_scan_api_download do
        let_it_be(:job2) { create(:ci_build, :running) }
        let_it_be(:sbom_scan2) { create(:sbom_scan, build: job2, project: job2.project) }

        def request
          get api("/jobs/#{job.id}/sbom_scans/#{sbom_scan.id}"), params: params, headers: headers
        end

        def request_with_second_scope
          get api("/jobs/#{job2.id}/sbom_scans/#{sbom_scan2.id}"), params: params, headers: headers
        end
      end

      context 'when sbom scan is in created state' do
        it 'returns accepted with queued message', :aggregate_failures do
          download_results

          expect(response).to have_gitlab_http_status(:accepted)
          expect(json_response['message']).to eq('SBOM Vulnerability Scan has been queued and will start shortly')
        end
      end

      context 'when sbom scan is in running state' do
        let(:sbom_scan) { create(:sbom_scan, :running, build: job, project: project) }

        it 'returns accepted with in progress message', :aggregate_failures do
          download_results

          expect(response).to have_gitlab_http_status(:accepted)
          expect(json_response['message']).to eq('SBOM Vulnerability Scan is still in progress')
        end
      end

      context 'when sbom scan is in failed state' do
        let(:sbom_scan) { create(:sbom_scan, :failed, build: job, project: project) }

        it 'returns gone with sbom scan error message', :aggregate_failures do
          download_results

          expect(response).to have_gitlab_http_status(:gone)
          expect(json_response['message'])
            .to eq("SBOM Vulnerability Scan failed and results are not available. #{sbom_scan.error_message}")
        end
      end

      context 'when sbom scan is finished' do
        let(:sbom_scan) { create(:sbom_scan, :finished, build: job, project: project) }

        it 'returns the result file', :aggregate_failures do
          download_results

          expect(response).to have_gitlab_http_status(:ok)
          expect(response.headers['X-Sendfile']).to eq(sbom_scan.result_file.path)
          expect(response.content_type).to eq('application/json')
        end
      end

      context 'when sbom scan has an unexpected status' do
        let(:sbom_scan) { create(:sbom_scan, build: job, project: project) }

        before do
          allow_next_found_instance_of(::Security::VulnerabilityScanning::SbomScan) do |s|
            allow(s).to receive(:status_name).and_return(:unknown_status)
          end
        end

        it 'returns internal server error with unexpected status message' do
          download_results

          expect(response).to have_gitlab_http_status(:internal_server_error)
          expect(json_response['message']).to eq("Unexpected SBOM scan status: unknown_status")
        end
      end

      context 'when sbom scan does not exist' do
        subject(:download_results) do
          get api("/jobs/#{job.id}/sbom_scans/0"), params: params, headers: headers
        end

        it 'returns not found' do
          download_results

          expect(response).to have_gitlab_http_status(:not_found)
        end
      end

      context 'when sbom scan does not belong to authenticated job' do
        let(:other_job) { create(:ci_build, :running, pipeline: pipeline, project: project) }
        let(:other_sbom_scan) { create(:sbom_scan, build: other_job, project: project) }

        subject(:download_results) do
          get api("/jobs/#{job.id}/sbom_scans/#{other_sbom_scan.id}"), params: params, headers: headers
        end

        it 'returns not found' do
          download_results

          expect(response).to have_gitlab_http_status(:not_found)
        end
      end

      context 'when job token is invalid' do
        let(:token) { 'invalid_token' }

        it 'returns forbidden' do
          download_results

          expect(response).to have_gitlab_http_status(:forbidden)
        end
      end

      context 'when the `dependency_scanning_sbom_scan_api` feature flag is disabled' do
        before do
          stub_feature_flags(dependency_scanning_sbom_scan_api: false)
        end

        it 'returns forbidden', :aggregate_failures do
          download_results

          expect(response).to have_gitlab_http_status(:forbidden)
          expect(json_response['message'])
            .to eq('403 Forbidden - Feature flag dependency_scanning_sbom_scan_api disabled for this project')
        end
      end
    end

    context 'when dependency_scanning licensed feature is not available' do
      before do
        stub_licensed_features(dependency_scanning: false)
      end

      it 'returns forbidden', :aggregate_failures do
        download_results

        expect(response).to have_gitlab_http_status(:forbidden)
        expect(json_response['message']).to eq('403 Forbidden - License required for dependency scanning')
      end
    end
  end
end
