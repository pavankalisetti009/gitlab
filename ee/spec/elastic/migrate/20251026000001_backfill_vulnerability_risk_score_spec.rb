# frozen_string_literal: true

require 'spec_helper'
require_relative File.join(__dir__, '../../..', 'ee/elastic/migrate/20251026000001_backfill_vulnerability_risk_score.rb')

RSpec.describe BackfillVulnerabilityRiskScore, :elastic, :sidekiq_inline, feature_category: :vulnerability_management do
  let(:version) { 20251026000001 }
  let(:migration) { described_class.new(version) }
  let(:helper) { Gitlab::Elastic::Helper.new }

  before do
    stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)
    allow(migration).to receive(:helper).and_return(helper)
  end

  describe 'migration_options' do
    it 'has migration options set' do
      expect(migration.batched?).to be_truthy
      expect(migration.throttle_delay).to eq(1.minute)
      expect(migration.retry_on_failure?).to be_truthy
    end

    it 'has correct document type' do
      expect(described_class::DOCUMENT_TYPE).to eq(::Vulnerability)
    end
  end

  describe '#item_to_preload' do
    it 'preloads finding risk score association' do
      expect(migration.item_to_preload).to eq([{ finding: :finding_risk_score }])
    end
  end

  describe 'skip conditions' do
    context 'on GitLab.com' do
      before do
        allow(Gitlab).to receive(:com?).and_return(true)
        allow(Gitlab).to receive(:dedicated?).and_return(false)
      end

      it 'does not skip migration' do
        expect(migration.skip_migration?).to be_falsey
      end
    end

    context 'on GitLab Dedicated' do
      before do
        allow(Gitlab).to receive(:com?).and_return(false)
        allow(Gitlab).to receive(:dedicated?).and_return(true)
      end

      it 'does not skip migration' do
        expect(migration.skip_migration?).to be_falsey
      end
    end

    context 'on self-managed instance' do
      before do
        allow(Gitlab).to receive(:com?).and_return(false)
        allow(Gitlab).to receive(:dedicated?).and_return(false)
      end

      it 'skips migration' do
        expect(migration.skip_migration?).to be_truthy
      end
    end
  end

  describe '#migrate', :clean_gitlab_redis_shared_state do
    let_it_be(:project) { create(:project) }
    let_it_be(:vulnerability_1) { create(:vulnerability, project: project) }
    let_it_be(:vulnerability_2) { create(:vulnerability, project: project) }
    let_it_be(:vulnerability_3) { create(:vulnerability, project: project) }
    
    before do
      # Create risk scores in database for some vulnerabilities
      create(:vulnerability_finding_risk_score, 
             finding: vulnerability_1.finding, 
             risk_score: 0.85)
      create(:vulnerability_finding_risk_score, 
             finding: vulnerability_2.finding, 
             risk_score: 0.42)
      # vulnerability_3 has no risk score (should get 0.0 default)

      # Index vulnerabilities
      [vulnerability_1, vulnerability_2, vulnerability_3].each do |vuln|
        vuln.__elasticsearch__.index_document
      end
      
      ensure_elasticsearch_index!
    end

    context 'when migration is allowed to run' do
      before do
        allow(Gitlab).to receive(:com?).and_return(true)
      end

      it 'updates vulnerability documents with risk_score from database' do
        migration.migrate

        # Refresh index to see updates
        vulnerability_1.__elasticsearch__.refresh_index!
        
        # Verify documents have been updated with correct risk scores
        doc_1 = vulnerability_1.__elasticsearch__.as_indexed_json
        expect(doc_1['risk_score']).to eq(0.85)

        doc_2 = vulnerability_2.__elasticsearch__.as_indexed_json  
        expect(doc_2['risk_score']).to eq(0.42)

        # Vulnerability without risk score should get default value
        doc_3 = vulnerability_3.__elasticsearch__.as_indexed_json
        expect(doc_3['risk_score']).to eq(0.0)
      end
    end

    context 'when migration is skipped' do
      before do
        allow(Gitlab).to receive(:com?).and_return(false)
        allow(Gitlab).to receive(:dedicated?).and_return(false)
      end

      it 'does not update documents' do
        expect(migration).to receive(:log).with(/Skipping migration/)
        migration.migrate

        # Verify documents were not updated
        doc_1 = vulnerability_1.__elasticsearch__.as_indexed_json
        expect(doc_1).not_to have_key('risk_score')
      end
    end
  end
end
