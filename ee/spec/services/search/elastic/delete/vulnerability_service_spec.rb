# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Search::Elastic::Delete::VulnerabilityService, feature_category: :vulnerability_management do
  include ElasticsearchHelpers

  let_it_be(:vulnerability_index) { Search::Elastic::Types::Vulnerability.index_name }
  let_it_be(:test_project_id) { 123 }
  let_it_be(:test_traversal_id) { 1 }

  before do
    stub_ee_application_setting(elasticsearch_search: true, elasticsearch_indexing: true)
  end

  def items_in_vulnerability_index
    items_in_index(vulnerability_index, 'vulnerability_id')
  end

  describe '.execute', :elastic do
    context 'with Elasticsearch integration' do
      let!(:old_group) { create(:group) }
      let!(:project) { create(:project, group: old_group) }
      let_it_be(:new_group) { create(:group) }

      before do
        # Not involved in the deletion process. Required to create ES docs for integration testing.
        allow(::Search::Elastic::VulnerabilityIndexingHelper).to receive(
          :vulnerability_indexing_allowed?).and_return(true)
      end

      context 'when project has vulnerabilities with different traversal_ids' do
        before do
          create_list(:vulnerability, 3, :with_read, project: project, group: old_group)
          ensure_elasticsearch_index!

          project.update_attribute(:namespace_id, new_group.id)
          create_list(:vulnerability, 2, :with_read, project: project, group: new_group)
          ensure_elasticsearch_index!
        end

        it 'deletes only vulnerabilities with old traversal_id' do
          expect(items_in_vulnerability_index.count).to eq(5)

          described_class.execute(project_id: project.id, traversal_id: new_group.id)
          es_helper.refresh_index(index_name: vulnerability_index)

          expect(items_in_vulnerability_index.count).to eq(2)
          expect(items_in_vulnerability_index).to match_array(
            Vulnerabilities::Read.where(project_id: project.id, traversal_ids: [new_group.id])
                                 .pluck(:vulnerability_id)
          )
        end
      end

      context 'when multiple projects documents exist' do
        let_it_be(:another_group) { create(:group) }
        let_it_be(:another_project) { create(:project, group: another_group) }

        before do
          # Create vulnerabilities for first project with old group
          create_list(:vulnerability, 3, :with_read, project: project, group: old_group)
          ensure_elasticsearch_index!

          # Update project to new group and create more vulnerabilities
          project.update_attribute(:namespace_id, new_group.id)
          create_list(:vulnerability, 2, :with_read, project: project, group: new_group)
          ensure_elasticsearch_index!

          # Create vulnerabilities for another project
          create_list(:vulnerability, 1, :with_read, project: another_project, group: another_group)
          ensure_elasticsearch_index!
        end

        it 'only deletes vulnerabilities from the specified project' do
          described_class.execute(project_id: project.id, traversal_id: new_group.id)
          es_helper.refresh_index(index_name: vulnerability_index)

          # Verify first project's documents with old traversal_id are deleted
          project_old_items = es_helper.client.search(
            index: vulnerability_index,
            body: {
              query: {
                bool: {
                  filter: [
                    { term: { project_id: project.id } },
                    { prefix: { traversal_ids: old_group.id } }
                  ]
                }
              }
            }
          )['hits']['total']['value']
          expect(project_old_items).to eq(0)

          # Verify first project's documents with new traversal_id remain
          project_new_items = es_helper.client.search(
            index: vulnerability_index,
            body: {
              query: {
                bool: {
                  filter: [
                    { term: { project_id: project.id } },
                    { prefix: { traversal_ids: new_group.id } }
                  ]
                }
              }
            }
          )['hits']['total']['value']
          expect(project_new_items).to eq(2)

          # Verify another project's documents are unaffected
          another_project_items = es_helper.client.search(
            index: vulnerability_index,
            body: {
              query: {
                bool: {
                  filter: [
                    { term: { project_id: another_project.id } },
                    { prefix: { traversal_ids: another_group.id } }
                  ]
                }
              }
            }
          )['hits']['total']['value']
          expect(another_project_items).to eq(1)
        end
      end
    end
  end

  describe '#initialize' do
    it 'sets project_id and traversal_id from options' do
      options = { project_id: test_project_id, traversal_id: test_traversal_id }
      service = described_class.new(options)

      expect(service.send(:project_id)).to eq(test_project_id)
      expect(service.send(:traversal_id)).to eq(test_traversal_id)
    end
  end

  describe '#execute' do
    let(:service) { described_class.new(options) }

    context 'when project_id and traversal_id are present' do
      let(:options) { { project_id: test_project_id, traversal_id: test_traversal_id } }

      it 'calls delete_vulnerability_documents' do
        expect(service).to receive(:delete_vulnerability_documents)
        service.execute
      end
    end

    context 'when project_id is missing' do
      let(:options) { { traversal_id: test_traversal_id } }

      it 'returns without calling delete_vulnerability_documents' do
        expect(service).not_to receive(:delete_vulnerability_documents)
        expect(service.execute).to be_nil
      end
    end

    context 'when traversal_id is missing' do
      let(:options) { { project_id: test_project_id } }

      it 'returns without calling delete_vulnerability_documents' do
        expect(service).not_to receive(:delete_vulnerability_documents)
        expect(service.execute).to be_nil
      end
    end
  end

  describe '#delete_vulnerability_documents' do
    let(:service) { described_class.new(options) }
    let(:options) { { project_id: test_project_id, traversal_id: test_traversal_id } }
    let(:mock_client) { instance_double(Gitlab::Search::Client) }
    let(:mock_logger) { instance_double(Gitlab::Elasticsearch::Logger) }
    let(:query) do
      {
        bool: {
          filter: [
            { term: { project_id: test_project_id } },
            { bool: { must_not: { prefix: { traversal_ids: { value: test_traversal_id } } } } }
          ]
        }
      }
    end

    before do
      allow(service).to receive_messages(client: mock_client, logger: mock_logger, build_query: query)
    end

    it 'executes the delete query and logs the response' do
      response = { 'deleted' => 5 }

      expect(mock_client).to receive(:delete_by_query).with(
        index: vulnerability_index,
        conflicts: 'proceed',
        timeout: '10m',
        body: { query: query }
      ).and_return(response)

      expect(service).to receive(:log_response).with(response)
      service.send(:delete_vulnerability_documents)
    end
  end

  describe '#build_query' do
    let(:service) { described_class.new(project_id: test_project_id, traversal_id: test_traversal_id) }

    it 'returns the correct query structure' do
      expected_query = {
        bool: {
          filter: [
            { term: { project_id: test_project_id } },
            { bool: { must_not: { prefix: { traversal_ids: { value: test_traversal_id } } } } }
          ]
        }
      }

      expect(service.send(:build_query)).to eq(expected_query)
    end
  end

  describe '#log_response' do
    let(:service) { described_class.new(project_id: test_project_id, traversal_id: test_traversal_id) }
    let(:mock_logger) { instance_double(Gitlab::Elasticsearch::Logger) }
    let(:structured_payload) do
      {
        project_id: test_project_id,
        traversal_id: test_traversal_id,
        index: vulnerability_index
      }
    end

    before do
      allow(service).to receive_messages(
        logger: mock_logger,
        build_structured_payload: structured_payload
      )
    end

    context 'when response contains failures' do
      let(:response) { { 'failure' => 'Some error', 'deleted' => 0 } }

      it 'logs an error message' do
        expected_payload = structured_payload.merge(
          failure: 'Some error',
          message: 'Failed to delete data for project transfer'
        )

        expect(mock_logger).to receive(:error).with(expected_payload)
        service.send(:log_response, response)
      end
    end

    context 'when response is successful' do
      let(:response) { { 'deleted' => 5 } }

      it 'logs an info message' do
        expected_payload = structured_payload.merge(
          deleted: 5,
          message: 'Successfully deleted duplicate data for project transfer'
        )

        expect(mock_logger).to receive(:info).with(expected_payload)
        service.send(:log_response, response)
      end
    end
  end
end
