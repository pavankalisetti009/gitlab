# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::Ingestion::Tasks::IngestVulnerabilityStatistics, feature_category: :vulnerability_management do
  describe '#execute' do
    let_it_be(:pipeline) { create(:ci_pipeline) }
    let_it_be_with_refind(:project) { pipeline.project }
    let_it_be(:tracked_context) { create(:security_project_tracked_context, :default, project: project) }
    let_it_be(:security_finding_1) { create(:security_finding, severity: :critical) }
    let_it_be(:security_finding_2) { create(:security_finding, severity: :medium) }
    let_it_be(:security_finding_3) { create(:security_finding, severity: :low) }
    let_it_be(:security_finding_4) { create(:security_finding, severity: :info) }
    let_it_be(:finding_map_1) { create(:finding_map, :new_record, security_finding: security_finding_1, pipeline: pipeline, tracked_context: tracked_context) }
    let_it_be(:finding_map_2) { create(:finding_map, :new_record, security_finding: security_finding_2, pipeline: pipeline, tracked_context: tracked_context) }
    let_it_be(:finding_map_3) { create(:finding_map, :with_finding, security_finding: security_finding_3, pipeline: pipeline, tracked_context: tracked_context) }
    let_it_be(:finding_map_4) { create(:finding_map, :new_record, security_finding: security_finding_4, pipeline: pipeline, tracked_context: tracked_context) }

    let_it_be(:other_project) { create(:project, archived: true) }
    let_it_be(:other_pipeline) { create(:ci_pipeline, project: other_project) }
    let_it_be(:other_tracked_context) { create(:security_project_tracked_context, :tracked, project: other_project) }
    let_it_be(:other_security_finding_1) { create(:security_finding, severity: :critical) }
    let_it_be(:other_security_finding_2) { create(:security_finding, severity: :medium) }
    let_it_be(:other_security_finding_3) { create(:security_finding, severity: :low) }
    let_it_be(:other_finding_map_1) { create(:finding_map, :new_record, security_finding: other_security_finding_1, pipeline: other_pipeline, tracked_context: other_tracked_context) }
    let_it_be(:other_finding_map_2) { create(:finding_map, :new_record, security_finding: other_security_finding_2, pipeline: other_pipeline, tracked_context: other_tracked_context) }
    let_it_be(:other_finding_map_3) { create(:finding_map, :with_finding, security_finding: other_security_finding_3, pipeline: other_pipeline, tracked_context: other_tracked_context) }

    subject(:ingest_statistics) { described_class.new(pipeline, finding_maps).execute }

    context 'when there is no statistics record for the project' do
      context 'when there are neither new nor transitioned to detected vulnerabilities' do
        let(:finding_maps) { [finding_map_3, other_finding_map_3] }

        it 'does not create a new Vulnerabilities::Statistic record' do
          expect { ingest_statistics }
            .to not_change { project.reload_vulnerability_statistic }.from(nil)
            .and not_change { other_project.reload_vulnerability_statistic }.from(nil)
        end
      end

      context 'when there are new vulnerabilities' do
        let(:finding_maps) do
          [finding_map_1, finding_map_2, finding_map_3, finding_map_4,
            other_finding_map_1, other_finding_map_2, other_finding_map_3]
        end

        it 'creates a new Vulnerabilities::Statistic record' do
          expect { ingest_statistics }
            .to change { project.reload_vulnerability_statistic }.from(nil)
            .and change { other_project.reload_vulnerability_statistic }.from(nil)
        end

        it 'sets the correct attributes for the recently created record' do
          ingest_statistics

          expect(project.vulnerability_statistic).to have_attributes(
            total: 3,
            critical: 1,
            high: 0,
            unknown: 0,
            medium: 1,
            low: 0,
            info: 1,
            letter_grade: 'f',
            archived: project.archived,
            traversal_ids: project.namespace.traversal_ids,
            security_project_tracked_context_id: tracked_context.id
          )

          expect(other_project.vulnerability_statistic).to have_attributes(
            total: 2,
            critical: 1,
            high: 0,
            unknown: 0,
            medium: 1,
            low: 0,
            info: 0,
            letter_grade: 'f',
            archived: other_project.archived,
            traversal_ids: other_project.namespace.traversal_ids,
            security_project_tracked_context_id: other_tracked_context.id
          )
        end

        it 'updates security_inventory_filters table correctly' do
          expect { ingest_statistics }.to change { Security::InventoryFilter.count }.from(0).to(1)

          expect(Security::InventoryFilter.by_project_id(project.id).first).to have_attributes(
            total: 3, critical: 1, high: 0, unknown: 0, medium: 1, low: 0, info: 1,
            archived: project.archived, traversal_ids: project.namespace.traversal_ids,
            project_name: project.name)

          expect(Security::InventoryFilter.by_project_id(other_project.id).first).to be_nil
        end
      end

      context 'when there are vulnerabilities transitioned to detected' do
        let(:finding_maps) { [finding_map_1] }

        before do
          finding_map_1.transitioned_to_detected = true
        end

        it 'creates a new Vulnerabilities::Statistic record' do
          expect { ingest_statistics }.to change { project.reload_vulnerability_statistic }.from(nil)
        end

        it 'sets the correct attributes for the recently created record' do
          ingest_statistics

          expect(project.vulnerability_statistic).to have_attributes(total: 1, critical: 1, high: 0, unknown: 0, medium: 0, low: 0, info: 0, letter_grade: 'f')
        end
      end
    end

    context 'when there are already a statistics record for the project' do
      let_it_be(:vulnerability_statistic) { create(:vulnerability_statistic, :grade_c, project: project) }
      let_it_be(:other_vulnerability_statistic) { create(:vulnerability_statistic, :grade_c, project: other_project) }

      let_it_be(:project_inventory_filter) do
        create(:security_inventory_filters, project: project,
          total: vulnerability_statistic.total,
          critical: vulnerability_statistic.critical,
          high: vulnerability_statistic.high,
          medium: vulnerability_statistic.medium,
          low: vulnerability_statistic.low,
          info: vulnerability_statistic.info,
          unknown: vulnerability_statistic.unknown)
      end

      let_it_be(:other_project_inventory_filter) do
        create(:security_inventory_filters, project: other_project,
          total: other_vulnerability_statistic.total,
          critical: other_vulnerability_statistic.critical,
          high: other_vulnerability_statistic.high,
          medium: other_vulnerability_statistic.medium,
          low: other_vulnerability_statistic.low,
          info: other_vulnerability_statistic.info,
          unknown: other_vulnerability_statistic.unknown)
      end

      context 'when there are neither new nor transitioned to detected vulnerabilities' do
        let(:finding_maps) { [finding_map_3, other_finding_map_3] }

        it 'does not create a new record and does not change the existing record' do
          expect { ingest_statistics }.to not_change { vulnerability_statistic.reload.letter_grade }
                                      .and not_change { vulnerability_statistic.reload.low }
                                      .and not_change { vulnerability_statistic.reload.total }
                                      .and not_change { other_vulnerability_statistic.reload.letter_grade }
                                      .and not_change { other_vulnerability_statistic.reload.low }
                                      .and not_change { other_vulnerability_statistic.reload.total }
                                      .and not_change { Vulnerabilities::Statistic.count }
        end
      end

      context 'when there are new vulnerabilities' do
        let(:finding_maps) do
          [finding_map_1, finding_map_2, finding_map_3,
            other_finding_map_1, other_finding_map_2, other_finding_map_3]
        end

        it 'does not create a new record and updates the existing one' do
          expect { ingest_statistics }.to change { vulnerability_statistic.reload.letter_grade }.from('c').to('f')
                                      .and change { vulnerability_statistic.reload.critical }.from(0).to(1)
                                      .and change { vulnerability_statistic.reload.medium }.from(1).to(2)
                                      .and change { vulnerability_statistic.reload.total }.from(1).to(3)
                                      .and change { other_vulnerability_statistic.reload.letter_grade }.from('c').to('f')
                                      .and change { other_vulnerability_statistic.reload.critical }.from(0).to(1)
                                      .and change { other_vulnerability_statistic.reload.medium }.from(1).to(2)
                                      .and change { other_vulnerability_statistic.reload.total }.from(1).to(3)
                                      .and not_change { Vulnerabilities::Statistic.count }
        end

        it 'updates security_inventory_filters table correctly' do
          expect { ingest_statistics }.to change { project_inventory_filter.reload.total }.from(1).to(3)
            .and change { project_inventory_filter.reload.critical }.from(0).to(1)
            .and change { project_inventory_filter.reload.medium }.from(1).to(2)
            .and not_change { project_inventory_filter.reload.high }.from(0)
            .and not_change { project_inventory_filter.reload.low }.from(0)
            .and not_change { project_inventory_filter.reload.info }.from(0)
            .and not_change { project_inventory_filter.reload.unknown }.from(0)
            .and not_change { project_inventory_filter.reload.archived }.from(project.archived)
            .and not_change { project_inventory_filter.reload.traversal_ids }.from(project.namespace.traversal_ids)
            .and not_change { project_inventory_filter.reload.project_name }.from(project.name)
            .and not_change { other_project_inventory_filter.reload.total }.from(1)
            .and not_change { other_project_inventory_filter.reload.critical }.from(0)
            .and not_change { other_project_inventory_filter.reload.medium }.from(1)
            .and not_change { other_project_inventory_filter.reload.high }.from(0)
            .and not_change { other_project_inventory_filter.reload.unknown }.from(0)
            .and not_change { other_project_inventory_filter.reload.low }.from(0)
            .and not_change { other_project_inventory_filter.reload.info }.from(0)
            .and not_change { other_project_inventory_filter.reload.archived }.from(other_project.archived)
            .and not_change { other_project_inventory_filter.reload.traversal_ids }.from(other_project.namespace.traversal_ids)
            .and not_change { other_project_inventory_filter.reload.project_name }.from(other_project.name)
            .and not_change { Security::InventoryFilter.count }
        end
      end

      context 'when there are vulnerabilities transitioned to detected' do
        let(:finding_maps) { [finding_map_1] }

        before do
          finding_map_1.transitioned_to_detected = true
        end

        it 'does not create a new record and updates the existing one' do
          expect { ingest_statistics }.to change { vulnerability_statistic.reload.letter_grade }.from('c').to('f')
                                      .and change { vulnerability_statistic.reload.critical }.from(0).to(1)
                                      .and change { vulnerability_statistic.reload.total }.from(1).to(2)
                                      .and not_change { vulnerability_statistic.reload.medium }.from(1)
                                      .and not_change { Vulnerabilities::Statistic.count }
        end
      end
    end
  end
end
