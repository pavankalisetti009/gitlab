# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::Ingestion::Tasks::IngestVulnerabilityReads::Upsert, feature_category: :vulnerability_management do
  let_it_be(:user) { create(:user) }
  let_it_be_with_refind(:project) { create(:project) }
  let_it_be_with_refind(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:tracked_context) { create(:security_project_tracked_context, :tracked, project: project) }
  let_it_be(:location) { create(:ci_reports_security_locations_sast, start_line: 29, end_line: 29) }
  let_it_be(:scanner) { build(:ci_reports_security_scanner, external_id: 'scanner', name: 'Scanner') }
  let_it_be_with_refind(:vulnerability) { create_vulnerability }

  let(:external_type) { 'cve' }
  let(:external_id) { 'CVE-2023-XXXX' }
  let(:identifier_name) { external_id }

  let(:ci_reports_security_identifier) do
    create(:ci_reports_security_identifier, external_id: external_id,
      external_type: external_type, name: identifier_name)
  end

  let(:identifier) do
    create(:vulnerabilities_identifier, external_id: external_id, external_type: external_type,
      name: identifier_name, fingerprint: ci_reports_security_identifier.fingerprint)
  end

  let(:ci_reports_security_finding) do
    create(:ci_reports_security_finding, identifiers: [ci_reports_security_identifier],
      location: location, scanner: scanner)
  end

  let_it_be(:vulnerability_scanner) { create(:vulnerabilities_scanner, external_id: 'scanner', name: 'Scanner') }
  let!(:vulnerability_finding) do
    create(
      :vulnerabilities_finding,
      vulnerability: vulnerability,
      project: pipeline.project,
      primary_identifier: identifier,
      identifiers: [identifier],
      location_fingerprint: location.fingerprint,
      scanner: vulnerability_scanner
    )
  end

  let(:security_finding) { create(:security_finding, scanner: vulnerability_scanner) }
  let!(:finding_map) do
    create(:finding_map,
      pipeline: pipeline,
      tracked_context: tracked_context,
      security_finding: security_finding,
      report_finding: ci_reports_security_finding)
  end

  let(:create_service) { described_class.new(pipeline, [finding_map]) }

  before do
    finding_map.vulnerability_id = vulnerability.id
    vulnerability.vulnerability_read&.destroy!
  end

  subject(:execute) { create_service.execute }

  describe 'creating vulnerability_read record' do
    it 'creates a vulnerability_read record' do
      expect { execute }.to change { Vulnerabilities::Read.count }.by(1)
    end

    it 'associates the vulnerability_read with the vulnerability' do
      execute

      expect(vulnerability.reload.vulnerability_read).to be_present
    end

    it 'sets the correct attributes on the vulnerability_read' do
      execute
      vulnerability_read = vulnerability.reload.vulnerability_read

      expect(vulnerability_read).to have_attributes(
        vulnerability_id: vulnerability.id,
        project_id: project.id,
        security_project_tracked_context_id: tracked_context.id,
        scanner: vulnerability_scanner,
        report_type: vulnerability.report_type,
        severity: vulnerability.severity,
        state: vulnerability.state,
        traversal_ids: project.namespace.traversal_ids,
        archived: project.archived,
        identifier_names: [identifier_name]
      )
    end
  end

  describe 'owasp_top_10 assignment' do
    let(:external_type) { 'owasp' }
    let(:external_id) { 'A1:2017-Injection' }

    shared_examples 'sets owasp_top_10 correctly' do |expected_value|
      it 'sets owasp_top_10 on vulnerability read' do
        execute
        vulnerability_read = vulnerability.reload.vulnerability_read

        expect(vulnerability_read.owasp_top_10).to eq(expected_value)
      end
    end

    shared_examples 'sets owasp_top_10 to undefined' do
      it 'sets owasp_top_10 to undefined' do
        execute
        vulnerability_read = vulnerability.reload.vulnerability_read

        expect(vulnerability_read.owasp_top_10).to eq('undefined')
      end
    end

    context 'with valid owasp identifier' do
      context 'for 2017 external_id without name' do
        let(:external_id) { 'A1:2017' }

        it_behaves_like 'sets owasp_top_10 correctly', 'A1:2017-Injection'
      end

      context 'for 2021 external_id without name' do
        let(:external_id) { 'A3:2021' }

        it_behaves_like 'sets owasp_top_10 correctly', 'A3:2021-Injection'
      end

      context 'for 2017 external_id with name' do
        it_behaves_like 'sets owasp_top_10 correctly', 'A1:2017-Injection'
      end

      context 'for 2021 external_id with name' do
        let(:external_id) { 'A3:2021-Injection' }

        it_behaves_like 'sets owasp_top_10 correctly', 'A3:2021-Injection'
      end

      context 'when primary identifier is not owasp identifier' do
        let(:external_type) { 'cve' }
        let(:external_id) { 'CVE-2023-XXXX' }
        let(:owasp_external_id) { 'A1:2017-Injection' }

        let(:ci_reports_security_owasp_identifier) do
          create(:ci_reports_security_identifier, external_id: owasp_external_id, external_type: 'owasp')
        end

        let(:ci_reports_security_finding) do
          create(:ci_reports_security_finding, identifiers:
            [ci_reports_security_identifier, ci_reports_security_owasp_identifier],
            location: location, scanner: scanner)
        end

        let(:owasp_identifier) do
          create(:vulnerabilities_identifier, external_id: owasp_external_id, external_type: 'owasp',
            fingerprint: ci_reports_security_owasp_identifier.fingerprint)
        end

        let!(:vulnerability_finding) do
          create(:vulnerabilities_finding, vulnerability: vulnerability, project: pipeline.project,
            primary_identifier: identifier,
            identifiers: [identifier, owasp_identifier],
            location_fingerprint: location.fingerprint,
            scanner: vulnerability_scanner)
        end

        it_behaves_like 'sets owasp_top_10 correctly', 'A1:2017-Injection'
      end
    end

    context 'with invalid owasp identifier' do
      context 'for invalid priority label' do
        let(:external_id) { 'A1' }

        it_behaves_like 'sets owasp_top_10 to undefined'
      end

      context 'for invalid year' do
        let(:external_id) { 'A1:2010' }

        it_behaves_like 'sets owasp_top_10 to undefined'
      end

      context 'for invalid external_id with correct label year and incorrect name' do
        let(:external_id) { 'A1:2021-Injection' }

        it_behaves_like 'sets owasp_top_10 to undefined'
      end
    end

    context 'with non owasp identifier' do
      let(:external_type) { 'cve' }
      let(:external_id) { 'CVE-2023-XXXX' }

      it_behaves_like 'sets owasp_top_10 to undefined'
    end
  end

  describe 'has_vulnerability_resolution assignment' do
    context 'when the report type is not supported' do
      let(:external_type) { 'cwe' }
      let(:external_id) { '23' }
      let(:ci_reports_security_finding) do
        create(
          :ci_reports_security_finding,
          report_type: :dast,
          identifiers: [ci_reports_security_identifier],
          location: location,
          scanner: scanner)
      end

      it 'sets has_vulnerability_resolution to false' do
        execute
        vulnerability_read = vulnerability.reload.vulnerability_read

        expect(vulnerability_read.has_vulnerability_resolution).to be false
      end
    end

    context 'when the CWE is not supported' do
      let(:external_type) { 'cwe' }
      let(:external_id) { 'unsupported' }

      it 'sets has_vulnerability_resolution to false' do
        execute
        vulnerability_read = vulnerability.reload.vulnerability_read

        expect(vulnerability_read.has_vulnerability_resolution).to be false
      end
    end

    context 'when the report is sast and a supported CWE' do
      let(:external_type) { 'cwe' }
      let(:external_id) { '23' }
      let(:identifier_name) { 'CWE-23' }

      it 'sets has_vulnerability_resolution to true' do
        execute
        vulnerability_read = vulnerability.reload.vulnerability_read

        expect(vulnerability_read.has_vulnerability_resolution).to be true
      end
    end
  end

  describe 'identifier_names assignment' do
    let(:external_type) { 'cwe' }
    let(:external_id) { '1035' }
    let(:identifier_name) { 'CWE-1035' }

    it 'sets identifier_names from the identifiers' do
      execute
      vulnerability_read = vulnerability.reload.vulnerability_read

      expect(vulnerability_read.identifier_names).to eq([identifier_name])
    end

    context 'with multiple identifiers' do
      let(:external_id_b) { '937' }
      let(:external_type_b) { 'cwe' }
      let(:identifier_name_b) { 'CWE-937' }

      let(:ci_reports_security_identifier_b) do
        create(:ci_reports_security_identifier, external_id: external_id_b,
          external_type: external_type_b, name: identifier_name_b)
      end

      let(:ci_reports_security_finding) do
        create(:ci_reports_security_finding,
          identifiers: [ci_reports_security_identifier, ci_reports_security_identifier_b],
          location: location, scanner: scanner)
      end

      let(:identifier_b) do
        create(:vulnerabilities_identifier, external_id: external_id_b, external_type: external_type_b,
          name: identifier_name_b, fingerprint: ci_reports_security_identifier_b.fingerprint)
      end

      let!(:vulnerability_finding) do
        create(
          :vulnerabilities_finding,
          vulnerability: vulnerability,
          project: pipeline.project,
          primary_identifier: identifier,
          identifiers: [identifier, identifier_b],
          location_fingerprint: location.fingerprint,
          scanner: vulnerability_scanner
        )
      end

      it 'sets identifier_names for all identifiers' do
        execute
        vulnerability_read = vulnerability.reload.vulnerability_read

        expect(vulnerability_read.identifier_names).to match_array([identifier_name, identifier_name_b])
      end
    end
  end

  describe 'when vulnerability_read already exists' do
    let!(:existing_vulnerability_read) do
      create(:vulnerability_read, vulnerability: vulnerability, project: project)
    end

    it 'updates the existing vulnerability_read' do
      expected_attributes = existing_vulnerability_read.attributes.merge({
        'identifier_names' => [external_id],
        'scanner_id' => vulnerability_scanner.id,
        'severity' => vulnerability.severity,
        'uuid' => ci_reports_security_finding.uuid,
        'security_project_tracked_context_id' => tracked_context.id
      })
      execute

      expect(existing_vulnerability_read.reload.attributes).to eq(expected_attributes)
    end
  end

  describe 'N+1 queries' do
    it 'does not cause N+1 queries when processing multiple vulnerabilities' do
      single_vulnerability = create(:vulnerability, project: project, author: user)
      single_finding_map = create(:finding_map, pipeline: pipeline, security_finding: security_finding,
        report_finding: ci_reports_security_finding)
      single_finding_map.vulnerability_id = single_vulnerability.id
      single_service = described_class.new(pipeline, [single_finding_map])

      control = ActiveRecord::QueryRecorder.new { single_service.execute }

      Vulnerabilities::Read.delete_all

      additional_vulnerabilities = create_list(:vulnerability, 2, project: project, author: user)
      additional_finding_maps = additional_vulnerabilities.map do |vulnerability|
        unique_report_finding = create(:ci_reports_security_finding,
          identifiers: [ci_reports_security_identifier],
          location: location,
          scanner: scanner)

        map = create(:finding_map, pipeline: pipeline, security_finding: security_finding,
          report_finding: unique_report_finding)
        map.vulnerability_id = vulnerability.id
        map
      end

      all_finding_maps = [single_finding_map] + additional_finding_maps
      multi_service = described_class.new(pipeline, all_finding_maps)

      expect { multi_service.execute }.not_to exceed_query_limit(control)
    end
  end

  private

  def create_vulnerability(severity: 7, report_type: 0)
    create(:vulnerability,
      project: pipeline.project,
      author: user,
      severity: severity,
      report_type: report_type)
  end
end
