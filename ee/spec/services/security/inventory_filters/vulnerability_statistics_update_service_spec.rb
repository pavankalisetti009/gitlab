# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::InventoryFilters::VulnerabilityStatisticsUpdateService, feature_category: :security_asset_inventories do
  describe '.execute' do
    let(:project_to_severity_counts) { { project1: { critical: 1 } } }
    let(:mock_service_object) { instance_double(described_class, execute: true) }

    subject(:execute_update) { described_class.execute(project_to_severity_counts) }

    before do
      allow(described_class).to receive(:new).with(project_to_severity_counts).and_return(mock_service_object)
    end

    it 'instantiates the service object and calls execute' do
      execute_update

      expect(mock_service_object).to have_received(:execute)
    end
  end

  describe '#execute' do
    let_it_be(:group) { create(:group) }
    let_it_be(:project1) { create(:project, namespace: group, name: 'Project One') }
    let_it_be(:project2) { create(:project, namespace: group, name: 'Project Two', archived: true) }

    let(:project_to_severity_counts) { { project1 => severity_counts } }
    let(:severity_counts) { { 'critical' => 2, 'high' => 1 } }

    subject(:update_statistics) { described_class.new(project_to_severity_counts).execute }

    context 'when project_to_severity_counts is empty' do
      let(:project_to_severity_counts) { {} }

      it 'returns early without executing any queries' do
        expect(Security::InventoryFilter.connection).not_to receive(:execute)

        update_statistics
      end
    end

    context 'when project_to_severity_counts is nil' do
      let(:project_to_severity_counts) { nil }

      it 'returns early without executing any queries' do
        expect(Security::InventoryFilter.connection).not_to receive(:execute)

        update_statistics
      end
    end

    context 'when creating new records' do
      it 'creates security_inventory_filter records with correct values' do
        expect { update_statistics }.to change { Security::InventoryFilter.count }.by(1)

        filter = Security::InventoryFilter.find_by(project_id: project1.id)

        expect(filter).to have_attributes(
          project_id: project1.id,
          project_name: project1.name,
          archived: false,
          traversal_ids: group.traversal_ids,
          total: 3,
          critical: 2,
          high: 1,
          medium: 0,
          low: 0,
          unknown: 0,
          info: 0
        )
      end

      context 'with multiple projects' do
        let(:project_to_severity_counts) do
          {
            project1 => { 'critical' => 1 },
            project2 => { 'medium' => 3, 'low' => 2 }
          }
        end

        it 'creates records for all projects' do
          expect { update_statistics }.to change { Security::InventoryFilter.count }.by(2)

          filter1 = Security::InventoryFilter.find_by(project_id: project1.id)
          filter2 = Security::InventoryFilter.find_by(project_id: project2.id)

          expect(filter1).to have_attributes(
            project_name: project1.name,
            archived: false,
            total: 1,
            critical: 1,
            high: 0,
            medium: 0,
            low: 0
          )

          expect(filter2).to have_attributes(
            project_name: project2.name,
            archived: true,
            total: 5,
            critical: 0,
            high: 0,
            medium: 3,
            low: 2
          )
        end
      end
    end

    context 'when updating existing records' do
      let!(:existing_filter) do
        create(:security_inventory_filters,
          project_id: project1.id,
          project_name: 'Old Name',
          archived: true,
          total: 10,
          critical: 5,
          high: 3,
          medium: 2
        )
      end

      it 'updates project attributes and increments severity counts' do
        update_statistics

        existing_filter.reload

        expect(existing_filter).to have_attributes(
          project_name: project1.name,
          archived: false,
          total: 13,
          critical: 7,
          high: 4,
          medium: 2,
          low: 0,
          unknown: 0,
          info: 0
        )
      end

      context 'with negative diffs' do
        let(:severity_counts) { { 'critical' => -10, 'high' => 2 } }

        it 'uses GREATEST to prevent negative values' do
          update_statistics

          existing_filter.reload

          expect(existing_filter).to have_attributes(
            total: 2,
            critical: 0, # GREATEST(5 + (-10), 0) = 0
            high: 5,
            medium: 2
          )
        end
      end
    end

    context 'when total is provided in counts' do
      let(:severity_counts) { { 'total' => 999, 'critical' => 2, 'high' => 1 } }

      it 'recalculates total based on severity counts' do
        update_statistics

        filter = Security::InventoryFilter.find_by(project_id: project1.id)

        expect(filter.total).to eq(3)
      end
    end
  end
end
