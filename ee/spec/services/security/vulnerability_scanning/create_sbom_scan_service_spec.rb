# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::CreateSbomScanService, feature_category: :software_composition_analysis do
  let_it_be(:project) { create(:project) }
  let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:job) { create(:ci_build, pipeline: pipeline) }

  let(:service) { described_class.new(job) }
  let(:sbom_file) do
    fixture_file_upload('ee/spec/fixtures/security/vulnerability_scanning/sbom_scans/sbom.json', 'application/json')
  end

  describe '#authorize' do
    let(:max_size) { 10.megabytes }

    before do
      allow(Ci::JobArtifact).to receive(:max_artifact_size).with(type: :cyclonedx, project: project)
        .and_return(max_size)
    end

    context 'when filesize is within limits' do
      let(:filesize) { max_size - 1 }
      let(:expected_headers) { { 'Foo' => 'bar' } }

      before do
        allow(Security::VulnerabilityScanning::SbomScanUploader).to receive(:workhorse_authorize)
          .and_return(expected_headers)
      end

      it 'returns success with authorization headers', :aggregate_failures do
        result = service.authorize(filesize: filesize)

        expect(result).to be_success
        expect(result.payload[:headers]).to eq(expected_headers)
      end
    end

    context 'when filesize exceeds maximum limit' do
      let(:filesize) { 20.megabytes }

      it 'returns error response', :aggregate_failures do
        result = service.authorize(filesize: filesize)

        expect(result).to be_error
        expect(result.message).to eq('file size has reached maximum size limit')
        expect(result.reason).to eq(:payload_too_large)
      end
    end
  end

  describe '#execute' do
    before do
      allow(sbom_file).to receive(:size).and_return(1.megabyte)
      allow(Security::VulnerabilityScanning::ProcessSbomScanWorker).to receive(:perform_async)
      allow(Security::VulnerabilityScanning::ProcessSbomScanThrottledWorker).to receive(:perform_async)
    end

    context 'when file is valid and within size limits' do
      shared_examples 'creates an SbomScan record' do |throttled|
        it "creates an SbomScan record and schedules the #{throttled ? 'throttled' : 'regular'} scan worker",
          :aggregate_failures do
          expect(Gitlab::ApplicationRateLimiter).to receive(:throttled?)
            .with(:dependency_scanning_sbom_scan_api_throttling, scope: project)
            .once.and_return(throttled)

          result = service.execute(sbom_file)
          expect(result).to be_success

          sbom_scan = result.payload[:sbom_scan]
          expect(sbom_scan).to be_persisted
          expect(sbom_scan).to have_attributes({ id: be_present, build: job, project: project, sbom_file: be_present })
          expect(result.payload[:throttled]).to be(throttled)

          if throttled
            expect(result.payload[:project_throttling_resets_in]).to be > 0
            expect(Security::VulnerabilityScanning::ProcessSbomScanThrottledWorker)
              .to have_received(:perform_async).with(sbom_scan.id)
            expect(Security::VulnerabilityScanning::ProcessSbomScanWorker)
              .not_to have_received(:perform_async)
          else
            expect(result.payload[:project_throttling_resets_in]).to eq(0)
            expect(Security::VulnerabilityScanning::ProcessSbomScanWorker)
              .to have_received(:perform_async).with(sbom_scan.id)
            expect(Security::VulnerabilityScanning::ProcessSbomScanThrottledWorker)
              .not_to have_received(:perform_async)
          end
        end
      end

      context 'when not throttled' do
        it_behaves_like 'creates an SbomScan record', false
      end

      context 'when throttled' do
        it_behaves_like 'creates an SbomScan record', true
      end
    end

    context 'on failure' do
      shared_examples_for 'failed sbom scan creation' do |expected_message, expected_reason|
        it 'returns error response with appropriate message and reason' do
          result = service.execute(sbom_file)

          expect(result).to be_error
          expect(result.message).to eq(expected_message)
          expect(result.reason).to eq(expected_reason)
        end

        it 'does not create an SBOM scan' do
          expect { service.execute(sbom_file) }
            .not_to change { Security::VulnerabilityScanning::SbomScan.count }
        end

        it 'does not schedule the processing worker' do
          expect(Security::VulnerabilityScanning::ProcessSbomScanWorker)
            .not_to receive(:perform_async)

          service.execute(sbom_file)
        end
      end

      context 'when file size exceeds maximum limit' do
        before do
          allow(sbom_file).to receive(:size).and_return(20.megabytes)
        end

        it_behaves_like 'failed sbom scan creation', 'file size has reached maximum size limit', :payload_too_large
      end

      context 'when SBOM scan creation fails due to validation errors' do
        let(:sbom_scan) { instance_double(Security::VulnerabilityScanning::SbomScan) }
        let(:validation_errors) { ['Build must exist', 'Project must exist'] }

        before do
          allow(sbom_scan).to receive_messages(persisted?: false, store_sbom_file!: true)
          allow(sbom_scan).to receive_message_chain(:errors, :full_messages).and_return(validation_errors)
          allow(Security::VulnerabilityScanning::SbomScan).to receive(:create).and_return(sbom_scan)
        end

        it_behaves_like 'failed sbom scan creation', ['Build must exist', 'Project must exist'], :unprocessable_entity
      end

      context 'when file storage fails' do
        before do
          allow_next_instance_of(Security::VulnerabilityScanning::SbomScan) do |sbom_scan|
            allow(sbom_scan).to receive(:store_sbom_file!).and_raise(StandardError.new('Storage failed'))
          end
        end

        it 'raises the storage error' do
          expect { service.execute(sbom_file) }
            .to raise_error(StandardError, 'Storage failed')
        end
      end
    end
  end
end
