# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::ProcessSbomScanService, feature_category: :software_composition_analysis do
  let_it_be(:project) { create(:project) }
  let_it_be(:pipeline) { create(:ci_pipeline, project: project) }
  let_it_be(:build) { create(:ci_build, pipeline: pipeline) }

  let(:service) { described_class.new(sbom_scan) }
  let(:security_report) do
    ::Gitlab::Ci::Reports::Security::Report.new(:dependency_scanning, pipeline, Time.zone.now).tap do |report|
      report.scanner = Gitlab::VulnerabilityScanning::SecurityScanner.fabricate
    end
  end

  describe 'error classes' do
    where(:error_class, :expected_retry_delay, :expected_retryable) do
      [
        [Security::VulnerabilityScanning::ProcessSbomScanService::SbomScanBaseError, 0, true],
        [Security::VulnerabilityScanning::ProcessSbomScanService::SbomFileNotAvailableError, 5.seconds, true],
        [Security::VulnerabilityScanning::ProcessSbomScanService::SbomScanFailedError, 0, true],
        [Security::VulnerabilityScanning::ProcessSbomScanService::NonRetryableError, 0, false],
        [Security::VulnerabilityScanning::ProcessSbomScanService::UnprocessableSbomError, 0, false],
        [Security::VulnerabilityScanning::ProcessSbomScanService::InvalidSbomError, 0, false]
      ]
    end

    with_them do
      subject(:error) { error_class.new('Test message') }

      it 'has correct retry behavior' do
        expect(error.retry_delay).to eq(expected_retry_delay)
        expect(error.retryable?).to eq(expected_retryable)
      end

      it 'preserves error message' do
        expect(error.message).to eq('Test message')
      end

      it 'inherits from StandardError' do
        expect(error).to be_a(StandardError)
      end
    end
  end

  describe '#execute' do
    before do
      allow(::Gitlab::VulnerabilityScanning::SecurityReportBuilder).to receive_message_chain(:new, :execute)
        .and_return(security_report)
    end

    context 'when SBOM file is available' do
      let(:sbom_scan) { create(:sbom_scan, :with_sbom_file, build: build) }
      let(:finding) { build_stubbed(:ci_reports_security_finding, :dependency_scanning) }
      let(:expected_scan_results) do
        API::Entities::Security::VulnerabilityScanning::SbomScanResult.represent(security_report).to_json
      end

      before do
        allow(security_report).to receive(:findings).and_return([finding])
      end

      it 'performs the scan successfully', :aggregate_failures do
        service.execute

        sbom_scan.reload
        expect(sbom_scan.finished?).to be_truthy
        expect(sbom_scan.result_file).to be_present
        expect(sbom_scan.result_file.filename).to eq('sbom_scan_result.json')
        expect(sbom_scan.result_file.read).to eq(expected_scan_results)
      end
    end

    context 'on failure' do
      before do
        allow(Gitlab::ErrorTracking).to receive(:track_and_raise_exception).and_call_original
      end

      shared_examples_for 'failed sbom scan' do |raised_error, error_message|
        it 'tracks and raises the error', :aggregate_failures do
          expect { service.execute }.to raise_error(raised_error, error_message)

          expect(Gitlab::ErrorTracking).to have_received(:track_and_raise_exception)
            .with(instance_of(raised_error),
              sbom_scan_id: sbom_scan.id,
              project_id: project.id,
              pipeline_id: pipeline.id)

          sbom_scan.reload
          expect(sbom_scan.result_file).to be_blank
        end
      end

      context 'when uploaded SBOM file is not available' do
        let(:sbom_scan) { create(:sbom_scan, build: build) }

        it_behaves_like 'failed sbom scan',
          ::Security::VulnerabilityScanning::ProcessSbomScanService::SbomFileNotAvailableError,
          %r{SBOM file is not available yet for sbom scan \d+}
      end

      context 'when SBOM file processing fails' do
        let(:sbom_scan) { create(:sbom_scan, :with_invalid_sbom_file, build: build) }

        before do
          allow(sbom_scan.sbom_file).to receive(:read).and_raise(StandardError.new('Parsing failed'))
        end

        it_behaves_like 'failed sbom scan',
          ::Security::VulnerabilityScanning::ProcessSbomScanService::UnprocessableSbomError,
          %r{The provided SBOM report can't be processed: Parsing failed}
      end

      context 'when uploaded SBOM file is invalid' do
        let(:sbom_scan) { create(:sbom_scan, :with_sbom_file_having_unsupported_cyclonedx_spec, build: build) }

        it_behaves_like 'failed sbom scan',
          ::Security::VulnerabilityScanning::ProcessSbomScanService::InvalidSbomError,
          %r{The provided SBOM report is invalid and has the following errors: .*}
      end

      context 'when uploaded SBOM file does not provide the GitLab cycloneDX taxonomy' do
        let(:sbom_scan) { create(:sbom_scan, :with_sbom_missing_ds_taxonomy, build: build) }

        it_behaves_like 'failed sbom scan',
          ::Security::VulnerabilityScanning::ProcessSbomScanService::InvalidSbomError,
          "The provided SBOM report must follow the GitLab CycloneDX property taxonomy for Dependency Scanning."
      end

      context 'when security report generation fails' do
        let(:sbom_scan) { create(:sbom_scan, :with_sbom_file, build: build) }
        let(:security_report) { nil }

        it_behaves_like 'failed sbom scan',
          ::Security::VulnerabilityScanning::ProcessSbomScanService::SbomScanFailedError,
          %r{Failed to perform a vulnerability scan for sbom scan \d+$}
      end

      context 'when file storage fails' do
        let(:sbom_scan) { create(:sbom_scan, :with_sbom_file, build: build) }

        before do
          allow(sbom_scan).to receive(:store_result_file!).and_raise(StandardError.new('Storage failed'))
        end

        it_behaves_like 'failed sbom scan', StandardError, 'Storage failed'
      end
    end
  end
end
