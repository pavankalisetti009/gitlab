# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityMergeRequestLinks::DestroyService, feature_category: :vulnerability_management do
  include AccessMatchersGeneric

  let_it_be(:user) { create(:user) }
  let_it_be(:project) { create(:project) }
  let_it_be(:vulnerability) { create(:vulnerability, project: project) }
  let_it_be(:merge_request) { create(:merge_request, source_project: project) }
  let(:merge_request_link) do
    create(:vulnerabilities_merge_request_link, vulnerability: vulnerability, merge_request: merge_request)
  end

  let(:params) { { merge_request_link: merge_request_link } }
  let(:service) { described_class.new(project: project, current_user: user, params: params) }

  before do
    stub_licensed_features(security_dashboard: true)
  end

  subject(:destroy_merge_request_link) { service.execute }

  context 'with an authorized user with proper permissions' do
    before_all do
      project.add_developer(user)
    end

    context 'with valid params' do
      it 'deletes the specified vulnerability-merge request link' do
        link = merge_request_link
        expect(link).to be_persisted

        response = destroy_merge_request_link

        expect(response).to be_success
        expect { link.reload }.to raise_error(ActiveRecord::RecordNotFound)
      end

      it 'updates has_merge_request in vulnerability read record' do
        vulnerability_read = Vulnerabilities::Read.find_by(vulnerability_id: vulnerability.id) ||
          create(:vulnerability_read, vulnerability: vulnerability, has_merge_request: true)

        destroy_merge_request_link

        vulnerability_read.reload
        expect(vulnerability_read.has_merge_request).to be(false)
      end

      context 'when vulnerability has multiple merge request links' do
        before do
          create(:vulnerabilities_merge_request_link, vulnerability: vulnerability)
        end

        it 'keeps has_merge_request as true in vulnerability read record' do
          vulnerability_read = Vulnerabilities::Read.find_by(vulnerability_id: vulnerability.id) ||
            create(:vulnerability_read, vulnerability: vulnerability, has_merge_request: true)

          destroy_merge_request_link

          vulnerability_read.reload
          expect(vulnerability_read.has_merge_request).to be(true)
        end
      end

      context 'when turn_off_vulnerability_read_create_db_trigger_function feature flag is disabled' do
        before do
          stub_feature_flags(turn_off_vulnerability_read_create_db_trigger_function: false)
        end

        it 'still deletes the merge request link successfully' do
          link = merge_request_link
          expect(link).to be_persisted

          response = destroy_merge_request_link

          expect(response).to be_success
          expect { link.reload }.to raise_error(ActiveRecord::RecordNotFound)
        end
      end
    end

    context 'with missing merge_request_link' do
      let(:merge_request_link) { nil }

      it 'raises an access denied error' do
        expect { destroy_merge_request_link }.to raise_error(Gitlab::Access::AccessDeniedError)
      end
    end

    context 'when the merge_request_link fails to be destroyed' do
      before do
        allow(merge_request_link).to receive(:destroy).and_return(false)
        allow(merge_request_link).to receive_message_chain(:errors, :full_messages).and_return(['Destruction failed'])
      end

      it 'responds with an error' do
        expect { destroy_merge_request_link }.not_to change { Vulnerabilities::MergeRequestLink.count }

        response = destroy_merge_request_link

        expect(response).to be_error
        expect(response.message).to eq 'Destruction failed'
        expect(response.payload[:errors]).to eq ['Destruction failed']
      end
    end

    context 'when security dashboard feature is disabled' do
      before do
        stub_licensed_features(security_dashboard: false)
      end

      it 'raises an "access denied" error' do
        expect { destroy_merge_request_link }.to raise_error(Gitlab::Access::AccessDeniedError)
      end
    end
  end

  describe 'permissions' do
    context 'when admin mode enabled', :enable_admin_mode do
      it { expect { destroy_merge_request_link }.to be_allowed_for(:admin) }
    end

    context 'when admin mode disabled' do
      it { expect { destroy_merge_request_link }.to be_denied_for(:admin) }
    end

    it { expect { destroy_merge_request_link }.to be_allowed_for(:owner).of(project) }
    it { expect { destroy_merge_request_link }.to be_allowed_for(:maintainer).of(project) }
    it { expect { destroy_merge_request_link }.to be_allowed_for(:developer).of(project) }

    it { expect { destroy_merge_request_link }.to be_denied_for(:auditor) }
    it { expect { destroy_merge_request_link }.to be_denied_for(:reporter).of(project) }
    it { expect { destroy_merge_request_link }.to be_denied_for(:guest).of(project) }
    it { expect { destroy_merge_request_link }.to be_denied_for(:anonymous) }
  end
end
